=== CODE-GRAPH RAG SESSION LOG ===

USER: T√¨m code checkout/payment
ASSISTANT: D·ª±a tr√™n vi·ªác t√¨m ki·∫øm codebase, t√¥i ƒë√£ t√¨m th·∫•y **code checkout** nh∆∞ng **kh√¥ng c√≥ payment gateway**. ƒê√¢y l√† h·ªá th·ªëng **checkout-only** (ch·ªâ t·∫°o ƒë∆°n h√†ng, kh√¥ng x·ª≠ l√Ω thanh to√°n).

## üìã Code Checkout

### 1. **Frontend - React Store** (`src/Apps/App.Store`)

**Checkout UI Component**:
- `src/Apps/App.Store/src/pages/Checkout.jsx` - Trang checkout ch√≠nh
- `src/Apps/App.Store/src/components/checkout/CheckoutSection.jsx` - Form checkout
- `src/Apps/App.Store/src/services/basketService.js` - API service

**CheckoutSection.jsx** - Ch·ª©c nƒÉng ch√≠nh:
```javascript
// API call ƒë·ªÉ checkout basket
const handleSubmit = async (values, { setSubmitting }) => {
  const checkoutData = {
    customer: {
      name: `${values.firstName} ${values.lastName}`,
      email: values.email,
      phoneNumber: values.phoneNumber,
    },
    shippingAddress: {
      addressLine: values.addressLine,
      subdivision: values.subdivision,
      city: values.city,
      stateOrProvince: values.stateOrProvince,
      country: values.country,
      postalCode: values.postalCode,
    },
    couponCode: couponApplied && couponData ? couponData.couponCode : null,
  };

  const response = await basketService.checkoutBasket(checkoutData);
  // Hi·ªÉn th·ªã modal th√†nh c√¥ng v·ªõi order number
};
```

### 2. **Backend - Basket Service** (`src/Services/Basket`)

**API Endpoint**:
- `src/Services/Basket/Api/Basket.Api/Endpoints/BasketCheckout.cs` - REST API endpoint
- `POST /basket/checkout`

**Command Handler**:
- `src/Services/Basket/Core/Basket.Application/Features/Basket/Commands/BasketCheckoutCommand.cs`

**Quy tr√¨nh x·ª≠ l√Ω**:
1. Validate customer info & shipping address
2. Ki·ªÉm tra basket c√≥ items
3. √Åp d·ª•ng coupon code (n·∫øu c√≥)
4. Publish `BasketCheckoutDomainEvent`
5. X√≥a basket sau khi checkout
6. Push integration event v√†o outbox

### 3. **Backend - Order Service** (`src/Services/Order`)

**Consumer** x·ª≠ l√Ω event t·ª´ Basket:
- `src/Services/Order/Worker/Order.Worker.Consumer/EventHandlers/Integrations/BasketCheckoutIntegrationEventHandler.cs`

**Quy tr√¨nh**:
1. Nh·∫≠n `BasketCheckoutIntegrationEvent` t·ª´ RabbitMQ
2. Check idempotency (tr√°nh x·ª≠ l√Ω tr√πng l·∫∑p)
3. T·∫°o order v·ªõi `CreateOrderCommand`
4. L∆∞u v√†o database (SQL Server)

**Order Entity**:
- `src/Services/Order/Core/Order.Domain/Entities/OrderEntity.cs`
- Status: Pending ‚Üí Confirmed ‚Üí Processing ‚Üí Shipped ‚Üí Delivered
- H·ªó tr·ª£ Cancel v√† Refund

## üîç **KH√îNG C√ì PAYMENT GATEWAY**

Sau khi ki·ªÉm tra to√†n b·ªô codebase:
- **Kh√¥ng c√≥ service Payment**
- **Kh√¥ng c√≥ integration v·ªõi Stripe, PayPal, VNPay, Momo**
- **Kh√¥ng c√≥ payment processing logic**

File `CheckoutSection.jsx` c√≥ ƒëo·∫°n comment v·ªÅ payment nh∆∞ng b·ªã disable:
```javascript
{/* <h4 className="fz-checkout-title">{t('checkout.paymentInformation')}</h4>
<div className="d-flex payment-area align-items-center">
  <input
    type="text"
    name="payment-option"
    id="checkout-payment-option"
    placeholder="xxxx xxxx xxxx xxxx"
  />
  <i className="fa-light fa-credit-card"></i>
</div> */}
```

## üìä **Quy tr√¨nh Checkout hi·ªán t·∫°i**:

```
UserÂ°´ÂÜôË°®Âçï 
    ‚Üì
Frontend: POST /basket/checkout
    ‚Üì
Basket Service: Validate & Publish Event
    ‚Üì
RabbitMQ: BasketCheckoutIntegrationEvent
    ‚Üì
Order Service Consumer: T·∫°o Order
    ‚Üì
Database: L∆∞u Order (status: Pending)
    ‚Üì
Frontend: Hi·ªÉn th·ªã Order Success Modal v·ªõi Order No
```

## üí° **ƒê·ªÉ th√™m payment, b·∫°n c·∫ßn**:

1. T·∫°o **Payment Service** m·ªõi
2. T√≠ch h·ª£p payment gateway (Stripe/VNPay/Momo)
3. Th√™m step processing payment sau khi t·∫°o order
4. Update order status d·ª±a tr√™n payment result
5. Implement **Saga Pattern** ƒë·ªÉ x·ª≠ l√Ω rollback khi payment th·∫•t b·∫°i

**Microservices hi·ªán c√≥**: Catalog, Basket, Order, Inventory, Discount, Notification, Search, Report, Communication
**Thi·∫øu**: Payment Service
USER: Ph√¢n t√≠ch authentication system trong d·ª± √°n n√†y
ASSISTANT: # üîê Ph√¢n t√≠ch Authentication System trong ProG Coder Shop

## üìã T·ªïng quan

D·ª± √°n s·ª≠ d·ª•ng **Keycloak** l√†m Identity Provider v·ªõi giao th·ª©c **OpenID Connect (OIDC)** v√† **JWT tokens**. ƒê√¢y l√† gi·∫£i ph√°p SSO (Single Sign-On) enterprise-grade h·ªó tr·ª£ ƒëa tenant, role-based access control.

---

## üèóÔ∏è Ki·∫øn tr√∫c Authentication

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     OIDC      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     JWT Bearer     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   React Frontend‚îÇ  ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫  ‚îÇ   Keycloak   ‚îÇ   ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ  Backend APIs   ‚îÇ
‚îÇ  (Keycloak-js)  ‚îÇ              ‚îÇ              ‚îÇ                    ‚îÇ  (.NET 8)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                                  ‚îÇ                                      ‚îÇ
       ‚îÇ                                  ‚îÇ                                      ‚îÇ
       ‚ñº                                  ‚ñº                                      ‚ñº
  Token Store                         JWT Issuer                         Token Validation
  (Cookie)                         (Access Token)                    (JwtBearer Auth)
```

---

## üîë Chi ti·∫øt t·ª´ng th√†nh ph·∫ßn

### 1. **Keycloak Configuration** 

**Realm**: `prog-coder-realm`  
**Client ID**: `prog-coder-client-id`  
**Authority URL**: `http://localhost:8080/realms/prog-coder-realm`  
**Redirect URI**: `http://localhost:3002/` (App.Store)

**Docker Compose Setup** (`docker-compose.yml`):
```yaml
keycloak:
  image: quay.io/keycloak/keycloak:23.0.6
  environment:
    KEYCLOAK_ADMIN: admin
    KEYCLOAK_ADMIN_PASSWORD: 123456789Aa
    KC_DB: postgres
    KC_DB_URL: jdbc:postgresql://postgres-sql/keycloak_db
    KC_HTTP_ENABLED: true
    KC_HOSTNAME_STRICT_HTTPS: false
```

---

### 2. **Frontend Authentication** (`src/Apps/App.Store`)

#### **Keycloak-js Integration**

**File**: `src/Apps/App.Store/src/services/keycloakService.js`

**Kh·ªüi t·∫°o Keycloak**:
```javascript
const keycloakInstance = new Keycloak({
  url: import.meta.env.VITE_KEYCLOAK_URL,      // http://localhost:8080
  realm: import.meta.env.VITE_KEYCLOAK_REALM,  // prog-coder-realm
  clientId: import.meta.env.VITE_KEYCLOAK_CLIENT_ID  // prog-coder-client-id
});

// Initialize with PKCE (Proof Key for Code Exchange)
await initKeycloak({
  onLoad: 'check-sso',
  checkLoginIframe: false,
  pkceMethod: 'S256',
  redirectUri: window.location.origin
});
```

**Quy tr√¨nh Login**:
```javascript
// Redirect to Keycloak login page
keycloak.login({ redirectUri });

// Keycloak redirects back with: ?code=xxx&session_state=xxx
// Keycloak-js handles the callback and exchanges code for tokens
```

**Token Management**:
```javascript
// Token ƒë∆∞·ª£c l∆∞u v√†o cookie (kh√¥ng localStorage ƒë·ªÉ tr√°nh XSS)
setCookie('access_token', keycloak.token, 1);

// Auto refresh token tr∆∞·ªõc khi expired (60s)
setInterval(() => {
  keycloak.updateToken(30); // Refresh n·∫øu token h·∫øt h·∫°n trong 30s
}, 60000);
```

#### **KeycloakContext Provider**

**File**: `src/Apps/App.Store/src/contexts/KeycloakContext.jsx`

**Cung c·∫•p cho to√†n b·ªô app**:
```javascript
const { authenticated, login, logout, getUserInfo, updateToken } = useKeycloak();

// User info ƒë∆∞·ª£c extract t·ª´ JWT token
const userInfo = {
  id: tokenParsed.sub,
  username: tokenParsed.preferred_username,
  email: tokenParsed.email,
  firstName: tokenParsed.given_name,
  lastName: tokenParsed.family_name,
  roles: tokenParsed.realm_access?.roles
};
```

#### **Protected Route**

**File**: `src/Apps/App.Store/src/components/auth/ProtectedRoute.jsx`

```javascript
const ProtectedRoute = ({ children }) => {
  const { authenticated, login, keycloakReady } = useKeycloak();
  
  // T·ª± ƒë·ªông redirect v·ªÅ Keycloak n·∫øu ch∆∞a login
  if (keycloakReady && !authenticated) {
    login({ redirectUri: window.location.origin });
  }
  
  return authenticated ? children : <div>Loading...</div>;
};
```

#### **API Interceptor** 

**File**: `src/Apps/App.Store/src/api/axiosInstance.js`

**T·ª± ƒë·ªông g·∫Øn JWT token v√†o t·∫•t c·∫£ requests**:
```javascript
// Request interceptor
axiosInstance.interceptors.request.use((config) => {
  const token = getCookie('access_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Response interceptor - handle 401
axiosInstance.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 401) {
      // X√≥a cookie, redirect v·ªÅ login
      document.cookie = "access_token=; expires=...";
    }
    return Promise.reject(error);
  }
);
```

---

### 3. **Backend Authentication** (`src/Services/...`)

#### **JWT Bearer Authentication Configuration**

**File**: `src/Shared/BuildingBlocks/Authentication/Extensions/AuthorizationExtension.cs`

```csharp
public static IServiceCollection AddAuthenticationAndAuthorization(
    this IServiceCollection services,
    IConfiguration cfg)
{
    var authority = cfg["Authentication:Authority"];  // http://keycloak:8080/realms/prog-coder-realm
    var audience = cfg["Authentication:Audience"];    // "account"
    
    services.AddAuthentication(options =>
    {
        options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    })
    .AddJwtBearer(options =>
    {
        options.Authority = authority;
        options.Audience = audience;
        options.RequireHttpsMetadata = false; // Development mode
        
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = false,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ClockSkew = TimeSpan.FromSeconds(60),
            NameClaimType = JwtRegisteredClaimNames.Sub,
            RoleClaimType = ClaimTypes.Role
        };
        
        // Custom event handler ƒë·ªÉ extract roles t·ª´ realm_access claim
        options.Events = new JwtBearerEvents
        {
            OnTokenValidated = ctx =>
            {
                var realmAccess = ctx.Principal!.FindFirst("realm_access")?.Value;
                using var doc = JsonDocument.Parse(realmAccess);
                var roles = doc.RootElement.GetProperty("roles");
                
                foreach (var r in roles.EnumerateArray())
                {
                    var role = r.GetString();
                    ctx.Principal!.Identities.First()
                        .AddClaim(new Claim(ClaimTypes.Role, role));
                }
                return Task.CompletedTask;
            }
        };
    });
    
    services.AddAuthorization();
    return services;
}
```

#### **User Context Extension**

**File**: `src/Shared/BuildingBlocks/Authentication/Extensions/UserContextExtension.cs`

**Extract user information t·ª´ Claims**:
```csharp
public static class UserContextExtension
{
    public static UserContext GetCurrentUser(this IHttpContextAccessor context)
    {
        var identity = context.HttpContext?.User;
        
        return new UserContext()
        {
            Id = identity?.FindFirst(ClaimTypes.NameIdentifier)?.Value,
            Email = identity?.FindFirst(ClaimTypes.Email)?.Value,
            UserName = identity?.FindFirst("preferred_username")?.Value,
            FirstName = identity?.FindFirst(ClaimTypes.GivenName)?.Value,
            LastName = identity?.FindFirst(ClaimTypes.Surname)?.Value,
            Tenant = identity?.FindFirst("tenant")?.Value,
            Roles = identity?.FindAll(ClaimTypes.Role).Select(c => c.Value).ToList(),
            EmailVerified = bool.Parse(identity?.FindFirst("email_verified")?.Value)
        };
    }
}
```

#### **Custom Claim Types**

**File**: `src/Shared/Common/Constants/CustomClaimTypes.cs`

```csharp
public sealed class CustomClaimTypes
{
    public const string RealmAccess = "realm_access";
    public const string Roles = "roles";
    public const string UserName = "preferred_username";
    public const string EmailVerified = "email_verified";
    public const string Tenant = "tenant";
}
```

#### **Protected API Endpoints**

**V√≠ d·ª•**: Order Service - Create Order

**File**: `src/Services/Order/Api/Order.Api/Endpoints/CreateOrder.cs`

```csharp
public sealed class CreateOrder : ICarterModule
{
    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Order.Create, HandleCreateOrderAsync)
            .RequireAuthorization(); // ‚úÖ Requires authentication
            // .RequireAuthorization("AdminPolicy"); // ‚úÖ Requires specific role
    }
    
    private async Task<ApiCreatedResponse<Guid>> HandleCreateOrderAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromBody] CreateOrUpdateOrderDto dto)
    {
        // ‚úÖ Get current user from JWT claims
        var currentUser = httpContext.GetCurrentUser();
        var command = new CreateOrderCommand(
            dto, 
            Actor.User(currentUser.Email));
        
        return await sender.Send(command);
    }
}
```

---

### 4. **Service-to-Service Authentication** 

#### **Client Credentials Flow**

**File**: `src/Services/Inventory/Core/Inventory.Infrastructure/ApiClients/IKeycloakApi.cs`

```csharp
public interface IKeycloakApi
{
    [Post("/realms/{realm}/protocol/openid-connect/token")]
    [Headers("Content-Type: application/x-www-form-urlencoded")]
    Task<KeycloakAccessTokenResponse> GetAccessTokenAsync(
        [AliasAs("realm")] string realm,
        [Body(BodySerializationMethod.UrlEncoded)] 
        Dictionary<string, string> form);
}
```

**File**: `src/Services/Inventory/Core/Inventory.Infrastructure/Services/CatalogApiService.cs`

```csharp
public sealed class CatalogApiService
{
    private async Task<KeycloakAccessTokenResponse> GetAccessTokenAsync()
    {
        var form = new Dictionary<string, string>
        {
            { "client_id", _clientId },           // prog-coder-service-account
            { "client_secret", _clientSecret },
            { "grant_type", "client_credentials" },
            { "scope", "openid" }
        };
        
        return await _keycloakApi.GetAccessTokenAsync(_realm, form);
    }
    
    public async Task<ApiGetResponse<GetProductByIdReponse>?> GetProductByIdAsync(
        string productId)
    {
        var tokenResponse = await GetAccessTokenAsync();
        var response = await _catalogApi.GetProductByIdAsync(
            productId, 
            $"Bearer {tokenResponse.AccessToken}");
        return response;
    }
}
```

---

### 5. **Swagger UI OAuth2 Integration**

**File**: `src/Shared/BuildingBlocks/Swagger/Extensions/SwaggerGenExtension.cs`

```csharp
services.AddSwaggerGen(opts =>
{
    // OAuth2 security definition
    opts.AddSecurityDefinition("oauth2", new OpenApiSecurityScheme
    {
        Type = SecuritySchemeType.OAuth2,
        Flows = new OpenApiOAuthFlows
        {
            AuthorizationCode = new OpenApiOAuthFlow
            {
                AuthorizationUrl = new Uri($"{authority}/protocol/openid-connect/auth"),
                TokenUrl = new Uri($"{authority}/protocol/openid-connect/token"),
                Scopes = oauthScopes
            }
        }
    });
    
    // Auto-add security requirements to [Authorize] endpoints
    opts.OperationFilter<AuthorizeCheckOperationFilter>();
});

// Swagger UI with OAuth2
app.UseSwaggerUI(c =>
{
    c.SwaggerEndpoint("/swagger/v1/swagger.json", "v1");
    c.OAuthClientId(clientId);
    c.OAuthClientSecret(clientSecret);
    c.OAuthScopes(scopes);
    c.OAuth2RedirectUrl(oAuth2RedirectUrl);
});
```

**File**: `src/Shared/BuildingBlocks/Swagger/AuthorizeCheckOperationFilter.cs`

```csharp
public sealed class AuthorizeCheckOperationFilter : IOperationFilter
{
    public void Apply(OpenApiOperation operation, OperationFilterContext context)
    {
        var hasAuthorize = context.ApiDescription
            .ActionDescriptor
            .EndpointMetadata
            .OfType<IAuthorizeData>()
            .Any();
        
        if (!hasAuthorize) return;
        
        operation.Responses.TryAdd("401", new OpenApiResponse { Description = "Unauthorized" });
        operation.Responses.TryAdd("403", new OpenApiResponse { Description = "Forbidden" });
        
        operation.Security = new List<OpenApiSecurityRequirement>
        {
            new OpenApiSecurityRequirement
            {
                [new OpenApiSecurityScheme {
                    Reference = new OpenApiReference {
                        Type = ReferenceType.SecurityScheme,
                        Id = "oauth2"
                    }
                }] = new[] { "openid" }
            }
        };
    }
}
```

---

## üîÑ Quy tr√¨nh Authentication Flow

### **User Login Flow**

```
1. User truy c·∫≠p trang protected (v√≠ d·ª•: /checkout)
   ‚Üì
2. ProtectedRoute component ki·ªÉm tra authenticated = false
   ‚Üì
3. Redirect user v·ªÅ Keycloak: 
   http://localhost:8080/realms/prog-coder-realm/protocol/openid-connect/auth?
     client_id=prog-coder-client-id&
     redirect_uri=http://localhost:3002/&
     response_type=code&
     scope=openid&
     code_challenge=xxx (PKCE)
   ‚Üì
4. User nh·∫≠p username/password tr√™n Keycloak login page
   ‚Üì
5. Keycloak redirect v·ªÅ frontend v·ªõi: ?code=xxx&session_state=xxx
   ‚Üì
6. Keycloak-js t·ª± ƒë·ªông exchange code ‚Üí access_token + refresh_token
   ‚Üì
7. Access token ƒë∆∞·ª£c l∆∞u v√†o cookie: access_token=xxx
   ‚Üì
8. KeycloakContext set authenticated = true
   ‚Üì
9. User ƒë∆∞·ª£c redirect v·ªÅ trang y√™u c·∫ßu
```

### **API Request Flow**

```
1. Frontend g·ªçi API (v√≠ d·ª•: POST /basket/checkout)
   ‚Üì
2. Axios interceptor t·ª± ƒë·ªông g√°n header:
   Authorization: Bearer <access_token>
   ‚Üì
3. API Gateway forwards request ‚Üí Basket Service
   ‚Üì
4. JwtBearerMiddleware validates token:
   - Ki·ªÉm tra signature v·ªõi Keycloak public key
   - Validate issuer, audience, expiration
   - Extract claims ‚Üí HttpContext.User
   ‚Üì
5. N·∫øu valid ‚Üí ti·∫øp t·ª•c x·ª≠ l√Ω
   N·∫øu invalid ‚Üí return 401 Unauthorized
```

---

## üîê Security Features

| Feature | Implementation |
|---------|----------------|
| **Token Validation** | JWT signature validation v·ªõi Keycloak public key |
| **Token Refresh** | Auto-refresh tr∆∞·ªõc khi expired (30s buffer) |
| **PKCE** | Proof Key for Code Exchange ƒë·ªÉ prevent auth code interception |
| **HTTPS Required** | `RequireHttpsMetadata = false` (dev), `true` (prod) |
| **Cookie Security** | `SameSite=Lax`, `Secure` flag trong HTTPS |
| **Token Storage** | Cookie (kh√¥ng localStorage ƒë·ªÉ tr√°nh XSS) |
| **Authorization** | Role-based v·ªõi `[RequireAuthorization("RoleName")]` |
| **Token Expiration Handling** | Auto logout khi refresh token th·∫•t b·∫°i |
| **Idempotency** | Check duplicate token processing v·ªõi Inbox Pattern |
| **Service-to-Service** | Client Credentials flow v·ªõi separate client ID |

---

## üìä JWT Token Structure

**Example Access Token (decoded)**:
```json
{
  "sub": "550e8400-e29b-41d4-a716-446655440000",
  "preferred_username": "user@example.com",
  "email": "user@example.com",
  "given_name": "John",
  "family_name": "Doe",
  "email_verified": true,
  "realm_access": {
    "roles": ["user", "customer"]
  },
  "tenant": "tenant-1",
  "iss": "http://localhost:8080/realms/prog-coder-realm",
  "aud": "account",
  "exp": 1704067200,
  "iat": 1704063600
}
```

**Claims Mapping**:
- `sub` ‚Üí `ClaimTypes.NameIdentifier` (User ID)
- `preferred_username` ‚Üí CustomClaimTypes.UserName
- `given_name` ‚Üí `ClaimTypes.GivenName`
- `family_name` ‚Üí `ClaimTypes.Surname`
- `email` ‚Üí `ClaimTypes.Email`
- `realm_access.roles` ‚Üí `ClaimTypes.Role[]`

---

## üéØ Best Practices ƒê∆∞·ª£c √Åp D·ª•ng

1. ‚úÖ **PKCE** - Prevent authorization code interception
2. ‚úÖ **Short-lived Access Tokens** - Gi·∫£m thi·ªÉu impact n·∫øu token b·ªã leak
3. ‚úÖ **Refresh Token Rotation** - Enhance security
4. ‚úÖ **Cookie over localStorage** - Avoid XSS attacks
5. ‚úÖ **Automatic Token Refresh** - Seamless user experience
6. ‚úÖ **Centralized Token Validation** - JwtBearerMiddleware
7. ‚úÖ **Role-based Authorization** - `[RequireAuthorization]`
8. ‚úÖ **Swagger OAuth2 Integration** - Easy API testing
9. ‚úÖ **Service-to-Service Auth** - Client Credentials flow
10. ‚úÖ **Tenant Support** - Multi-tenant architecture

---

## üöÄ C·∫•u h√¨nh trong Production

**C√°c tham s·ªë c·∫ßn thay ƒë·ªïi**:

```json
// appsettings.json
{
  "Authentication": {
    "Authority": "https://auth.yourdomain.com/realms/prog-coder-realm",
    "RequireHttpsMetadata": true,  // ‚úÖ B·∫Øt bu·ªôc trong production
    "ClientId": "prod-client-id",
    "ClientSecret": "strong-secret-key"
  }
}

// .env
VITE_KEYCLOAK_URL=https://auth.yourdomain.com
VITE_KEYCLOAK_REDIRECT_URI=https://store.yourdomain.com/
```

---

## üìù K·∫øt lu·∫≠n

Authentication system trong d·ª± √°n n√†y l√† m·ªôt gi·∫£i ph√°p **production-ready** v·ªõi:

- **Keycloak** l√†m Identity Provider (enterprise-grade)
- **OIDC + JWT** v·ªõi PKCE cho frontend authentication
- **Role-based authorization** v·ªõi multi-tenant support
- **Automatic token refresh** v·ªõi seamless user experience
- **Service-to-service authentication** v·ªõi Client Credentials flow
- **Swagger UI OAuth2** cho d·ªÖ d√†ng testing
- **Security best practices** ƒë∆∞·ª£c √°p d·ª•ng ƒë·∫ßy ƒë·ªß

ƒê√¢y l√† m·ªôt ki·∫øn tr√∫c authentication **m·∫°nh m·∫Ω, scalable v√† secure** ph√π h·ª£p cho microservices architecture.
