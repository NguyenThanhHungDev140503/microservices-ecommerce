This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.cs, **/*.proto, **/*.csproj, **/*.props
- Files matching these patterns are excluded: Apps/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
ApiGateway/
  YarpApiGateway/
    Program.cs
    YarpApiGateway.csproj
JobOrchestrator/
  App.Job/
    ApiClients/
      IKeycloakApi.cs
    Attributes/
      JobAttribute.cs
    Enums/
      DashboardTotalTitle.cs
    GrpcClients/
      Interceptors/
        GrpcApiKeyInterceptor.cs
    Jobs/
      Inventory/
        ExpireInventoryReservationsJob.cs
      Report/
        SyncDashboardReportJob.cs
    Models/
      Keycloaks/
        KeycloakAccessToken.cs
        KeycloakUser.cs
      Orders/
        OrderItemModel.cs
        OrderModel.cs
    Quartz/
      JobRegistrationExtensions.cs
      QuartzHostedService.cs
      QuartzJobFactory.cs
    App.Job.csproj
    DependencyInjection.cs
    Program.cs
Services/
  Basket/
    Api/
      Basket.Api/
        Constants/
          ApiRoutes.cs
        Endpoints/
          BasketCheckout.cs
          DeleteBasket.cs
          GetBasket.cs
          StoreBasket.cs
        Basket.Api.csproj
        DependencyInjection.cs
        GlobalUsing.cs
        Program.cs
    Core/
      Basket.Application/
        Dtos/
          Abstractions/
            AuditableDto.cs
            DtoId.cs
            EntityDto.cs
            ICreationAuditDto.cs
            IModificationAuditDto.cs
          Baskets/
            BasketCheckoutAddressDto.cs
            BasketCheckoutCustomerDto.cs
            BasketCheckoutDto.cs
            BasketCheckoutItemDto.cs
            ShoppingCartDto.cs
            ShoppingCartItemDto.cs
            StoreShoppingCartDto.cs
            StoreShoppingCartItemDto.cs
        Exceptions/
          ApplicationException.cs
        Features/
          Basket/
            Commands/
              BasketCheckoutCommand.cs
              DeleteBasketCommand.cs
              StoreBasketCommand.cs
            EventHandlers/
              Domain/
                BasketCheckoutDomainEventHandler.cs
            Queries/
              GetBasketQuery.cs
        Mappings/
          BasketMappingProfile.cs
        Models/
          Filters/
            GetAllCategoriesFilter.cs
            GetAllProductsFilter.cs
            GetProductsFilter.cs
            GetPublishProductsFilter.cs
          Responses/
            Externals/
              EvaluateCouponResponse.cs
              GetAllProductsResponse.cs
              ProductReponse.cs
          Results/
            GetBasketResult.cs
        Repositories/
          IBasketRepository.cs
          IOutboxRepository.cs
        Services/
          ICatalogGrpcService.cs
          IDiscountGrpcService.cs
        ApplicationMarker.cs
        Basket.Application.csproj
        DependencyInjection.cs
        GlobalUsing.cs
      Basket.Domain/
        Abstractions/
          Aggregate.cs
          Entity.cs
          EntityId.cs
          IAggregate.cs
          IAuditable.cs
          ICreationAuditable.cs
          IDomainEvent.cs
          IEntityId.cs
          IModificationAuditable.cs
        Attributes/
          BsonCollectionAttribute.cs
        Entities/
          OutboxMessageEntity.cs
          ShoppingCartEntity.cs
          ShoppingCartItemEntity.cs
        Enums/
          ProductStatus.cs
        Events/
          BasketCheckoutDomainEvent.cs
        Exceptions/
          DomainException.cs
        ValueObjects/
          Money.cs
        Basket.Domain.csproj
        GlobalUsing.cs
      Basket.Infrastructure/
        Constants/
          MongoCollection.cs
        Data/
          Extensions/
            DatabaseExtentions.cs
        Exceptions/
          InfrastructureException.cs
        GrpcClients/
          Extensions/
            GrpcClientExtension.cs
          Interceptors/
            GrpcApiKeyInterceptor.cs
        Repositories/
          BaseRepository.cs
          BasketRepository.cs
          CachedBasketRepository.cs
          OutboxRepository.cs
        Services/
          CatalogGrpcService.cs
          DiscountGrpcService.cs
        Basket.Infrastructure.csproj
        DependencyInjection.cs
        GlobalUsing.cs
        InfrastructureMarker.cs
    Worker/
      Basket.Worker.Outbox/
        BackgroundServices/
          OutboxBackgroundService.cs
        Processors/
          OutboxProcessor.cs
        Structs/
          OutboxUpdate.cs
        Basket.Worker.Outbox.csproj
        DependencyInjection.cs
        Program.cs
  Catalog/
    Api/
      Catalog.Api/
        Constants/
          ApiRoutes.cs
        Endpoints/
          CreateBrand.cs
          CreateCategory.cs
          CreateProduct.cs
          DeleteBrand.cs
          DeleteCategory.cs
          DeleteProduct.cs
          GetAllBrands.cs
          GetAllCategories.cs
          GetAllProducts.cs
          GetProductById.cs
          GetProducts.cs
          GetPublishProductById.cs
          GetPublishProducts.cs
          GetTreeCategories.cs
          InitializeData.cs
          PublishProduct.cs
          UnpublishProduct.cs
          UpdateBrand.cs
          UpdateCategory.cs
          UpdateProduct.cs
        Mappings/
          CatalogApiMappingProfile.cs
        Models/
          CreateProductRequest.cs
          UpdateProductRequest.cs
        Catalog.Api.csproj
        DependencyInjection.cs
        GlobalUsing.cs
        Program.cs
      Catalog.Grpc/
        Interceptors/
          ApiKeyValidationInterceptor.cs
        Services/
          CatalogGrpcService.cs
        Catalog.Grpc.csproj
        DependencyInjection.cs
        Program.cs
    Core/
      Catalog.Application/
        Dtos/
          Abstractions/
            AuditableDto.cs
            DtoId.cs
            EntityDto.cs
            ICreationAuditDto.cs
            IModificationAuditDto.cs
          Brands/
            BrandDto.cs
            CreateBrandDto.cs
            UpdateBrandDto.cs
          Categories/
            CategoryDto.cs
            CategoryTreeItemDto.cs
            CreateCategoryDto.cs
            UpdateCategoryDto.cs
          Products/
            CreateProductDto.cs
            ProductDto.cs
            ProductImageDto.cs
            ProductInfoDto.cs
            PublishProductDto.cs
            UpdateProductDto.cs
        Exceptions/
          ApplicationException.cs
        Features/
          Brand/
            Commands/
              CreateBrandCommand.cs
              DeleteBrandCommand.cs
              UpdateBrandCommand.cs
            Queries/
              GetAllBrandsQuery.cs
          Category/
            Commands/
              CreateCategoryCommand.cs
              DeleteCategoryCommand.cs
              UpdateCategoryCommand.cs
            Queries/
              GetAllCategoriesQuery.cs
              GetTreeCategoriesQuery.cs
          Product/
            Commands/
              ChangeProductStatusCommand.cs
              CreateProductCommand.cs
              DeleteProductCommand.cs
              PublishProductCommand.cs
              UnpublishProductCommand.cs
              UpdateProductCommand.cs
            EventHandlers/
              Domain/
                DeletedUnPublishedProductDomainEventHandler.cs
                UpsertedProductDomainEventHandler.cs
            Queries/
              GetAllAvailableProductsQuery.cs
              GetAllProductsQuery.cs
              GetCountProductsQuery.cs
              GetProductByIdQuery.cs
              GetProductsQuery.cs
              GetPublishProductByIdQuery.cs
              GetPublishProductsQuery.cs
          System/
            InitialDataCommand.cs
        Mappings/
          CatalogMappingProfile.cs
        Models/
          Filters/
            GetAllCategoriesFilter.cs
            GetAllProductsFilter.cs
            GetProductsFilter.cs
            GetPublishProductsFilter.cs
          Results/
            GetAllAvailableProductsResult.cs
            GetAllBrandsResult.cs
            GetAllCategoriesResult.cs
            GetAllProductsResult.cs
            GetCountProductsResult.cs
            GetProductByIdResult.cs
            GetProductsResult.cs
            GetPublishProductByIdResult.cs
            GetPublishProductsResult.cs
            GetTreeCategoriesResult.cs
        Repositories/
          IOutboxRepository.cs
        Services/
          IMinIOCloudService.cs
          ISeedDataService.cs
        ApplicationMarker.cs
        Catalog.Application.csproj
        DependencyInjection.cs
        GlobalUsing.cs
      Catalog.Domain/
        Abstractions/
          Aggregate.cs
          Entity.cs
          EntityId.cs
          IAggregate.cs
          IAuditable.cs
          ICreationAuditable.cs
          IDomainEvent.cs
          IEntityId.cs
          IModificationAuditable.cs
        Entities/
          BrandEntity.cs
          CategoryEntity.cs
          OutboxMessageEntity.cs
          ProductEntity.cs
          ProductImageEntity.cs
        Enums/
          ProductStatus.cs
        Events/
          DeletedUnPublishedProductDomainEvent.cs
          UpsertedProductDomainEvent.cs
        Exceptions/
          DomainException.cs
        ValueObjects/
          Money.cs
        Catalog.Domain.csproj
        GlobalUsing.cs
      Catalog.Infrastructure/
        Data/
          BrandSeedData.cs
          CategorySeedData.cs
          InitialData.cs
          ProductSeedData.cs
        Exceptions/
          InfrastructureException.cs
        Repositories/
          OutboxRepository.cs
        Services/
          MinIOCloudService.cs
          SeedDataService.cs
        Catalog.Infrastructure.csproj
        DependencyInjection.cs
        GlobalUsing.cs
        InfrastructureMarker.cs
    Worker/
      Catalog.Woker.Outbox/
        BackgroundServices/
          OutboxBackgroundService.cs
        Processors/
          OutboxProcessor.cs
        Structs/
          OutboxUpdate.cs
        Catalog.Worker.Outbox.csproj
        DependencyInjection.cs
        Program.cs
      Catalog.Worker.Consumer/
        BackgroundServices/
          CatalogBackgroudService.cs
        EventHandlers/
          Integrations/
            StockChangedEventHandler.cs
        Catalog.Worker.Consumer.csproj
        DependencyInjection.cs
        Program.cs
  Communication/
    Api/
      Communication.Api/
        Constants/
          ApiRoutes.cs
        EventHandlers/
          Integrations/
            OrderCreatedIntegrationEventHandler.cs
        Hubs/
          NotificationHub.cs
        Models/
          NotificationDto.cs
          NotificationType.cs
        Services/
          INotificationHubService.cs
          NotificationHubService.cs
        Communication.Api.csproj
        DependencyInjection.cs
        GlobalUsing.cs
        Program.cs
  Discount/
    Api/
      Discount.Api/
        Constants/
          ApiRoutes.cs
        Endpoints/
          ApproveCoupon.cs
          CreateCoupon.cs
          DeleteCoupon.cs
          EvaluateCoupon.cs
          GetAllCoupons.cs
          GetCoupon.cs
          GetCouponByCode.cs
          GetCoupons.cs
          GetCouponsApproved.cs
          RejectCoupon.cs
          UpdateCoupon.cs
          UpdateValidityPeriod.cs
        DependencyInjection.cs
        Discount.Api.csproj
        GlobalUsing.cs
        Program.cs
      Discount.Grpc/
        Interceptors/
          ApiKeyValidationInterceptor.cs
        Services/
          DiscountGrpcService.cs
        DependencyInjection.cs
        Discount.Grpc.csproj
        Program.cs
    Core/
      Discount.Application/
        Dtos/
          Abstractions/
            AuditableDto.cs
            DtoId.cs
            EntityDto.cs
            ICreationAuditDto.cs
            IModificationAuditDto.cs
          Coupons/
            ApplyCouponDto.cs
            CouponDto.cs
            CreateCouponDto.cs
            EvaluateCouponDto.cs
            UpdateCouponDto.cs
            UpdateValidityPeriodDto.cs
        Exceptions/
          ApplicationException.cs
        Features/
          Coupon/
            Commands/
              ApplyCouponCommand.cs
              ApproveCouponCommand.cs
              CreateCouponCommand.cs
              DeleteCouponCommand.cs
              EvaluateCouponCommand.cs
              RejectCouponCommand.cs
              UpdateCouponCommand.cs
              UpdateValidityPeriodCommand.cs
            Queries/
              GetAllCouponsQuery.cs
              GetCouponByCodeQuery.cs
              GetCouponByIdQuery.cs
              GetCouponsApprovedQuery.cs
              GetCouponsQuery.cs
        Mappings/
          DiscountMappingProfile.cs
        Models/
          Results/
            ApplyCouponResult.cs
            EvaluateCouponResult.cs
            GetCouponByIdResult.cs
            GetCouponsResult.cs
        Repositories/
          ICouponRepository.cs
          IUnitOfWork.cs
          UnitOfWorkUsageExample.cs
        ApplicationMarker.cs
        DependencyInjection.cs
        Discount.Application.csproj
        GlobalUsing.cs
      Discount.Domain/
        Abstractions/
          Aggregate.cs
          Entity.cs
          EntityId.cs
          IAggregate.cs
          IAuditable.cs
          ICreationAuditable.cs
          IDomainEvent.cs
          IEntityId.cs
          IModificationAuditable.cs
        Entities/
          CouponEntity.cs
        Enums/
          CouponStatus.cs
          CouponType.cs
        Exceptions/
          DomainException.cs
        ValueObjects/
          CouponCode.cs
        Discount.Domain.csproj
        GlobalUsing.cs
      Discount.Infrastructure/
        Constants/
          MongoCollection.cs
        Data/
          Extensions/
            DatabaseExtentions.cs
        Exceptions/
          InfrastructureException.cs
        Repositories/
          CouponRepository.cs
          IMongoSessionProvider.cs
          UnitOfWork.cs
        DependencyInjection.cs
        Discount.Infrastructure.csproj
        GlobalUsing.cs
        InfrastructureMarker.cs
  Inventory/
    Api/
      Inventory.Api/
        Constants/
          ApiRoutes.cs
        Endpoints/
          CreateInventoryItem.cs
          CreateLocation.cs
          DecreaseStock.cs
          DeleteInventoryItem.cs
          DeleteLocation.cs
          GetAllHistories.cs
          GetAllInventoryItems.cs
          GetAllLocations.cs
          GetAllReservations.cs
          GetInventoryItems.cs
          GetLocationById.cs
          IncreaseStock.cs
          UpdateInventoryItem.cs
          UpdateLocation.cs
        DependencyInjection.cs
        GlobalUsing.cs
        Inventory.Api.csproj
        Program.cs
      Inventory.Grpc/
        Interceptors/
          ApiKeyValidationInterceptor.cs
        Services/
          InventoryGrpcService.cs
        DependencyInjection.cs
        Inventory.Grpc.csproj
        Program.cs
    Core/
      Inventory.Application/
        Constants/
          KeycloakUserAttributes.cs
          KeycloakUserEvent.cs
        Dtos/
          Abstractions/
            AuditableDto.cs
            DtoId.cs
            EntityDto.cs
            ICreationAuditDto.cs
            IModificationAuditDto.cs
          InventoryItems/
            CreateInventoryItemDto.cs
            InventoryHistoryDto.cs
            InventoryItemDto.cs
            LocationDto.cs
            ProductDto.cs
            UpdateInventoryItemDto.cs
            UpdateStockDto.cs
          InventoryReservations/
            CreateReservationDto.cs
            ReservationDto.cs
          Locations/
            CreateLocationDto.cs
            UpdateLocationDto.cs
        Exceptions/
          ApplicationException.cs
        Features/
          InventoryItem/
            Commands/
              CreateInventoryItemCommand.cs
              DeleteInventoryItemCommand.cs
              UpdateInventoryItemCommand.cs
              UpdateStockCommand.cs
            EventHandlers/
              Domain/
                InventoryItemDeletedDomainEventHandler.cs
                LocationChangedDomainEventHandler.cs
                StockChangedDomainEventHandler.cs
            Queries/
              GetAllInventoryItemQuery.cs
              GetInventoryItemsQuery.cs
          InventoryItemHistory/
            Queries/
              GetAllHistoriesQuery.cs
          InventoryReservation/
            Commands/
              CommitReservationCommand.cs
              ExpireReservationCommand.cs
              ReleaseReservationCommand.cs
              ReserveInventoryCommand.cs
            EventHandlers/
              Domain/
                ReservationCommittedDomainEventHandler.cs
                ReservationCreatedDomainEventHandler.cs
                ReservationExpiredDomainEventHandler.cs
                ReservationReleasedDomainEventHandler.cs
            Queries/
              GetAllInventoryReservationQuery.cs
          Location/
            Commands/
              CreateLocationCommand.cs
              DeleteLocationCommand.cs
              UpdateLocationCommand.cs
            Queries/
              GetAllLocationsQuery.cs
              GetLocationByIdQuery.cs
        Mappings/
          InventoryMappingProfile.cs
        Models/
          Filters/
            GetInventoryItemsFilter.cs
          Responses/
            Externals/
              GetProductByIdReponse.cs
              KeycloakAccessTokenResponse.cs
              ProductReponse.cs
            Internals/
              GetAllProductsResponse.cs
          Results/
            GetAllHistoriesResult.cs
            GetAllInventoryItemResult.cs
            GetAllInventoryReservationResult.cs
            GetAllLocationsResult.cs
            GetInventoryItemsResult.cs
            GetLocationByIdResult.cs
            GetReservationsByReferenceResult.cs
        Services/
          ICatalogApiService.cs
          ICatalogGrpcService.cs
        ApplicationMarker.cs
        DependencyInjection.cs
        GlobalUsing.cs
        Inventory.Application.csproj
      Inventory.Domain/
        Abstractions/
          Aggregate.cs
          Entity.cs
          EntityId.cs
          IAggregate.cs
          IAuditable.cs
          ICreationAuditable.cs
          IDbTransaction.cs
          IDomainEvent.cs
          IEntityId.cs
          IModificationAuditable.cs
          IUnitOfWork.cs
        Entities/
          InboxMessageEntity.cs
          InventoryHistoryEntity.cs
          InventoryItemEntity.cs
          InventoryReservationEntity.cs
          LocationEntity.cs
          OutboxMessageEntity.cs
        Enums/
          InventoryChangeType.cs
          InventorySource.cs
          ReservationStatus.cs
        Events/
          InventoryItemDeletedDomainEvent.cs
          LocationChangedDomainEvent.cs
          ReservationCommittedDomainEvent.cs
          ReservationCreatedDomainEvent.cs
          ReservationExpiredDomainEvent.cs
          ReservationReleasedDomainEvent.cs
          StockChangedDomainEvent.cs
          TransferOutDomainEvent.cs
        Exceptions/
          DomainException.cs
        Repositories/
          IInboxMessageRepository.cs
          IInventoryHistoryRepository.cs
          IInventoryItemRepository.cs
          IInventoryReservationRepository.cs
          ILocationRepository.cs
          IOutboxMessageRepository.cs
          IRepository.cs
        ValueObjects/
          Product.cs
        GlobalUsing.cs
        Inventory.Domain.csproj
      Inventory.Infrastructure/
        ApiClients/
          Extensions/
            ApiClientExtension.cs
          ICatalogApi.cs
          IKeycloakApi.cs
        Data/
          Configurations/
            InboxMessageConfiguration.cs
            InventoryHistoryConfiguration.cs
            InventoryItemConfiguration.cs
            InventoryReservationConfiguration.cs
            LocationEntityConfiguration.cs
            OutboxMessageConfiguration.cs
          Extensions/
            AuditableEntityInterceptorExtensions.cs
            DatabaseExtentions.cs
          Interceptors/
            AuditableEntityInterceptor.cs
            DispatchDomainEventsInterceptor.cs
          Migrations/
            20251218115210_init_database.cs
            20251218115210_init_database.Designer.cs
            20251229085215_update_outbox_msg.cs
            20251229085215_update_outbox_msg.Designer.cs
            20260106132841_add_inbox.cs
            20260106132841_add_inbox.Designer.cs
            ApplicationDbContextModelSnapshot.cs
          ApplicationDbContext.cs
        Exceptions/
          InfrastructureException.cs
        GrpcClients/
          Extensions/
            GrpcClientExtension.cs
          Interceptors/
            GrpcApiKeyInterceptor.cs
        Repositories/
          InboxMessageRepository.cs
          InventoryHistoryRepository.cs
          InventoryItemRepository.cs
          InventoryReservationRepository.cs
          LocationRepository.cs
          OutboxMessageRepository.cs
          Repository.cs
        Services/
          CatalogApiService.cs
          CatalogGrpcService.cs
        UnitOfWork/
          DbTransactionAdapter.cs
          UnitOfWork.cs
        DependencyInjection.cs
        GlobalUsing.cs
        InfrastructureMarker.cs
        Inventory.Infrastructure.csproj
    Worker/
      Inventory.Worker.Consumer/
        BackgroundServices/
          InventoryBackgroudService.cs
        EventHandlers/
          Integrations/
            OrderCancelledIntegrationEventHandler.cs
            OrderCreatedIntegrationEventHandler.cs
            OrderDeliveredIntegrationEventHandler.cs
        DependencyInjection.cs
        Inventory.Worker.Consumer.csproj
        Program.cs
      Inventory.Worker.Outbox/
        Abstractions/
          IDatabaseProvider.cs
        BackgroundServices/
          OutboxBackgroundService.cs
        Factories/
          DatabaseProviderFactory.cs
        Models/
          OutboxMessage.cs
        Processors/
          OutboxProcessor.cs
        Providers/
          MySqlDatabaseProvider.cs
          PostgreSqlDatabaseProvider.cs
          SqlServerDatabaseProvider.cs
        Structs/
          OutboxUpdate.cs
        DependencyInjection.cs
        Inventory.Worker.Outbox.csproj
        Program.cs
  Notification/
    Api/
      Notification.Api/
        Constants/
          ApiRoutes.cs
        Endpoints/
          GetAllNotifications.cs
          GetCountNotificationUnread.cs
          GetNotifications.cs
          GetTop10NotificationsUnread.cs
          MarkAsRead.cs
        DependencyInjection.cs
        GlobalUsing.cs
        Notification.Api.csproj
        Program.cs
    Core/
      Notification.Application/
        Constants/
          TemplateKey.cs
          TemplateVariables.cs
        Data/
          Repositories/
            ICommandDeliveryRepository.cs
            ICommandNotificationRepository.cs
            IQueryDeliveryRepository.cs
            IQueryNotificationRepository.cs
            IQueryTemplateRepository.cs
        Dtos/
          Abstractions/
            AuditableDto.cs
            DtoId.cs
            EntityDto.cs
            ICreationAuditDto.cs
            IModificationAuditDto.cs
          Deliveries/
            CreateDeliveryDto.cs
          Keycloaks/
            KeycloakAccessTokenDto.cs
            KeycloakUserDto.cs
          Notifications/
            MarkAsReadNotificationDto.cs
            NotificationDto.cs
        Exceptions/
          ApplicationException.cs
        Features/
          Delivery/
            Commands/
              CreateDeliveryCommand.cs
              ProcessDeliveryCommand.cs
            Queries/
              GetDueDeliveriesQuery.cs
          Keycloak/
            Queries/
              GetKeycloakUsersByRoleQuery.cs
              GetKeycloakUsersQuery.cs
          Notification/
            Commands/
              MarkAsReadNotificationCommand.cs
            Queries/
              GetAllNotificationsQuery.cs
              GetCountNotificationUnreadQuery.cs
              GetNotificationsQuery.cs
              GetTop10NotificationsUnreadQuery.cs
        Mappings/
          NotificationMappingProfile.cs
        Models/
          Results/
            GetAllNotificationsResult.cs
            GetCountNotificationUnreadResult.cs
            GetNotificationsResult.cs
            GetTop10NotificationsUnreadResult.cs
          ChannelResult.cs
          NotificationContext.cs
        Providers/
          ITemplateProvider.cs
        Services/
          IKeycloakService.cs
        Strategy/
          INotificationSender.cs
          INotificationSenderResolver.cs
        ApplicationMarker.cs
        DependencyInjection.cs
        GlobalUsing.cs
        Notification.Application.csproj
      Notification.Domain/
        Abstractions/
          Aggregate.cs
          Entity.cs
          IAggregate.cs
          IAuditable.cs
          ICreationAuditable.cs
          IDomainEvent.cs
          IEntityId.cs
          IModificationAuditable.cs
        Entities/
          DeliveryEntity.cs
          MessagePayloadEntity.cs
          NotificationEntity.cs
          TemplateEntity.cs
        Enums/
          ChannelType.cs
          DeliveryPriority.cs
          DeliveryStatus.cs
          DiscordColor.cs
        Exceptions/
          DomainException.cs
        Models/
          Externals/
            Discord/
              DiscordWebhookPayload.cs
            Keycloaks/
              KeycloakAccessToken.cs
              KeycloakUser.cs
        GlobalUsing.cs
        Notification.Domain.csproj
      Notification.Infrastructure/
        ApiClients/
          IDiscordApi.cs
          IKeycloakApi.cs
        Constants/
          MongoCollection.cs
        Data/
          Extensions/
            DatabaseExtentions.cs
        Exceptions/
          InfrastructureException.cs
        Providers/
          TemplateProvider.cs
        Repositories/
          DeliveryRepository.cs
          NotificationRepository.cs
          TemplateRepository.cs
        Resolvers/
          NotificationChannelResolver.cs
        Senders/
          DiscordNotificationSender.cs
          EmailNotificationSender.cs
          InAppNotificationSender.cs
        Services/
          KeycloakService.cs
        DependencyInjection.cs
        GlobalUsing.cs
        InfrastructureMarker.cs
        Notification.Infrastructure.csproj
    Worker/
      Notification.Worker.Consumer/
        BackgroundServices/
          NotificationBackgroundService.cs
        EventHandlers/
          Integrations/
            UpsertedProductIntegrationEventHandler.cs
        DependencyInjection.cs
        Notification.Worker.Consumer.csproj
        Program.cs
      Notification.Worker.Processor/
        DependencyInjection.cs
        Notification.Worker.Processor.csproj
        Program.cs
        Worker.cs
  Order/
    Api/
      Order.Api/
        Constants/
          ApiRoutes.cs
        Endpoints/
          CreateOrder.cs
          GetAllMyOrders.cs
          GetAllOrders.cs
          GetMyOrderById.cs
          GetMyOrders.cs
          GetOrderById.cs
          GetOrderByOrderNo.cs
          GetOrders.cs
          UpdateOrder.cs
          UpdateOrderStatus.cs
        Models/
          UpdateOrderStatusRequest.cs
        DependencyInjection.cs
        GlobalUsing.cs
        Order.Api.csproj
        Program.cs
      Order.Grpc/
        Interceptors/
          ApiKeyValidationInterceptor.cs
        Services/
          OrderGrpcService.cs
        DependencyInjection.cs
        Order.Grpc.csproj
        Program.cs
    Core/
      Order.Application/
        Constants/
          KeycloakUserAttributes.cs
          KeycloakUserEvent.cs
        Dtos/
          Abstractions/
            AuditableDto.cs
            DtoId.cs
            EntityDto.cs
            ICreationAuditDto.cs
            IModificationAuditDto.cs
          Orders/
            CreateOrderItemDto.cs
            CreateOrUpdateOrderDto.cs
            OrderDto.cs
            OrderItemDto.cs
          ValueObjects/
            AddressDto.cs
            CustomerDto.cs
            DiscountDto.cs
            ProductDto.cs
        Exceptions/
          ApplicationException.cs
        Features/
          Order/
            Commands/
              CreateOrderCommand.cs
              UpdateOrderCommand.cs
              UpdateOrderStatusCommand.cs
            EventHandlers/
              Domain/
                OrderCancelledDomainEventHandler.cs
                OrderCreatedDomainEventHandler.cs
                OrderDeliveredDomainEventHandler.cs
            Queries/
              GetAllMyOrdersQuery.cs
              GetAllOrdersQuery.cs
              GetMyOrderByIdQuery.cs
              GetMyOrdersQuery.cs
              GetOrderByIdQuery.cs
              GetOrderByMonthQuery.cs
              GetOrderByOrderNoQuery.cs
              GetOrdersQuery.cs
        Mappings/
          OrderMappingProfile.cs
        Models/
          Filters/
            GetAllOrdersFilter.cs
            GetInventoryItemsFilter.cs
            GetMyOrdersFilter.cs
            GetOrdersFilter.cs
          Responses/
            Externals/
              GetAllProductsResponse.cs
              ProductReponse.cs
            Internals/
              ApplyCouponResponse.cs
              EvaluateCouponResponse.cs
            KeycloakAccessTokenResponse.cs
          Results/
            GetAllMyOrdersResult.cs
            GetAllOrdersResult.cs
            GetMyOrderByIdResult.cs
            GetMyOrdersResult.cs
            GetOrderByIdResult.cs
            GetOrderByMonthResult.cs
            GetOrderByOrderNoResult.cs
            GetOrdersResult.cs
        Services/
          ICatalogGrpcService.cs
          IDiscountGrpcService.cs
        ApplicationMarker.cs
        DependencyInjection.cs
        GlobalUsing.cs
        Order.Application.csproj
      Order.Domain/
        Abstractions/
          Aggregate.cs
          Entity.cs
          EntityId.cs
          IAggregate.cs
          IAuditable.cs
          ICreationAuditable.cs
          IDbTransaction.cs
          IDomainEvent.cs
          IEntityId.cs
          IModificationAuditable.cs
          IUnitOfWork.cs
        Entities/
          InboxMessageEntity.cs
          OrderEntity.cs
          OrderItemEntity.cs
          OutboxMessageEntity.cs
        Enums/
          OrderStatus.cs
        Events/
          OrderCancelledDomainEvent.cs
          OrderCreatedDomainEvent.cs
          OrderDeliveredDomainEvent.cs
        Exceptions/
          DomainException.cs
        Repositories/
          IInboxMessageRepository.cs
          IOrderItemRepository.cs
          IOrderRepository.cs
          IOutboxMessageRepository.cs
          IRepository.cs
        ValueObjects/
          Address.cs
          Customer.cs
          Discount.cs
          OrderNo.cs
          Product.cs
        GlobalUsing.cs
        Order.Domain.csproj
      Order.Infrastructure/
        Data/
          Configurations/
            InboxMessageConfiguration.cs
            OrderEntityConfiguration.cs
            OrderItemEntityConfiguration.cs
            OutboxMessageConfiguration.cs
          Extensions/
            AuditableEntityInterceptorExtensions.cs
            DatabaseExtentions.cs
          Interceptors/
            AuditableEntityInterceptor.cs
            DispatchDomainEventsInterceptor.cs
          Migrations/
            20251119100113_init_database.cs
            20251119100113_init_database.Designer.cs
            20251211081244_add_reason_fields.cs
            20251211081244_add_reason_fields.Designer.cs
            20251227060709_update_address.cs
            20251227060709_update_address.Designer.cs
            20251227065035_update_order_address.cs
            20251227065035_update_order_address.Designer.cs
            20251229085353_update_outbox_msg.cs
            20251229085353_update_outbox_msg.Designer.cs
            20260106125029_add_inbox.cs
            20260106125029_add_inbox.Designer.cs
            ApplicationDbContextModelSnapshot.cs
          ApplicationDbContext.cs
        Exceptions/
          InfrastructureException.cs
        GrpcClients/
          Extensions/
            GrpcClientExtension.cs
          Interceptors/
            GrpcApiKeyInterceptor.cs
        Repositories/
          InboxMessageRepository.cs
          OrderItemRepository.cs
          OrderRepository.cs
          OutboxMessageRepository.cs
          Repository.cs
        Services/
          CatalogGrpcService.cs
          DiscountGrpcService.cs
        UnitOfWork/
          DbTransactionAdapter.cs
          UnitOfWork.cs
        DependencyInjection.cs
        GlobalUsing.cs
        InfrastructureMarker.cs
        Order.Infrastructure.csproj
    Worker/
      Order.Woker.Outbox/
        Abstractions/
          IDatabaseProvider.cs
        BackgroundServices/
          OutboxBackgroundService.cs
        Factories/
          DatabaseProviderFactory.cs
        Models/
          OutboxMessage.cs
        Processors/
          OutboxProcessor.cs
        Providers/
          MySqlDatabaseProvider.cs
          PostgreSqlDatabaseProvider.cs
          SqlServerDatabaseProvider.cs
        Structs/
          OutboxUpdate.cs
        DependencyInjection.cs
        Order.Worker.Outbox.csproj
        Program.cs
      Order.Worker.Consumer/
        BackgroundServices/
          OrderBackgroudService.cs
        EventHandlers/
          Integrations/
            BasketCheckoutIntegrationEventHandler.cs
            ReservationExpiredIntegrationEventHandler.cs
        DependencyInjection.cs
        Order.Worker.Consumer.csproj
        Program.cs
  Report/
    Api/
      Report.Api/
        Constants/
          ApiRoutes.cs
        Endpoints/
          GetDashboardTotals.cs
          GetOrderGrowthLineChart.cs
          GetTopProductPieChart.cs
        DependencyInjection.cs
        GlobalUsing.cs
        Program.cs
        Report.Api.csproj
      Report.Grpc/
        Interceptors/
          ApiKeyValidationInterceptor.cs
        Services/
          ReportGrpcService.cs
        DependencyInjection.cs
        Program.cs
        Report.Grpc.csproj
    Core/
      Report.Application/
        Data/
          Repositories/
            IDashboardTotalRepository.cs
            IOrderGrowthLineChartRepository.cs
            ITopProductPieChartRepository.cs
        Dtos/
          Abstractions/
            AuditableDto.cs
            DtoId.cs
            EntityDto.cs
            ICreationAuditDto.cs
            IModificationAuditDto.cs
          DashboardTotals/
            DashboardTotalDto.cs
            UpdateDashboardTotalDto.cs
          OrderGrowthLineCharts/
            OrderGrowthLineChartDto.cs
            UpdateOrderGrowthLineChartDto.cs
          TopProductPieCharts/
            TopProductPieChartDto.cs
            UpdateTopProductPieChartDto.cs
        Exceptions/
          ApplicationException.cs
        Features/
          DashboardTotal/
            Commands/
              UpdateDashboardTotalCommand.cs
            Queries/
              GetDashboardTotalsQuery.cs
          OrderGrowthLineChart/
            Commands/
              UpdateOrderGrowthLineChartCommand.cs
            Queries/
              GetOrderGrowthLineChartQuery.cs
          TopProductPieChart/
            Commands/
              UpdateTopProductPieChartCommand.cs
            Queries/
              GetTopProductPieChartQuery.cs
        Mappings/
          ReportMappingProfile.cs
        Models/
          Results/
            DashboardTotalsResult.cs
            OrderGrowthLineChartResult.cs
            TopProductPieChartResult.cs
        ApplicationMarker.cs
        DependencyInjection.cs
        GlobalUsing.cs
        Report.Application.csproj
      Report.Domain/
        Abstractions/
          Aggregate.cs
          Entity.cs
          IAggregate.cs
          IAuditable.cs
          ICreationAuditable.cs
          IDomainEvent.cs
          IEntityId.cs
          IModificationAuditable.cs
        Entities/
          DashboardTotalEntity.cs
          OrderGrowthLineChartEntity.cs
          TopProductPieChartEntity.cs
        Enums/
          DashboardTotalTitle.cs
        Exceptions/
          DomainException.cs
        Models/
          Externals/
            Keycloaks/
              KeycloakAccessToken.cs
              KeycloakUser.cs
        GlobalUsing.cs
        Report.Domain.csproj
      Report.Infrastructure/
        ApiClients/
          IKeycloakApi.cs
        Constants/
          MongoCollection.cs
        Data/
          Extensions/
            DatabaseExtentions.cs
        Exceptions/
          InfrastructureException.cs
        GrpcClients/
          Extensions/
            GrpcClientExtension.cs
          Interceptors/
            GrpcApiKeyInterceptor.cs
        Repositories/
          DashboardTotalRepository.cs
          OrderGrowthLineChartRepository.cs
          TopProductPieChartRepository.cs
        Services/
          CatalogGrpcService.cs
        DependencyInjection.cs
        GlobalUsing.cs
        InfrastructureMarker.cs
        Report.Infrastructure.csproj
  Search/
    Api/
      Search.Api/
        Constants/
          ApiRoutes.cs
        Endpoints/
          SearchProduct.cs
        DependencyInjection.cs
        GlobalUsing.cs
        Program.cs
        Search.Api.csproj
    Core/
      Search.Application/
        Dtos/
          Abstractions/
            AuditableDto.cs
            DtoId.cs
            EntityDto.cs
            ICreationAuditDto.cs
            IModificationAuditDto.cs
          Products/
            ProductDto.cs
            UpsertProductDto.cs
        Exceptions/
          ApplicationException.cs
        Features/
          Product/
            Commands/
              DeleteProductCommand.cs
              UpsertProductCommand.cs
            Queries/
              SearchProductQuery.cs
        Mappings/
          SearchMappingProfile.cs
        Models/
          Filters/
            SearchTermsFilter.cs
          Results/
            SearchProductResult.cs
        Repositories/
          IProductRepository.cs
        ApplicationMarker.cs
        DependencyInjection.cs
        GlobalUsing.cs
        Search.Application.csproj
      Search.Domain/
        Abstractions/
          Aggregate.cs
          Entity.cs
          EntityId.cs
          IAggregate.cs
          IAuditable.cs
          ICreationAuditable.cs
          IDomainEvent.cs
          IEntityId.cs
          IModificationAuditable.cs
        Entities/
          ProductEntity.cs
        Enums/
          ElasticIndex.cs
          ProductStatus.cs
          SortBy.cs
          SortType.cs
        Exceptions/
          DomainException.cs
        GlobalUsing.cs
        Search.Domain.csproj
      Search.Infrastructure/
        Data/
          ElasticSearchInitializer.cs
          ElasticSearchProfileMapping.cs
        Exceptions/
          InfrastructureException.cs
        Repositories/
          ProductRepository.cs
        DependencyInjection.cs
        GlobalUsing.cs
        InfrastructureMarker.cs
        Search.Infrastructure.csproj
    Worker/
      Search.Worker.Consumer/
        BackgroundServices/
          SearchBackgroudService.cs
        EventHandlers/
          Integrations/
            DeletedUnPublishedProductIntegrationEventHandler.cs
            UpsertedProductIntegrationEventHandler.cs
        DependencyInjection.cs
        Program.cs
        Search.Worker.Consumer.csproj
Shared/
  BuildingBlocks/
    Authentication/
      Extensions/
        AuthorizationExtension.cs
        UserContextExtension.cs
    Behaviors/
      LoggingBehavior.cs
      ValidationBehavior.cs
    CQRS/
      ICommand.cs
      ICommandHandler.cs
      IQuery.cs
      IQueryHandler.cs
    DistributedTracing/
      DistributedTracingExtension.cs
    Exceptions/
      Handler/
        CustomExceptionHandler.cs
      ClientValidationException.cs
      InternalServerException.cs
      NoPermissionException.cs
      NotFoundException.cs
      UnauthorizedException.cs
    Logging/
      ActivityTraceEnricher.cs
      SerilogLoggingExtensions.cs
    Pagination/
      Extensions/
        PagingExtensions.cs
      PaginatedResult.cs
      PagingResult.cs
    Swagger/
      Extensions/
        FormOpenApiExtensions.cs
        SwaggerGenExtension.cs
      AuthorizeCheckOperationFilter.cs
    Validators/
      CustomValidators.cs
    BuildingBlocks.csproj
  Common/
    Attributes/
      ExportExcelAttribute.cs
    Configurations/
      ApiClientCfg.cs
      AppConfigCfg.cs
      AppDomainCfg.cs
      AuthorizationCfg.cs
      ConnectionStringsCfg.cs
      CorsCfg.cs
      DistributedTracingCfg.cs
      ElasticSearchCfg.cs
      GrpcClientCfg.cs
      KeycloakApiCfg.cs
      MessageBrokerCfg.cs
      MinIoCfg.cs
      NotificationCfg.cs
      RedisCacheCfg.cs
      SerilogCfg.cs
      SwaggerGenCfg.cs
      WorkerCfg.cs
    Constants/
      AppConstants.cs
      AuthorizeRole.cs
      CustomClaimTypes.cs
      DatabaseType.cs
      MessageCode.cs
      ReqHeaderName.cs
    Enums/
      ApplicationStatus.cs
    Extensions/
      EnumExtension.cs
      HashExtension.cs
      NumericExtension.cs
      QueryableExtension.cs
      StringExtension.cs
    Helpers/
      EnumHelper.cs
      NumericHelper.cs
    Models/
      Context/
        UserContext.cs
      Reponses/
        ApiCreatedResponse.cs
        ApiDefaultPathResponse.cs
        ApiDeletedResponse.cs
        ApiGetResponse.cs
        ApiPerformedResponse.cs
        ApiUpdatedResponse.cs
        ResultSharedResponse.cs
      ErrorResult.cs
      PaginationRequest.cs
      UploadFileBytes.cs
      UploadFileResult.cs
    ValueObjects/
      Actor.cs
    Common.csproj
  Contracts/
    Catalog.Contract/
      Protos/
        catalog.proto
      Catalog.Contract.csproj
    Discount.Contract/
      Protos/
        discount.proto
      Discount.Contract.csproj
    Inventory.Contract/
      Protos/
        inventory.proto
      Inventory.Contract.csproj
    Order.Contract/
      Protos/
        order.proto
      Order.Contract.csproj
    Report.Contract/
      Protos/
        report.proto
      Report.Contract.csproj
  EventSourcing/
    Events/
      Baskets/
        BasketCheckoutIntegrationEvent.cs
      Catalog/
        DeletedUnPublishedProductIntegrationEvent.cs
        UpsertedProductIntegrationEvent.cs
      Inventories/
        ReservationExpiredIntegrationEvent.cs
        StockChangedIntegrationEvent.cs
      Orders/
        OrderCancelledIntegrationEvent.cs
        OrderCreatedIntegrationEvent.cs
        OrderDeliveredIntegrationEvent.cs
      AssemblyReference.cs
      IntegrationEvent.cs
    MassTransit/
      Extentions.cs
    EventSourcing.csproj
Directory.Build.props
Directory.Packages.props
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="ApiGateway/YarpApiGateway/Program.cs">
#region using

using HealthChecks.UI.Client;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Microsoft.AspNetCore.RateLimiting;

#endregion

#region Startup

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
var policyName = builder.Configuration.GetSection("CorsConfig:PolicyName").Get<string>()!;
builder.Services.AddCors(options =>
{
    options.AddPolicy(policyName,
        b => b
            .WithOrigins(builder.Configuration.GetSection("CorsConfig:Domains").Get<string[]>()!)
            .AllowAnyHeader()
            .AllowAnyMethod()
            .AllowCredentials()); // Required for SignalR to send cookies/tokens
});

builder.Services.AddReverseProxy()
    .LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"));

builder.Services.AddRateLimiter(rateLimiterOptions =>
{
    rateLimiterOptions.AddFixedWindowLimiter("fixed", options =>
    {
        options.Window = TimeSpan.FromSeconds(10);
        options.PermitLimit = 5;
    });
});

builder.Services.AddHealthChecks();

var app = builder.Build();

app.UseCors(policyName);

// Configure the HTTP request pipeline.
app.UseRateLimiter();

app.MapReverseProxy();

app.UseHealthChecks("/health",
    new HealthCheckOptions
    {
        ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
    });

app.MapGet("/", (IWebHostEnvironment env) => new
{
    Service = "API Gateway",
    Status = "Running",
    Timestamp = DateTimeOffset.UtcNow,
    Environment = env.EnvironmentName,
    Endpoints = new Dictionary<string, string>
            {
                { "health", "/health" }
            },
    Message = "API Gateway is running..."
});

app.Run();

#endregion
</file>

<file path="ApiGateway/YarpApiGateway/YarpApiGateway.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <ItemGroup>
    <PackageReference Include="Yarp.ReverseProxy" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" />
  </ItemGroup>

</Project>
</file>

<file path="JobOrchestrator/App.Job/ApiClients/IKeycloakApi.cs">
#region using

using App.Job.Models.Keycloaks;
using Refit;

#endregion

namespace App.Job.ApiClients;

public interface IKeycloakApi
{
    #region Methods

    [Post("/realms/{realm}/protocol/openid-connect/token")]
    [Headers("Content-Type: application/x-www-form-urlencoded")]
    Task<KeycloakAccessToken> GetAccessTokenAsync(
        [AliasAs("realm")] string realm,
        [Body(BodySerializationMethod.UrlEncoded)] Dictionary<string, string> form);

    [Get("/admin/realms/{realm}/users/count")]
    Task<long> GetUsersCountAsync(
        [AliasAs("realm")] string realm,
        [Header("Authorization")] string bearerToken);

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/Attributes/JobAttribute.cs">
namespace App.Job.Attributes;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
public class JobAttribute : Attribute
{
    #region Fields, Properties and Indexers

    public string? JobName { get; set; }

    public string? JobGroup { get; set; }

    public string? CronExpression { get; set; }

    public string? Description { get; set; }

    public bool AutoStart { get; set; } = true;

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/Enums/DashboardTotalTitle.cs">
#region using

using System.ComponentModel;

#endregion

namespace App.Job.Enums;

public enum DashboardTotalTitle
{
    #region Fields, Properties and Indexers

    [Description("Total Orders")]
    TotalOrders,

    [Description("Total Users")]
    TotalUsers,

    [Description("Total Products")]
    TotalProducts,

    [Description("Total Revenue")]
    TotalRevenue

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/GrpcClients/Interceptors/GrpcApiKeyInterceptor.cs">
#region using

using Common.Configurations;
using Common.Constants;
using Grpc.Core;
using Grpc.Core.Interceptors;

#endregion

namespace App.Job.GrpcClients.Interceptors;

public sealed class GrpcApiKeyInterceptor(IConfiguration cfg) : Interceptor
{
    #region Methods

    public override AsyncUnaryCall<TResponse> AsyncUnaryCall<TRequest, TResponse>(
        TRequest request,
        ClientInterceptorContext<TRequest, TResponse> context,
        AsyncUnaryCallContinuation<TRequest, TResponse> continuation)
    {
        var grpcKey = cfg.GetValue<string>($"{GrpcClientCfg.Catalog.Section}:{GrpcClientCfg.Catalog.ApiKey}")
            ?? throw new InvalidOperationException("gRPC Key is not configured.");

        var headers = context.Options.Headers ?? [];

        if (!headers.Any(h => h.Key.Equals(ReqHeaderName.GrpcKey, StringComparison.OrdinalIgnoreCase)))
        {
            headers.Add(ReqHeaderName.GrpcKey, grpcKey);
        }

        var newOptions = context.Options.WithHeaders(headers);
        var newContext = new ClientInterceptorContext<TRequest, TResponse>(
            context.Method,
            context.Host,
            newOptions);

        return base.AsyncUnaryCall(request, newContext, continuation);
    }

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/Jobs/Inventory/ExpireInventoryReservationsJob.cs">
#region using

using App.Job.Attributes;
using Inventory.Grpc;
using Quartz;

#endregion

namespace App.Job.Jobs.Inventory;

[Job(
    JobName = "ExpireInventoryReservations",
    JobGroup = "Inventory",
    Description = "Expires pending inventory reservations that have exceeded their expiration time",
    CronExpression = "0 0/5 * * * ?", // Runs every 5 minutes
    AutoStart = true)]
public class ExpireInventoryReservationsJob(
    ILogger<ExpireInventoryReservationsJob> logger,
    InventoryGrpc.InventoryGrpcClient inventoryGrpc) : IJob
{
    #region Implementations

    public async Task Execute(IJobExecutionContext context)
    {
        var jobKey = context.JobDetail.Key;

        logger.LogInformation(
            "Job {JobName} started at {StartTime}",
            jobKey.Name,
            DateTimeOffset.Now);

        try
        {
            await ExpireReservationsAsync(context.CancellationToken);

            logger.LogInformation(
                "Job {JobName} completed successfully at {EndTime}",
                jobKey.Name,
                DateTimeOffset.Now);
        }
        catch (OperationCanceledException)
        {
            logger.LogWarning("Job {JobName} was cancelled", jobKey.Name);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Job {JobName} failed with error", jobKey.Name);
        }
    }

    #endregion

    #region Private Methods

    private async Task ExpireReservationsAsync(CancellationToken cancellationToken)
    {
        logger.LogInformation("Checking for expired inventory reservations...");

        var response = await inventoryGrpc.ExpireReservationAsync(
            new ExpireReservationRequest { },
            cancellationToken: cancellationToken);

        logger.LogInformation("Expire reservations result: {Result}", response.Success);
    }

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/Jobs/Report/SyncDashboardReportJob.cs">
#region using

using App.Job.ApiClients;
using App.Job.Attributes;
using App.Job.Enums;
using App.Job.Models.Orders;
using Catalog.Grpc;
using Common.Configurations;
using Common.Extensions;
using Google.Protobuf.WellKnownTypes;
using Order.Grpc;
using Quartz;
using Report.Grpc;

#endregion

namespace App.Job.Jobs.Report;

[Job(
    JobName = "SyncDashboardReport",
    JobGroup = "Report",
    Description = "Synchronizes dashboard report data from multiple sources",
    CronExpression = "0 0/1 * * * ?", // Runs every 1 minutes
    AutoStart = true)]
public class SyncDashboardReportJob(ILogger<SyncDashboardReportJob> logger,
    IKeycloakApi keycloak,
    IConfiguration cfg,
    ReportGrpc.ReportGrpcClient reportGrpc,
    OrderGrpc.OrderGrpcClient orderGrpc,
    CatalogGrpc.CatalogGrpcClient catalogGrpc) : IJob
{
    #region Implementations

    public async Task Execute(IJobExecutionContext context)
    {
        var jobKey = context.JobDetail.Key;

        logger.LogInformation(
            "Job {JobName} started at {StartTime}",
            jobKey.Name,
            DateTimeOffset.Now);

        try
        {
            logger.LogInformation("Fetching order statistics...");
            await SyncOrderStatisticsAsync(context.CancellationToken);

            logger.LogInformation("Fetching product statistics...");
            await SyncProductStatisticsAsync(context.CancellationToken);

            logger.LogInformation("Fetching dashboard card...");
            await SyncDashboardCardAsync(context.CancellationToken);

            logger.LogInformation("Job {JobName} completed successfully at {EndTime}", jobKey.Name, DateTimeOffset.Now);
        }
        catch (OperationCanceledException)
        {
            logger.LogWarning("Job {JobName} was cancelled", jobKey.Name);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Job {JobName} failed with error", jobKey.Name);
        }
    }

    #endregion

    #region Private Methods

    private async Task SyncOrderStatisticsAsync(CancellationToken cancellationToken)
    {
        var orders = await GetOrdersByMonthAsync(cancellationToken);

        // Group orders by day and calculate statistics
        var dailyStats = orders
            .GroupBy(o => o.OrderDate.Day)
            .Select(g => new OrderGrowthLineChartItem
            {
                Day = g.Key,
                Value = g.Sum(o => (double)o.FinalPrice),
                Date = Timestamp.FromDateTime(new DateTime(
                    DateTime.UtcNow.Year,
                    DateTime.UtcNow.Month,
                    g.Key, 0, 0, 0, DateTimeKind.Utc))
            })
            .ToList();

        // Call Report gRPC
        await reportGrpc.PutOrderGrowthLineChartAsync(
            new PutOrderGrowthLineChartRequest { Items = { dailyStats } },
            cancellationToken: cancellationToken);

        logger.LogInformation("Order statistics synced successfully");
    }

    private async Task SyncProductStatisticsAsync(CancellationToken cancellationToken)
    {
        var orders = await GetAllOrdersync(cancellationToken);

        // Calculate top products by total quantity sold
        var topProducts = orders
            .SelectMany(o => o.OrderItems)
            .GroupBy(item => new { item.ProductId, item.ProductName })
            .Select(g => new TopProductPieChartItem
            {
                Name = g.Key.ProductName,
                Value = g.Sum(item => item.Quantity)
            })
            .OrderByDescending(x => x.Value)
            .Take(10)
            .ToList();

        // Call Report gRPC
        await reportGrpc.PutTopProductPieChartAsync(
            new PutTopProductPieChartRequest { Items = { topProducts } },
            cancellationToken: cancellationToken);

        logger.LogInformation("Product statistics synced successfully");
    }

    private async Task SyncDashboardCardAsync(CancellationToken cancellationToken)
    {
        var orders = await GetOrdersByMonthAsync(cancellationToken);
        var usersCount = await GetUsersCountAsync(cancellationToken);
        var productsCount = await GetCountProductAsync(cancellationToken);

        // Calculate statistics
        var totalOrders = orders.Count;
        var totalRevenue = orders.Sum(o => o.FinalPrice);

        // Call Report gRPC to update 4 cards
        await reportGrpc.PutDashboardTotalAsync(new PutDashboardTotalRequest
        {
            Title = DashboardTotalTitle.TotalOrders.GetDescription(),
            Count = totalOrders.ToString()
        }, cancellationToken: cancellationToken);

        await reportGrpc.PutDashboardTotalAsync(new PutDashboardTotalRequest
        {
            Title = DashboardTotalTitle.TotalUsers.GetDescription(),
            Count = usersCount.ToString()
        }, cancellationToken: cancellationToken);

        await reportGrpc.PutDashboardTotalAsync(new PutDashboardTotalRequest
        {
            Title = DashboardTotalTitle.TotalProducts.GetDescription(),
            Count = productsCount.ToString()
        }, cancellationToken: cancellationToken);

        await reportGrpc.PutDashboardTotalAsync(new PutDashboardTotalRequest
        {
            Title = DashboardTotalTitle.TotalRevenue.GetDescription(),
            Count = totalRevenue.ToString("N0")
        }, cancellationToken: cancellationToken);

        logger.LogInformation("Dashboard updated successfully");
    }

    private async Task<long> GetUsersCountAsync(CancellationToken cancellationToken)
    {
        var realm = cfg[$"{ApiClientCfg.Keycloak.Section}:{ApiClientCfg.Keycloak.Realm}"]!;
        var form = new Dictionary<string, string>
        {
            { "client_id", cfg[$"{ApiClientCfg.Keycloak.Section}:{ApiClientCfg.Keycloak.ClientId}"]! },
            { "client_secret", cfg[$"{ApiClientCfg.Keycloak.Section}:{ApiClientCfg.Keycloak.ClientSecret}"]! },
            { "grant_type", cfg[$"{ApiClientCfg.Keycloak.Section}:{ApiClientCfg.Keycloak.GrantType}"]! },
            { "scope", string.Join(" ", cfg.GetRequiredSection($"{ApiClientCfg.Keycloak.Section}:{ApiClientCfg.Keycloak.Scopes}").Get<string[]>()!) }
        };

        var accessToken = await keycloak.GetAccessTokenAsync(realm, form);
        var count = await keycloak.GetUsersCountAsync(realm, $"Bearer {accessToken.AccessToken}");

        return count;
    }

    private async Task<long> GetCountProductAsync(CancellationToken cancellationToken)
    {
        var result = await catalogGrpc.GetCountProductAsync(
                new GetCountProductRequest { },
                cancellationToken: cancellationToken);
        return result.Count;
    }

    private async Task<List<OrderModel>> GetOrdersByMonthAsync(CancellationToken cancellationToken)
    {
        var now = DateTime.UtcNow;
        var result = await orderGrpc.GetOrdersByMonthAsync(
                new GetOrdersByMonthRequest { Year = now.Year, Month = now.Month },
                cancellationToken: cancellationToken);

        var orders = result.Orders.Select(order => new OrderModel
        {
            Id = order.Id,
            OrderDate = order.CreatedOnUtc?.ToDateTime() ?? DateTime.UtcNow,
            TotalPrice = (decimal)order.TotalPrice,
            FinalPrice = (decimal)order.FinalPrice,
            OrderItems = order.OrderItems.Select(item => new OrderItemModel
            {
                ProductId = item.Product.Id,
                ProductName = item.Product.Name,
                ProductPrice = (decimal)item.Product.Price,
                Quantity = item.Quantity
            }).ToList()
        }).ToList();

        return orders;
    }

    private async Task<List<OrderModel>> GetAllOrdersync(CancellationToken cancellationToken)
    {
        var now = DateTime.UtcNow;
        var result = await orderGrpc.GetAllOrdersAsync(
                new GetAllOrdersRequest { },
                cancellationToken: cancellationToken);

        var orders = result.Orders.Select(order => new OrderModel
        {
            Id = order.Id,
            OrderDate = order.CreatedOnUtc?.ToDateTime() ?? DateTime.UtcNow,
            TotalPrice = (decimal)order.TotalPrice,
            FinalPrice = (decimal)order.FinalPrice,
            OrderItems = order.OrderItems.Select(item => new OrderItemModel
            {
                ProductId = item.Product.Id,
                ProductName = item.Product.Name,
                ProductPrice = (decimal)item.Product.Price,
                Quantity = item.Quantity
            }).ToList()
        }).ToList();

        return orders;
    }

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/Models/Keycloaks/KeycloakAccessToken.cs">
#region using

using System.Text.Json.Serialization;

#endregion

namespace App.Job.Models.Keycloaks;

public sealed class KeycloakAccessToken
{
    #region Fields, Properties and Indexers

    [JsonPropertyName("access_token")]
    public string? AccessToken { get; set; }

    [JsonPropertyName("expires_in")]
    public int ExpiresIn { get; set; }

    [JsonPropertyName("refresh_expires_in")]
    public int RefreshExpiresIn { get; set; }

    [JsonPropertyName("token_type")]
    public string? TokenType { get; set; }

    [JsonPropertyName("id_token")]
    public string? IdToken { get; set; }

    [JsonPropertyName("not-before-policy")]
    public int NotBeforePolicy { get; set; }

    [JsonPropertyName("scope")]
    public string? Scope { get; set; }

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/Models/Keycloaks/KeycloakUser.cs">
#region using

using System.Text.Json.Serialization;

#endregion

namespace App.Job.Models.Keycloaks;

public sealed class KeycloakUser
{
    #region Fields, Properties and Indexers

    [JsonPropertyName("id")]
    public string Id { get; set; } = default!;

    [JsonPropertyName("createdTimestamp")]
    public long CreatedTimestamp { get; set; }

    [JsonPropertyName("username")]
    public string? Username { get; set; }

    [JsonPropertyName("enabled")]
    public bool Enabled { get; set; }

    [JsonPropertyName("totp")]
    public bool Totp { get; set; }

    [JsonPropertyName("emailVerified")]
    public bool EmailVerified { get; set; }

    [JsonPropertyName("firstName")]
    public string? FirstName { get; set; }

    [JsonPropertyName("lastName")]
    public string? LastName { get; set; }

    [JsonPropertyName("email")]
    public string? Email { get; set; }

    [JsonPropertyName("notBefore")]
    public int NotBefore { get; set; }

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/Models/Orders/OrderItemModel.cs">
namespace App.Job.Models.Orders;

public sealed class OrderItemModel
{
    #region Fields, Properties and Indexers

    public string Id { get; set; } = string.Empty;

    public string ProductId { get; set; } = string.Empty;

    public string ProductName { get; set; } = string.Empty;

    public decimal ProductPrice { get; set; }

    public int Quantity { get; set; }

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/Models/Orders/OrderModel.cs">
namespace App.Job.Models.Orders;

public class OrderModel
{
    #region Fields, Properties and Indexers

    public string Id { get; set; } = string.Empty;

    public DateTime OrderDate { get; set; }

    public decimal TotalPrice { get; set; }

    public decimal FinalPrice { get; set; }

    public List<OrderItemModel> OrderItems { get; set; } = default!;

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/Quartz/JobRegistrationExtensions.cs">
#region using

using App.Job.Attributes;
using Quartz;
using System.Reflection;

#endregion

namespace App.Job.Quartz;

public static class JobRegistrationExtensions
{
    #region Methods

    public static IServiceCollection AddQuartzJobs(this IServiceCollection services)
    {
        var jobTypes = DiscoverJobTypes();

        foreach (var jobType in jobTypes)
        {
            services.AddScoped(jobType);
        }

        return services;
    }

    public static async Task RegisterJobsToScheduler(
        this IScheduler scheduler,
        ILogger logger,
        CancellationToken cancellationToken = default)
    {
        var jobTypes = DiscoverJobTypes();

        foreach (var jobType in jobTypes)
        {
            try
            {
                var jobAttribute = jobType.GetCustomAttribute<JobAttribute>();
                var jobName = jobAttribute?.JobName ?? jobType.Name;
                var jobGroup = jobAttribute?.JobGroup ?? GetJobGroupFromNamespace(jobType.Namespace ?? string.Empty);
                var description = jobAttribute?.Description ?? $"Job: {jobType.Name}";

                // Create JobDetail
                var jobDetail = JobBuilder
                    .Create(jobType)
                    .WithIdentity(jobName, jobGroup)
                    .WithDescription(description)
                    .StoreDurably()
                    .Build();

                // Register job to scheduler
                await scheduler.AddJob(jobDetail, replace: true, cancellationToken: cancellationToken);

                // If cron expression exists and AutoStart is true, create trigger
                if (jobAttribute != null &&
                    !string.IsNullOrWhiteSpace(jobAttribute.CronExpression) &&
                    jobAttribute.AutoStart)
                {
                    var trigger = TriggerBuilder
                        .Create()
                        .WithIdentity($"{jobName}_Trigger", jobGroup)
                        .ForJob(jobName, jobGroup)
                        .WithCronSchedule(jobAttribute.CronExpression)
                        .WithDescription($"Trigger for {jobName}")
                        .Build();

                    await scheduler.ScheduleJob(trigger, cancellationToken);

                    logger.LogInformation(
                        "Registered and scheduled job: {JobName} in group {JobGroup} with cron: {CronExpression}",
                        jobName, jobGroup, jobAttribute.CronExpression);
                }
                else
                {
                    logger.LogInformation(
                        "Registered job (manual trigger): {JobName} in group {JobGroup}",
                        jobName, jobGroup);
                }
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "Failed to register job: {JobType}", jobType.Name);
            }
        }
    }

    #endregion

    #region Private Methods

    private static List<Type> DiscoverJobTypes()
    {
        try
        {
            var assembly = Assembly.GetExecutingAssembly();
            return GetJobTypesFromAssembly(assembly);
        }
        catch (Exception)
        {
            return new List<Type>();
        }
    }

    private static List<Type> GetJobTypesFromAssembly(Assembly assembly)
    {
        try
        {
            var types = assembly.GetTypes()
                .Where(t =>
                    !t.IsAbstract &&
                    !t.IsInterface &&
                    typeof(IJob).IsAssignableFrom(t) &&
                    (t.Namespace?.StartsWith("App.Job.Jobs") == true ||
                     t.GetCustomAttribute<JobAttribute>() != null))
                .ToList();

            return types;
        }
        catch (ReflectionTypeLoadException)
        {
            return new List<Type>();
        }
    }

    private static string GetJobGroupFromNamespace(string namespaceName)
    {
        if (string.IsNullOrWhiteSpace(namespaceName))
            return "Default";

        var parts = namespaceName.Split('.');

        // Find "Jobs" and get the next part as group name
        var jobsIndex = Array.IndexOf(parts, "Jobs");
        if (jobsIndex >= 0 && jobsIndex < parts.Length - 1)
        {
            return parts[jobsIndex + 1];
        }

        return "Default";
    }

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/Quartz/QuartzHostedService.cs">
#region using

using Quartz;

#endregion

namespace App.Job.Quartz;

public class QuartzHostedService(IScheduler scheduler, ILogger<QuartzHostedService> logger) : IHostedService
{
    #region Implementations

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        logger.LogInformation("Starting Quartz Scheduler...");
        await scheduler.Start(cancellationToken);
        logger.LogInformation("Quartz Scheduler started successfully");
    }

    public async Task StopAsync(CancellationToken cancellationToken)
    {
        logger.LogInformation("Stopping Quartz Scheduler...");
        await scheduler.Shutdown(true, cancellationToken);
        logger.LogInformation("Quartz Scheduler stopped");
    }

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/Quartz/QuartzJobFactory.cs">
#region using

using Quartz;
using Quartz.Spi;
using System.Collections.Concurrent;

#endregion

namespace App.Job.Quartz;

public class QuartzJobFactory : IJobFactory
{
    #region Fields, Properties and Indexers

    private readonly IServiceScopeFactory _serviceScopeFactory;

    private readonly ConcurrentDictionary<IJob, IServiceScope> _jobScopes = new();

    #endregion

    #region Ctors

    public QuartzJobFactory(IServiceScopeFactory serviceScopeFactory)
    {
        _serviceScopeFactory = serviceScopeFactory;
    }


    #endregion

    #region Implementations

    public IJob NewJob(TriggerFiredBundle bundle, IScheduler scheduler)
    {
        var jobDetail = bundle.JobDetail;
        var jobType = jobDetail.JobType;
        var scope = _serviceScopeFactory.CreateScope();

        try
        {
            var job = scope.ServiceProvider.GetService(jobType) as IJob;

            if (job == null)
            {
                scope.Dispose();
                throw new InvalidOperationException($"Unable to create job of type {jobType.Name}");
            }

            _jobScopes[job] = scope;

            return job;
        }
        catch
        {
            scope.Dispose();
            throw;
        }
    }

    public void ReturnJob(IJob job)
    {
        if (_jobScopes.TryRemove(job, out var scope))
        {
            scope.Dispose();
        }

        if (job is IDisposable disposable)
        {
            disposable.Dispose();
        }
    }

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/App.Job.csproj">
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <PropertyGroup>
    <UserSecretsId>dotnet-App.Job-8493b734-01bf-497f-81a0-1b507d4a65c7</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <Protobuf Include="..\..\Shared\Contracts\Catalog.Contract\Protos\catalog.proto" GrpcServices="Client" />
    <Protobuf Include="..\..\Shared\Contracts\Report.Contract\Protos\report.proto" GrpcServices="Client" />
    <Protobuf Include="..\..\Shared\Contracts\Order.Contract\Protos\order.proto" GrpcServices="Client" />
    <Protobuf Include="..\..\Shared\Contracts\Inventory.Contract\Protos\inventory.proto" GrpcServices="Client" />
  </ItemGroup>
  
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="Quartz" />
    <PackageReference Include="Quartz.Extensions.Hosting" />
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="Google.Protobuf" />
    <PackageReference Include="Grpc.Net.Client" />
    <PackageReference Include="Grpc.Tools">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Refit.HttpClientFactory" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\Shared\Common\Common.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="JobOrchestrator/App.Job/DependencyInjection.cs">
#region using

using App.Job.ApiClients;
using App.Job.GrpcClients.Interceptors;
using App.Job.Quartz;
using BuildingBlocks.Logging;
using Catalog.Grpc;
using Common.Configurations;
using Inventory.Grpc;
using Order.Grpc;
using Quartz;
using Refit;
using Report.Grpc;

#endregion

namespace App.Job;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddWorkerServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddSerilogLogging(cfg);

        services.AddQuartz(q =>
        {
            q.UseInMemoryStore();
            q.UseDefaultThreadPool(tp =>
            {
                tp.MaxConcurrency = 10;
            });

            q.UseJobFactory<QuartzJobFactory>();
        });

        services.AddQuartzHostedService(q => q.WaitForJobsToComplete = true);
        services.AddQuartzJobs();
        services.AddRefitClients(cfg);
        services.AddGrpcClients(cfg);

        return services;
    }

    public static async Task RegisterJobsAsync(
        this IServiceProvider serviceProvider,
        CancellationToken cancellationToken = default)
    {
        var scheduler = await serviceProvider.GetRequiredService<ISchedulerFactory>().GetScheduler(cancellationToken);
        var loggerFactory = serviceProvider.GetRequiredService<ILoggerFactory>();
        var logger = loggerFactory.CreateLogger("App.Job");

        await scheduler.RegisterJobsToScheduler(logger, cancellationToken);
    }

    #endregion

    #region Private Methods

    private static IServiceCollection AddRefitClients(this IServiceCollection services, IConfiguration cfg)
    {
        services.AddRefitClient<IKeycloakApi>()
                .ConfigureHttpClient(c =>
                {
                    c.BaseAddress = new Uri(cfg[$"{KeycloakApiCfg.Section}:{KeycloakApiCfg.BaseUrl}"]!);
                    c.Timeout = TimeSpan.FromSeconds(30);
                });

        return services;
    }

    public static IServiceCollection AddGrpcClients(this IServiceCollection services, IConfiguration cfg)
    {
        // Catalog Grpc
        {
            var catalogServiceUrl = cfg.GetValue<string>($"{GrpcClientCfg.Catalog.Section}:{GrpcClientCfg.Catalog.Url}")
            ?? throw new InvalidOperationException("Catalog service URL is not configured.");

            services.AddGrpcClient<CatalogGrpc.CatalogGrpcClient>(options =>
            {
                options.Address = new Uri(catalogServiceUrl);
            })
            .AddInterceptor<GrpcApiKeyInterceptor>()
            .ConfigurePrimaryHttpMessageHandler(() =>
            {
                return new HttpClientHandler
                {
                    ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
                };
            });
        }

        // Order Grpc
        {
            var orderServiceUrl = cfg.GetValue<string>($"{GrpcClientCfg.Order.Section}:{GrpcClientCfg.Order.Url}")
            ?? throw new InvalidOperationException("Order service URL is not configured.");

            services.AddGrpcClient<OrderGrpc.OrderGrpcClient>(options =>
            {
                options.Address = new Uri(orderServiceUrl);
            })
            .AddInterceptor<GrpcApiKeyInterceptor>()
            .ConfigurePrimaryHttpMessageHandler(() =>
            {
                return new HttpClientHandler
                {
                    ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
                };
            });
        }

        // Report Grpc
        {
            var reportServiceUrl = cfg.GetValue<string>($"{GrpcClientCfg.Report.Section}:{GrpcClientCfg.Report.Url}")
            ?? throw new InvalidOperationException("Report service URL is not configured.");

            services.AddGrpcClient<ReportGrpc.ReportGrpcClient>(options =>
            {
                options.Address = new Uri(reportServiceUrl);
            })
            .AddInterceptor<GrpcApiKeyInterceptor>()
            .ConfigurePrimaryHttpMessageHandler(() =>
            {
                return new HttpClientHandler
                {
                    ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
                };
            });
        }

        // Inventory Grpc
        {
            var inventoryServiceUrl = cfg.GetValue<string>($"{GrpcClientCfg.Inventory.Section}:{GrpcClientCfg.Inventory.Url}")
            ?? throw new InvalidOperationException("Inventory service URL is not configured.");

            services.AddGrpcClient<InventoryGrpc.InventoryGrpcClient>(options =>
            {
                options.Address = new Uri(inventoryServiceUrl);
            })
            .AddInterceptor<GrpcApiKeyInterceptor>()
            .ConfigurePrimaryHttpMessageHandler(() =>
            {
                return new HttpClientHandler
                {
                    ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
                };
            });
        }

        services.AddSingleton<GrpcApiKeyInterceptor>();

        return services;
    }

    #endregion
}
</file>

<file path="JobOrchestrator/App.Job/Program.cs">
#region using

using App.Job;

#endregion

var builder = Host.CreateApplicationBuilder(args);

builder.Services.AddWorkerServices(builder.Configuration);

var host = builder.Build();

await host.Services.RegisterJobsAsync();

await host.RunAsync();
</file>

<file path="Services/Basket/Api/Basket.Api/Constants/ApiRoutes.cs">
namespace Basket.Api.Constants;

public sealed class ApiRoutes
{
    public static class Basket
    {
        #region Constants

        public const string Tags = "Baskets";

        private const string Base = "basket";

        public const string GetBasket = $"/{Base}";

        public const string StoreBasket = $"/{Base}";

        public const string DeleteBasket = $"/{Base}";

        public const string CheckoutBasket = $"/{Base}/checkout";

        #endregion
    }
}
</file>

<file path="Services/Basket/Api/Basket.Api/Endpoints/BasketCheckout.cs">
#region using

using Basket.Api.Constants;
using Basket.Application.Features.Basket.Commands;
using Basket.Application.Dtos.Baskets;
using BuildingBlocks.Authentication.Extensions;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Basket.Api.Endpoints;

public sealed class BasketCheckout : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Basket.CheckoutBasket, HandleBasketCheckoutAsync)
            .WithTags(ApiRoutes.Basket.Tags)
            .WithName(nameof(BasketCheckout))
            .Produces<ApiCreatedResponse<Guid>>(StatusCodes.Status201Created)
            .Produces(StatusCodes.Status401Unauthorized)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .DisableAntiforgery()
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiCreatedResponse<Guid>> HandleBasketCheckoutAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromBody] BasketCheckoutDto dto)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new BasketCheckoutCommand(currentUser.Id, dto);
        var result = await sender.Send(command);

        return new ApiCreatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Basket/Api/Basket.Api/Endpoints/DeleteBasket.cs">
#region using

using Basket.Api.Constants;
using Basket.Application.Features.Basket.Commands;
using BuildingBlocks.Authentication.Extensions;

#endregion

namespace Basket.Api.Endpoints;

public sealed class DeleteBasket : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapDelete(ApiRoutes.Basket.DeleteBasket, HandleDeleteBasketAsync)
            .WithTags(ApiRoutes.Basket.Tags)
            .WithName(nameof(DeleteBasket))
            .Produces<ApiDeletedResponse<Guid>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiDeletedResponse<Guid>> HandleDeleteBasketAsync(
        ISender sender,
        IHttpContextAccessor httpContext)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new DeleteBasketCommand(currentUser.Id);

        await sender.Send(command);

        return new ApiDeletedResponse<Guid>(Guid.Parse(currentUser.Id));
    }

    #endregion
}
</file>

<file path="Services/Basket/Api/Basket.Api/Endpoints/GetBasket.cs">
#region using

using Basket.Api.Constants;
using Basket.Application.Models.Results;
using Basket.Application.Features.Basket.Queries;
using BuildingBlocks.Authentication.Extensions;

#endregion

namespace Basket.Api.Endpoints;

public sealed class GetBasket : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Basket.GetBasket, HandleGetBasketAsync)
            .WithTags(ApiRoutes.Basket.Tags)
            .WithName(nameof(GetBasket))
            .Produces<ApiGetResponse<GetBasketResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetBasketResult>> HandleGetBasketAsync(
        ISender sender,
        IHttpContextAccessor httpContext)
    {
        var currentUser = httpContext.GetCurrentUser();
        var query = new GetBasketQuery(currentUser.Id);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetBasketResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Basket/Api/Basket.Api/Endpoints/StoreBasket.cs">
#region using

using Basket.Api.Constants;
using Microsoft.AspNetCore.Mvc;
using Basket.Application.Dtos.Baskets;
using Basket.Application.Features.Basket.Commands;
using BuildingBlocks.Authentication.Extensions;

#endregion

namespace Basket.Api.Endpoints;

public sealed class StoreBasket : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Basket.StoreBasket, HandleStoreBasketAsync)
            .WithTags(ApiRoutes.Basket.Tags)
            .WithName(nameof(StoreBasket))
            .Produces<ApiCreatedResponse<Guid>>(StatusCodes.Status201Created)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .DisableAntiforgery()
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiCreatedResponse<Guid>> HandleStoreBasketAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromBody] StoreShoppingCartDto dto)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new StoreBasketCommand(currentUser.Id, dto);
        var result = await sender.Send(command);

        return new ApiCreatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Basket/Api/Basket.Api/Basket.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <UserSecretsId>68beccec-977d-4711-a7f7-5d8d06e5c2e0</UserSecretsId>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="AspNetCore.HealthChecks.MongoDb" />
    <PackageReference Include="AspNetCore.HealthChecks.MySql" />
    <PackageReference Include="AspNetCore.HealthChecks.NpgSql" />
    <PackageReference Include="AspNetCore.HealthChecks.Redis" />
    <PackageReference Include="AspNetCore.HealthChecks.SqlServer" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" />
    <PackageReference Include="Carter" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Basket.Application\Basket.Application.csproj" />
    <ProjectReference Include="..\..\Core\Basket.Infrastructure\Basket.Infrastructure.csproj" />
  </ItemGroup>
  
  <ItemGroup>
    <Folder Include="Models\" />
  </ItemGroup>
  
</Project>
</file>

<file path="Services/Basket/Api/Basket.Api/DependencyInjection.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using BuildingBlocks.Swagger.Extensions;
using Common.Configurations;
using Common.Constants;
using HealthChecks.UI.Client;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;

#endregion

namespace Basket.Api;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddApiServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services.AddCarter();

        // HealthChecks
        {
            var dbype = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DbType}"];
            var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];
            var dbName = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DatabaseName}"];

            switch (dbype)
            {
                case DatabaseType.SqlServer:
                    services.AddHealthChecks()
                        .AddSqlServer(connectionString: conn!);
                    break;
                case DatabaseType.MySql:
                    services.AddHealthChecks()
                        .AddMySql(connectionString: conn!);
                    break;
                case DatabaseType.PostgreSql:
                    services.AddHealthChecks()
                        .AddNpgSql(connectionString: conn!);
                    break;
                case DatabaseType.MongoDb:
                    services.AddHealthChecks()
                        .AddMongoDb(
                            clientFactory: sp => new MongoDB.Driver.MongoClient(conn!),
                            databaseNameFactory: sp => dbName!);
                    break;
                default:
                    throw new Exception("Unsupported database type");
            }
        }

        services.AddHttpContextAccessor();
        services.AddAuthenticationAndAuthorization(cfg);
        services.AddSwaggerServices(cfg);

        return services;
    }

    public static WebApplication UseApi(this WebApplication app)
    {
        app.UseSerilogReqLogging();
        app.UsePrometheusEndpoint();
        app.MapCarter();
        app.UseExceptionHandler(options => { });
        app.UseHealthChecks("/health",
            new HealthCheckOptions
            {
                ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
            });

        app.UseAuthentication();
        app.UseAuthorization();
        app.UseSwaggerApi();

        app.MapGet("/", (IWebHostEnvironment env) => new ApiDefaultPathResponse
        {
            Service = "Basket.Api",
            Status = "Running",
            Timestamp = DateTimeOffset.UtcNow,
            Environment = env.EnvironmentName,
            Endpoints = new Dictionary<string, string>
            {
                { "health", "/health" }
            },
            Message = "API is running..."
        });

        return app;
    }

    #endregion

}
</file>

<file path="Services/Basket/Api/Basket.Api/GlobalUsing.cs">
global using Carter;
global using MediatR;
global using Common.Models.Reponses;
</file>

<file path="Services/Basket/Api/Basket.Api/Program.cs">
#region using

using Basket.Api;
using Basket.Application;
using Basket.Infrastructure;

#endregion

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddApiServices(builder.Configuration);

var app = builder.Build();

// Configure the HTTP request pipeline.
app.UseApi();
app.UseInfrastructure();

app.Run();
</file>

<file path="Services/Basket/Core/Basket.Application/Dtos/Abstractions/AuditableDto.cs">
namespace Basket.Application.Dtos.Abstractions;

public abstract class AuditableDto : IAuditableDto
{
    #region Fields, Properties and Indexers

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}

public interface IAuditableDto : ICreationAuditDto, IModificationAuditDto { }
</file>

<file path="Services/Basket/Core/Basket.Application/Dtos/Abstractions/DtoId.cs">
namespace Basket.Application.Dtos.Abstractions;

public class DtoId<T> : IDtoId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    #endregion
}

public interface IDtoId<T>
{
    T Id { get; init; }
}
</file>

<file path="Services/Basket/Core/Basket.Application/Dtos/Abstractions/EntityDto.cs">
namespace Basket.Application.Dtos.Abstractions;

public abstract class EntityDto<T> : IDtoId<T>, IAuditableDto
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Dtos/Abstractions/ICreationAuditDto.cs">
namespace Basket.Application.Dtos.Abstractions;

public interface ICreationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Dtos/Abstractions/IModificationAuditDto.cs">
namespace Basket.Application.Dtos.Abstractions;

public interface IModificationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Basket/Core/Basket.Application/Dtos/Baskets/BasketCheckoutAddressDto.cs">
namespace Basket.Application.Dtos.Baskets;

public sealed record BasketCheckoutAddressDto
{
    #region Fields, Properties and Indexers

    public string AddressLine { get; init; } = default!;

    public string Subdivision { get; init; } = default!;

    public string City { get; init; } = default!;

    public string StateOrProvince { get; init; } = default!;

    public string Country { get; init; } = default!;

    public string PostalCode { get; init; } = default!;

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Dtos/Baskets/BasketCheckoutCustomerDto.cs">
namespace Basket.Application.Dtos.Baskets;

public sealed record BasketCheckoutCustomerDto
{
    #region Fields, Properties and Indexers

    public string Name { get; init; } = default!;

    public string Email { get; init; } = default!;

    public string PhoneNumber { get; init; } = default!;

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Dtos/Baskets/BasketCheckoutDto.cs">
namespace Basket.Application.Dtos.Baskets;

public class BasketCheckoutDto
{
    #region Fields, Properties and Indexers

    public BasketCheckoutCustomerDto Customer { get; set; } = default!;

    public BasketCheckoutAddressDto ShippingAddress { get; set; } = default!;

    public string? CouponCode { get; set; }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Dtos/Baskets/BasketCheckoutItemDto.cs">
namespace Basket.Application.Dtos.Baskets;

public sealed record BasketCheckoutItemDto
{
    #region Fields, Properties and Indexers

    public Guid ProductId { get; init; }

    public int Quantity { get; init; }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Dtos/Baskets/ShoppingCartDto.cs">
#region using

#endregion

namespace Basket.Application.Dtos.Baskets;

public class ShoppingCartDto
{
    #region Fields, Properties and Indexers

    public string UserId { get; set; } = default!;

    public List<ShoppingCartItemDto> Items { get; set; } = default!;

    public decimal TotalPrice { get; set; }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Dtos/Baskets/ShoppingCartItemDto.cs">
namespace Basket.Application.Dtos.Baskets;

public class ShoppingCartItemDto
{
    #region Fields, Properties and Indexers

    public int Quantity { get; set; } = default!;

    public decimal Price { get; set; } = default!;

    public Guid ProductId { get; set; } = default!;

    public string ProductName { get; set; } = default!;

    public string ProductSlug { get; set; } = default!;

    public string ProductImage { get; set; } = default!;

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Dtos/Baskets/StoreShoppingCartDto.cs">
namespace Basket.Application.Dtos.Baskets;

public sealed class StoreShoppingCartDto
{
    #region Fields, Properties and Indexers

    public List<StoreShoppingCartItemDto> Items { get; set; } = [];

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Dtos/Baskets/StoreShoppingCartItemDto.cs">
namespace Basket.Application.Dtos.Baskets;

public sealed class StoreShoppingCartItemDto
{
    #region Fields, Properties and Indexers

    public Guid ProductId { get; set; } = default!;

    public int Quantity { get; set; } = default!;

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Exceptions/ApplicationException.cs">
namespace Basket.Application.Exceptions;

public sealed class ApplicationException : Exception
{
    #region Ctors

    public ApplicationException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Features/Basket/Commands/BasketCheckoutCommand.cs">
#region using

using Basket.Application.Dtos.Baskets;
using Basket.Application.Repositories;
using MediatR;
using BuildingBlocks.Validators;
using Basket.Domain.Events;
using Basket.Application.Services;

#endregion

namespace Basket.Application.Features.Basket.Commands;

public sealed record BasketCheckoutCommand(string UserId, BasketCheckoutDto Dto) : ICommand<Guid>;

public sealed class BasketCheckoutCommandValidator : AbstractValidator<BasketCheckoutCommand>
{
    #region Ctors

    public BasketCheckoutCommandValidator()
    {
        RuleFor(x => x.UserId)
            .NotEmpty()
            .WithMessage(MessageCode.UserIdIsRequired);

        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                // Customer validation
                RuleFor(x => x.Dto.Customer)
                    .NotNull()
                    .WithMessage(MessageCode.BadRequest)
                    .DependentRules(() =>
                    {
                        RuleFor(x => x.Dto.Customer.Name)
                            .NotEmpty()
                            .WithMessage(MessageCode.NameIsRequired)
                            .MaximumLength(255)
                            .WithMessage(MessageCode.Max255Characters);

                        RuleFor(x => x.Dto.Customer.Email)
                            .NotEmpty()
                            .WithMessage(MessageCode.EmailIsRequired)
                            .EmailAddress()
                            .WithMessage(MessageCode.InvalidEmailAddress)
                            .MaximumLength(255)
                            .WithMessage(MessageCode.Max255Characters);

                        RuleFor(x => x.Dto.Customer.PhoneNumber)
                            .NotEmpty()
                            .WithMessage(MessageCode.PhoneNumberIsRequired)
                            .IsValidPhoneNumber()
                            .WithMessage(MessageCode.InvalidPhoneNumber);
                    });

                // Shipping Address validation
                RuleFor(x => x.Dto.ShippingAddress)
                    .NotNull()
                    .WithMessage(MessageCode.BadRequest)
                    .DependentRules(() =>
                    {
                        RuleFor(x => x.Dto.ShippingAddress.AddressLine)
                            .NotEmpty()
                            .WithMessage(MessageCode.AddressLineIsRequired)
                            .MaximumLength(500)
                            .WithMessage(MessageCode.Max500Characters);

                        RuleFor(x => x.Dto.ShippingAddress.Subdivision)
                            .NotEmpty()
                            .WithMessage(MessageCode.SubdivisionIsRequired)
                            .MaximumLength(100)
                            .WithMessage(MessageCode.Max100Characters);

                        RuleFor(x => x.Dto.ShippingAddress.City)
                            .NotEmpty()
                            .WithMessage(MessageCode.CityIsRequired)
                            .MaximumLength(100)
                            .WithMessage(MessageCode.Max100Characters);

                        RuleFor(x => x.Dto.ShippingAddress.StateOrProvince)
                            .NotEmpty()
                            .WithMessage(MessageCode.StateOrProvinceIsRequired)
                            .MaximumLength(100)
                            .WithMessage(MessageCode.Max100Characters);

                        RuleFor(x => x.Dto.ShippingAddress.Country)
                            .NotEmpty()
                            .WithMessage(MessageCode.CountryIsRequired)
                            .MaximumLength(100)
                            .WithMessage(MessageCode.Max100Characters);

                        RuleFor(x => x.Dto.ShippingAddress.PostalCode)
                            .NotEmpty()
                            .WithMessage(MessageCode.PostalCodeIsRequired)
                            .MaximumLength(20)
                            .WithMessage(MessageCode.Max20Characters);
                    });

                // Coupon Code validation (optional)
                When(x => !string.IsNullOrWhiteSpace(x.Dto.CouponCode), () =>
                {
                    RuleFor(x => x.Dto.CouponCode)
                        .MaximumLength(50)
                        .WithMessage(MessageCode.Max50Characters);
                });
            });
    }

    #endregion
}

public sealed class BasketCheckoutCommandHandler(
    IBasketRepository basketRepo,
    IMediator mediator,
    IDiscountGrpcService discountGrpc,
    ICatalogGrpcService catalogGrpc)
    : ICommandHandler<BasketCheckoutCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(BasketCheckoutCommand command, CancellationToken cancellationToken)
    {
        var dto = command.Dto;
        decimal discountAmt = 0m;
        string couponCode = string.Empty;

        var basket = await basketRepo.GetBasketAsync(command.UserId, cancellationToken);

        if (basket.Items == null || basket.Items.Count == 0) throw new ClientValidationException(MessageCode.BasketIsRequired);

        if (!string.IsNullOrWhiteSpace(dto.CouponCode))
        {
            var productsResponse = await catalogGrpc.GetAllAvailableProductsAsync(cancellationToken: cancellationToken);

            if (productsResponse == null || productsResponse.Items == null || productsResponse.Items.Count == 0)
            {
                throw new ClientValidationException(MessageCode.ProductsIsNotExistsOrNotInStock);
            }

            decimal amount = 0m;

            foreach (var item in basket.Items)
            {
                var productInfo = productsResponse.Items.FirstOrDefault(x => x.Id == item.ProductId)
                    ?? throw new ClientValidationException(MessageCode.ProductIsNotExistsOrNotInStock, item.ProductId);

                amount += item.Quantity * productInfo.Price;
            }

            var discountResult = await discountGrpc.EvaluateCouponAsync(dto.CouponCode, amount)
                ?? throw new ClientValidationException(MessageCode.CouponCodeIsNotExistsOrExpired);

            discountAmt = discountResult.DiscountAmount;
            couponCode = discountResult.CouponCode;
        }

        var customerEvent = new CustomerDomainEvent(
            Guid.Parse(command.UserId),
            dto.Customer.Name,
            dto.Customer.Email,
            dto.Customer.PhoneNumber);
        var shippingAddressEvent = new AddressDomainEvent(
            dto.ShippingAddress.AddressLine,
            dto.ShippingAddress.Subdivision,
            dto.ShippingAddress.City,
            dto.ShippingAddress.StateOrProvince,
            dto.ShippingAddress.Country,
            dto.ShippingAddress.PostalCode);
        var discountEvent = new DiscountDomainEvent(couponCode, discountAmt);

        var @event = new BasketCheckoutDomainEvent(basket, customerEvent, shippingAddressEvent, discountEvent);

        await mediator.Publish(@event, cancellationToken);

        await basketRepo.DeleteBasketAsync(command.UserId, cancellationToken);

        return basket.Id;
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Features/Basket/Commands/DeleteBasketCommand.cs">
#region using

using MediatR;
using Basket.Application.Repositories;

#endregion

namespace Basket.Application.Features.Basket.Commands;

public record DeleteBasketCommand(string UserId) : ICommand<Unit>;

public class DeleteBasketCommandValidator : AbstractValidator<DeleteBasketCommand>
{
    #region Ctors

    public DeleteBasketCommandValidator()
    {
        RuleFor(x => x.UserId)
            .NotEmpty()
            .WithMessage(MessageCode.UserIdIsRequired);
    }

    #endregion
}

public class DeleteBasketCommandHandler(IBasketRepository repository) : ICommandHandler<DeleteBasketCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(DeleteBasketCommand command, CancellationToken cancellationToken)
    {
        await repository.DeleteBasketAsync(command.UserId, cancellationToken);

        return Unit.Value;
    }

    #endregion

}
</file>

<file path="Services/Basket/Core/Basket.Application/Features/Basket/Commands/StoreBasketCommand.cs">
#region using

using Basket.Application.Dtos.Baskets;
using Basket.Application.Repositories;
using Basket.Application.Services;

#endregion

namespace Basket.Application.Features.Basket.Commands;

public record StoreBasketCommand(string UserId, StoreShoppingCartDto Dto) : ICommand<Guid>;

public class StoreBasketCommandValidator : AbstractValidator<StoreBasketCommand>
{
    #region Ctors

    public StoreBasketCommandValidator()
    {
        RuleFor(x => x.UserId)
            .NotEmpty()
            .WithMessage(MessageCode.UserIdIsRequired);

        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Items)
                    .NotEmpty()
                    .WithMessage(MessageCode.BadRequest);

                RuleForEach(x => x.Dto.Items).ChildRules(items =>
                {
                    items.RuleFor(i => i.ProductId)
                        .NotEmpty()
                        .WithMessage(MessageCode.ProductIdIsRequired);
                    items.RuleFor(i => i.Quantity)
                        .GreaterThan(0)
                        .WithMessage(MessageCode.QuantityIsRequired);
                });
            });
    }

    #endregion
}

public class StoreBasketCommandHandler(IBasketRepository repository, ICatalogGrpcService catalogGrpc) : ICommandHandler<StoreBasketCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(StoreBasketCommand command, CancellationToken cancellationToken)
    {
        var dto = command.Dto;

        var basket = await repository.GetBasketAsync(command.UserId, cancellationToken);

        var products = await catalogGrpc.GetProductsAsync(
            ids: dto.Items.Select(x => x.ProductId.ToString()).ToArray(),
            cancellationToken: cancellationToken);

        basket.Clear();

        foreach (var item in dto.Items)
        {
            var product = products!.Items!.FirstOrDefault(x => x.Id == item.ProductId)
                ?? throw new ClientValidationException(MessageCode.ProductIsNotExists, item.ProductId);

            basket.AddOrIncreaseItem(
                    productId: product.Id,
                    productName: product.Name,
                    productImage: product.Thumbnail,
                    price: product.Price,
                    quantity: item.Quantity);
        }

        await repository.StoreBasketAsync(command.UserId, basket, cancellationToken);

        return basket.Id;
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Features/Basket/EventHandlers/Domain/BasketCheckoutDomainEventHandler.cs">
#region using

using Basket.Application.Repositories;
using Basket.Domain.Entities;
using Basket.Domain.Events;
using EventSourcing.Events.Baskets;
using MediatR;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;

#endregion

namespace Basket.Application.Features.Basket.EventHandlers.Domain;

public sealed class BasketCheckoutDomainEventHandler(
    IOutboxRepository outboxRepo,
    ILogger<BasketCheckoutDomainEventHandler> logger) : INotificationHandler<BasketCheckoutDomainEvent>
{
    #region Implementations

    public async Task Handle(BasketCheckoutDomainEvent @event, CancellationToken cancellationToken)
    {
        logger.LogInformation("Domain Event handled: {DomainEvent}", @event.GetType().Name);

        await PushToOutboxAsync(@event, cancellationToken);
    }

    #endregion

    #region Methods

    private async Task PushToOutboxAsync(BasketCheckoutDomainEvent @event, CancellationToken cancellationToken)
    {
        var message = new BasketCheckoutIntegrationEvent
        {
            Id = Guid.NewGuid().ToString(),
            BasketId = @event.Basket.Id,
            Customer = new CustomerIntegrationEvent
            {
                Id = @event.Customer.Id,
                Name = @event.Customer.Name,
                Email = @event.Customer.Email,
                PhoneNumber = @event.Customer.PhoneNumber
            },
            ShippingAddress = new AddressIntegrationEvent
            {
                AddressLine = @event.ShippingAddress.AddressLine,
                Subdivision = @event.ShippingAddress.Subdivision,
                City = @event.ShippingAddress.City,
                StateOrProvince = @event.ShippingAddress.StateOrProvince,
                Country = @event.ShippingAddress.Country,
                PostalCode = @event.ShippingAddress.PostalCode
            },
            Discount = new DiscountIntegrationEvent
            {
                CouponCode = @event.Discount.CouponCode,
                DiscountAmount = @event.Discount.DiscountAmount
            },
            Items = @event.Basket.Items?.Select(item => new CartItemIntegrationEvent
            {
                ProductId = item.ProductId,
                Quantity = item.Quantity
            }).ToList() ?? new List<CartItemIntegrationEvent>()
        };

        var outboxMessage = OutboxMessageEntity.Create(
            id: Guid.NewGuid(),
            eventType: message.EventType!,
            content: JsonConvert.SerializeObject(message),
            occurredOnUtc: DateTimeOffset.UtcNow);

        var result = await outboxRepo.AddMessageAsync(outboxMessage, cancellationToken);

        if (!result)
        {
            logger.LogWarning("Failed to add message to outbox. BasketId: {BasketId}", @event.Basket.Id);
            throw new InvalidOperationException("Failed to add message to outbox");
        }

        logger.LogInformation(
            "Successfully added basket checkout event to outbox. BasketId: {BasketId}, MessageId: {MessageId}",
            @event.Basket.Id,
            outboxMessage.Id);
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Features/Basket/Queries/GetBasketQuery.cs">
#region using

using AutoMapper;
using Basket.Application.Dtos.Baskets;
using Basket.Application.Models.Results;
using Basket.Application.Repositories;

#endregion

namespace Basket.Application.Features.Basket.Queries;

public sealed record GetBasketQuery(string UserId) : IQuery<GetBasketResult>;

public sealed class GetBasketQueryHandler(IBasketRepository repository, IMapper mapper) : IQueryHandler<GetBasketQuery, GetBasketResult>
{
    #region Implementations

    public async Task<GetBasketResult> Handle(GetBasketQuery query, CancellationToken cancellationToken)
    {
        var basket = await repository.GetBasketAsync(query.UserId, cancellationToken);

        var result = mapper.Map<ShoppingCartDto>(basket);
        var response = new GetBasketResult(result);

        return response;
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Mappings/BasketMappingProfile.cs">
#region using

using AutoMapper;
using Basket.Application.Dtos.Baskets;
using Basket.Domain.Entities;

#endregion

namespace Basket.Application.Mappings;

public sealed class BasketMappingProfile : Profile
{
    #region Ctors

    public BasketMappingProfile()
    {
        CreateShoppingCartMappings();
        CreateShoppingCartItemMappings();
    }

    #endregion

    #region Methods

    private void CreateShoppingCartMappings()
    {
        // ShoppingCartEntity -> ShoppingCartDto
        CreateMap<ShoppingCartEntity, ShoppingCartDto>()
            .ForMember(dest => dest.TotalPrice, opt => opt.MapFrom(src => src.TotalPrice));
    }

    private void CreateShoppingCartItemMappings()
    {
        // ShoppingCartItemEntity -> ShoppingCartItemDto
        CreateMap<ShoppingCartItemEntity, ShoppingCartItemDto>()
            .ForMember(dest => dest.ProductSlug, opt => opt.Ignore()); // ProductSlug might not exist in entity
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Models/Filters/GetAllCategoriesFilter.cs">
namespace Basket.Application.Models.Filters;

public record class GetAllCategoriesFilter(Guid? ParentId);
</file>

<file path="Services/Basket/Core/Basket.Application/Models/Filters/GetAllProductsFilter.cs">
namespace Basket.Application.Models.Filters;

public record class GetAllProductsFilter(string? SearchText, Guid[]? Ids);
</file>

<file path="Services/Basket/Core/Basket.Application/Models/Filters/GetProductsFilter.cs">
namespace Basket.Application.Models.Filters;

public record class GetProductsFilter(string? SearchText, Guid[]? Ids);
</file>

<file path="Services/Basket/Core/Basket.Application/Models/Filters/GetPublishProductsFilter.cs">
namespace Basket.Application.Models.Filters;

public record class GetPublishProductsFilter(string? SearchText);
</file>

<file path="Services/Basket/Core/Basket.Application/Models/Responses/Externals/EvaluateCouponResponse.cs">
namespace Basket.Application.Models.Responses.Externals;

public class EvaluateCouponResponse
{
    #region Fields, Properties and Indexers

    public decimal OriginalAmount { get; init; }

    public decimal DiscountAmount { get; init; }

    public decimal FinalAmount { get; init; }

    public string CouponCode { get; init; } = string.Empty;

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Models/Responses/Externals/GetAllProductsResponse.cs">
namespace Basket.Application.Models.Responses.Externals;

public class GetAllProductsResponse
{
    #region Fields, Properties and Indexers

    public List<ProductReponse>? Items { get; set; }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Models/Responses/Externals/ProductReponse.cs">
namespace Basket.Application.Models.Responses.Externals;

public class ProductReponse
{
    #region Fields, Properties and Indexers

    public Guid Id { get; init; } = default!;

    public string Name { get; init; } = default!;

    public decimal Price { get; init; }

    public string Thumbnail { get; init; } = default!;

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Models/Results/GetBasketResult.cs">
#region using

using Basket.Application.Dtos.Baskets;

#endregion

namespace Basket.Application.Models.Results;

public sealed class GetBasketResult
{
    #region Fields, Properties and Indexers

    public ShoppingCartDto Basket { get; init; }

    #endregion

    #region Ctors

    public GetBasketResult(ShoppingCartDto basket)
    {
        Basket = basket;
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Repositories/IBasketRepository.cs">
#region using

using Basket.Domain.Entities;

#endregion

namespace Basket.Application.Repositories;

public interface IBasketRepository
{
    #region Methods

    Task<ShoppingCartEntity> GetBasketAsync(string userId, CancellationToken cancellationToken = default);

    Task<bool> StoreBasketAsync(string userId, ShoppingCartEntity cart, CancellationToken cancellationToken = default);

    Task<bool> DeleteBasketAsync(string userId, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Repositories/IOutboxRepository.cs">
#region using

using Basket.Domain.Entities;

#endregion

namespace Basket.Application.Repositories;

public interface IOutboxRepository
{
    #region Methods

    Task<bool> AddMessageAsync(OutboxMessageEntity message, CancellationToken cancellationToken = default);

    Task<bool> UpdateMessagesAsync(IEnumerable<OutboxMessageEntity> messages, CancellationToken cancellationToken = default);

    Task<List<OutboxMessageEntity>> GetAndClaimMessagesAsync(int batchSize, CancellationToken cancellationToken = default);

    Task<List<OutboxMessageEntity>> GetAndClaimRetryMessagesAsync(int batchSize, CancellationToken cancellationToken = default);

    Task<bool> ReleaseClaimsAsync(IEnumerable<OutboxMessageEntity> messages, CancellationToken cancellationToken = default);

    Task<bool> ReleaseExpiredClaimsAsync(TimeSpan claimTimeout, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Services/ICatalogGrpcService.cs">
#region using

using Basket.Application.Models.Responses.Externals;

#endregion

namespace Basket.Application.Services;

public interface ICatalogGrpcService
{
    #region Methods

    Task<ProductReponse?> GetProductByIdAsync(string productId, CancellationToken cancellationToken = default);

    Task<GetAllProductsResponse?> GetProductsAsync(string[]? ids = null, string searchText = "", CancellationToken cancellationToken = default);

    Task<GetAllProductsResponse?> GetAllAvailableProductsAsync(string[]? ids = null, string searchText = "", CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/Services/IDiscountGrpcService.cs">
#region using

using Basket.Application.Models.Responses.Externals;

#endregion

namespace Basket.Application.Services;

public interface IDiscountGrpcService
{
    #region Methods

    Task<EvaluateCouponResponse?> EvaluateCouponAsync(string code, decimal amount, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/ApplicationMarker.cs">
namespace Basket.Application;

public sealed class ApplicationMarker { }
</file>

<file path="Services/Basket/Core/Basket.Application/Basket.Application.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="AutoMapper" />
    <PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" />
    <PackageReference Include="Scrutor" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\Basket.Domain\Basket.Domain.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Basket/Core/Basket.Application/DependencyInjection.cs">
#region using

using BuildingBlocks.Behaviors;
using BuildingBlocks.Exceptions.Handler;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.FeatureManagement;
using System.Reflection;

#endregion

namespace Basket.Application;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddApplicationServices(this IServiceCollection services)
    {
        services.AddExceptionHandler<CustomExceptionHandler>();
        services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
        services.AddMediatR(config =>
        {
            config.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
            config.AddOpenBehavior(typeof(ValidationBehavior<,>));
            config.AddOpenBehavior(typeof(LoggingBehavior<,>));
        });
        services.AddFeatureManagement();

        // Register all AutoMapper profiles from the current assembly
        services.AddAutoMapper(Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Application/GlobalUsing.cs">
global using BuildingBlocks.CQRS;
global using FluentValidation;
global using Common.Constants;
global using BuildingBlocks.Exceptions;
</file>

<file path="Services/Basket/Core/Basket.Domain/Abstractions/Aggregate.cs">
namespace Basket.Domain.Abstractions;

public abstract class Aggregate<TId> : Entity<TId>, IAggregate<TId>
{
    #region Fields, Properties and Indexers

    private readonly List<IDomainEvent> _domainEvents = new();

    #endregion

    #region Implementations

    public IReadOnlyList<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    public void AddDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }

    public IDomainEvent[] ClearDomainEvents()
    {
        IDomainEvent[] dequeuedEvents = _domainEvents.ToArray();

        _domainEvents.Clear();

        return dequeuedEvents;
    }

    #endregion

}
</file>

<file path="Services/Basket/Core/Basket.Domain/Abstractions/Entity.cs">
#region using

using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;

#endregion

namespace Basket.Domain.Abstractions;

public abstract class Entity<T> : IEntityId<T>, IAuditable
{
    #region Fields, Properties and Indexers

    [BsonId]
    [BsonRepresentation(BsonType.String)]
    public T Id { get; set; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Basket/Core/Basket.Domain/Abstractions/EntityId.cs">
#region using

using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;

#endregion

namespace Basket.Domain.Abstractions;

public abstract class EntityId<T> : IEntityId<T>
{
    #region Fields, Properties and Indexers

    [BsonId]
    [BsonRepresentation(BsonType.String)]
    public T Id { get; set; } = default!;

    #endregion

}
</file>

<file path="Services/Basket/Core/Basket.Domain/Abstractions/IAggregate.cs">
namespace Basket.Domain.Abstractions;

public interface IAggregate<T> : IAggregate, IEntityId<T>
{
}

public interface IAggregate : ICreationAuditable, IModificationAuditable
{
    #region Fields, Properties and Indexers

    IReadOnlyList<IDomainEvent> DomainEvents { get; }

    IDomainEvent[] ClearDomainEvents();

    #endregion

}
</file>

<file path="Services/Basket/Core/Basket.Domain/Abstractions/IAuditable.cs">
namespace Basket.Domain.Abstractions;

public interface IAuditable : ICreationAuditable, IModificationAuditable { }
</file>

<file path="Services/Basket/Core/Basket.Domain/Abstractions/ICreationAuditable.cs">
namespace Basket.Domain.Abstractions;

public interface ICreationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Basket/Core/Basket.Domain/Abstractions/IDomainEvent.cs">
#region using

using MediatR;

#endregion

namespace Basket.Domain.Abstractions;

public interface IDomainEvent : INotification
{
    #region Fields, Properties and Indexers

    Guid EventId => Guid.NewGuid();

    public DateTimeOffset OccurredOn => DateTime.Now;

    public string EventType => GetType()?.AssemblyQualifiedName ?? string.Empty;

    #endregion

}
</file>

<file path="Services/Basket/Core/Basket.Domain/Abstractions/IEntityId.cs">
namespace Basket.Domain.Abstractions;

public interface IEntityId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; set; }

    #endregion

}
</file>

<file path="Services/Basket/Core/Basket.Domain/Abstractions/IModificationAuditable.cs">
namespace Basket.Domain.Abstractions;

public interface IModificationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Basket/Core/Basket.Domain/Attributes/BsonCollectionAttribute.cs">
namespace Basket.Domain.Attributes;

[AttributeUsage(AttributeTargets.Class, Inherited = false)]
public class BsonCollectionAttribute : Attribute
{
    #region Fields, Properties and Indexers

    public string CollectionName { get; }

    #endregion

    #region Ctors

    public BsonCollectionAttribute(string collectionName)
    {
        CollectionName = collectionName;
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Domain/Entities/OutboxMessageEntity.cs">
#region using

using Basket.Domain.Abstractions;

#endregion

namespace Basket.Domain.Entities;

public sealed class OutboxMessageEntity : EntityId<Guid>
{
    #region Fields, Properties and Indexers

    public string? EventType { get; set; }

    public string? Content { get; set; }

    public DateTimeOffset OccurredOnUtc { get; set; }

    public DateTimeOffset? ProcessedOnUtc { get; set; }

    public string? LastErrorMessage { get; set; }

    public DateTimeOffset? ClaimedOnUtc { get; set; }

    public int AttemptCount { get; set; }

    public int MaxAttempts { get; set; }

    public DateTimeOffset? NextAttemptOnUtc { get; set; }

    #endregion

    #region Factories

    public static OutboxMessageEntity Create(Guid id, string eventType, string content, DateTimeOffset occurredOnUtc)
    {
        return new OutboxMessageEntity()
        {
            Id = id,
            EventType = eventType,
            Content = content,
            OccurredOnUtc = occurredOnUtc,
            MaxAttempts = AppConstants.MaxAttempts,
            AttemptCount = 0
        };
    }

    #endregion

    #region Methods

    public void CompleteProcessing(DateTimeOffset processedOnUtc, string? lastErrorMessage = null)
    {
        ProcessedOnUtc = processedOnUtc;
        LastErrorMessage = lastErrorMessage;
        ClaimedOnUtc = null;
        NextAttemptOnUtc = null;
    }

    public void Claim(DateTimeOffset claimedOnUtc)
    {
        ClaimedOnUtc = claimedOnUtc;
    }

    public void SetRetryProperties(int attemptCount, int maxAttempts, DateTimeOffset? nextAttemptOnUtc, string? lastErrorMessage)
    {
        AttemptCount = attemptCount;
        MaxAttempts = maxAttempts;
        NextAttemptOnUtc = nextAttemptOnUtc;
        LastErrorMessage = lastErrorMessage;
    }

    public void RecordFailedAttempt(string errorMessage, DateTimeOffset currentTime)
    {
        IncreaseAttemptCount();

        if (AttemptCount >= MaxAttempts)
        {
            LastErrorMessage = $"Max attempts ({MaxAttempts}) exceeded. Last error: {errorMessage}";
            NextAttemptOnUtc = null;
        }
        else
        {
            // Calculate exponential backoff with jitter
            var baseDelay = TimeSpan.FromSeconds(Math.Pow(2, AttemptCount - 1));
            var maxDelay = TimeSpan.FromMinutes(5);
            var jitter = TimeSpan.FromMilliseconds(Random.Shared.Next(0, 1000));
            var delay = TimeSpan.FromTicks(Math.Min(baseDelay.Ticks, maxDelay.Ticks)) + jitter;

            NextAttemptOnUtc = currentTime + delay;
            LastErrorMessage = errorMessage;
        }
    }

    public void IncreaseAttemptCount()
    {
        AttemptCount++;
    }

    public bool CanRetry(DateTimeOffset currentTime)
    {
        return AttemptCount < MaxAttempts &&
               (NextAttemptOnUtc == null || currentTime >= NextAttemptOnUtc.Value);
    }

    public bool IsPermanentlyFailed()
    {
        return AttemptCount >= MaxAttempts;
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Domain/Entities/ShoppingCartEntity.cs">
#region using

using Basket.Domain.Abstractions;
using Basket.Domain.Attributes;

#endregion

namespace Basket.Domain.Entities;

[BsonCollection("Shopping_Carts")]
public sealed class ShoppingCartEntity : Aggregate<Guid>
{
    #region Fields, Properties and Indexers

    public string UserId { get; set; } = default!;

    public List<ShoppingCartItemEntity> Items { get; set; } = new();

    public decimal TotalPrice => Items.Sum(x => x.LineTotal);

    #endregion

    #region Factories

    public static ShoppingCartEntity Create(string userId)
    {
        return new ShoppingCartEntity()
        {
            Id = Guid.NewGuid(),
            UserId = userId
        };
    }

    #endregion

    #region Operations

    public ShoppingCartItemEntity AddOrIncreaseItem(
        Guid productId,
        string productName,
        string productImage,
        decimal price,
        int quantity = 1)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(quantity);
        ArgumentOutOfRangeException.ThrowIfNegative(price);

        var existing = Find(productId);
        if (existing is not null)
        {
            existing.Increase(quantity);
            existing.UpdatePrice(price);
            existing.UpdateMeta(productName, productImage);
            return existing;
        }

        var item = ShoppingCartItemEntity.Create(productId, productName, productImage, price, quantity);
        Items.Add(item);
        return item;
    }

    public void UpdateQuantity(Guid productId, int quantity)
    {
        var existing = Find(productId);
        if (existing is null) return;

        if (quantity <= 0)
        {
            Items.Remove(existing);
            return;
        }

        existing.SetQuantity(quantity);
    }

    public void UpdatePrice(Guid productId, decimal price)
    {
        var existing = Find(productId);
        if (existing is null) return;
        existing.UpdatePrice(price);
    }

    public void RemoveItem(Guid productId)
    {
        var existing = Find(productId);
        if (existing is null) return;
        Items.Remove(existing);
    }

    public void Clear() => Items.Clear();

    #endregion

    #region Helpers

    private ShoppingCartItemEntity? Find(Guid productId) =>
        Items.FirstOrDefault(x => x.ProductId == productId);

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Domain/Entities/ShoppingCartItemEntity.cs">
#region using

using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;

#endregion

namespace Basket.Domain.Entities;

public sealed class ShoppingCartItemEntity
{
    #region Fields, Properties and Indexers

    [BsonRepresentation(BsonType.String)]
    public Guid ProductId { get; set; } = default!;

    public string ProductName { get; set; } = default!;

    public string ProductImage { get; set; } = default!;

    public decimal Price { get; set; }

    public int Quantity { get; set; }

    public decimal LineTotal => Price * Quantity;

    #endregion

    #region Factories

    public static ShoppingCartItemEntity Create(
        Guid productId,
        string productName,
        string productImage,
        decimal price,
        int quantity)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(quantity);
        ArgumentOutOfRangeException.ThrowIfNegative(price);
        ArgumentException.ThrowIfNullOrWhiteSpace(productName);

        return new ShoppingCartItemEntity
        {
            ProductId = productId,
            ProductName = productName,
            ProductImage = productImage,
            Price = price,
            Quantity = quantity
        };
    }

    #endregion

    #region Methods

    public void Increase(int quantity)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(quantity);
        Quantity += quantity;
    }

    public void SetQuantity(int quantity)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(quantity);
        Quantity = quantity;
    }

    public void UpdatePrice(decimal price)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(price);
        Price = price;
    }

    public void UpdateMeta(string name, string image)
    {
        if (!string.IsNullOrWhiteSpace(name)) ProductName = name;
        if (!string.IsNullOrWhiteSpace(image)) ProductImage = image;
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Domain/Enums/ProductStatus.cs">
#region using

using System.ComponentModel;

#endregion

namespace Basket.Domain.Enums;

public enum ProductStatus
{
    [Description("In Stock")]
    InStock = 1,

    [Description("Out of Stock")]
    OutOfStock = 2
}
</file>

<file path="Services/Basket/Core/Basket.Domain/Events/BasketCheckoutDomainEvent.cs">
#region using

using Basket.Domain.Entities;
using MediatR;

#endregion

namespace Basket.Domain.Events;

public record BasketCheckoutDomainEvent(
    ShoppingCartEntity Basket,
    CustomerDomainEvent Customer,
    AddressDomainEvent ShippingAddress,
    DiscountDomainEvent Discount) : INotification;

public sealed record CustomerDomainEvent(
    Guid? Id,
    string Name,
    string Email,
    string PhoneNumber);

public sealed record AddressDomainEvent(
    string AddressLine,
    string Subdivision,
    string City,
    string StateOrProvince,
    string Country,
    string PostalCode);

public sealed record DiscountDomainEvent(string CouponCode, decimal DiscountAmount);
</file>

<file path="Services/Basket/Core/Basket.Domain/Exceptions/DomainException.cs">
namespace Basket.Domain.Exceptions;

public sealed class DomainException : Exception
{
    public DomainException(string message) : base(message)
    {
    }
}
</file>

<file path="Services/Basket/Core/Basket.Domain/ValueObjects/Money.cs">
#region using

using Basket.Domain.Exceptions;

#endregion

namespace Basket.Domain.ValueObjects;

public sealed record Money(decimal Amount, string Currency)
{
    public static Money From(decimal amount, string currency)
    {
        if (amount < 0) throw new DomainException(MessageCode.MoneyCannotBeNegative);
        if (string.IsNullOrWhiteSpace(currency)) throw new DomainException(MessageCode.CurrencyIsRequired);
        return new Money(amount, currency.ToUpperInvariant());
    }
}
</file>

<file path="Services/Basket/Core/Basket.Domain/Basket.Domain.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="MediatR" />
    <PackageReference Include="MongoDB.Bson" />
    <PackageReference Include="Newtonsoft.Json" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Basket/Core/Basket.Domain/GlobalUsing.cs">
global using Common.Constants;
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/Constants/MongoCollection.cs">
namespace Basket.Infrastructure.Constants;

public sealed class MongoCollection
{
    #region Constants

    public const string ShoppingCart = "shopping_cart";

    public const string OutboxMessage = "outbox_message";

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/Data/Extensions/DatabaseExtentions.cs">
#region using

using Basket.Domain.Entities;
using Basket.Infrastructure.Constants;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using MongoDB.Driver;

#endregion

namespace Basket.Infrastructure.Data.Extensions;

public static class DatabaseExtentions
{
    #region Methods

    public static async Task EnsureIndexesAsync(this WebApplication app)
    {
        var db = app.Services.GetRequiredService<IMongoDatabase>();
        var sc = db.GetCollection<ShoppingCartEntity>(MongoCollection.ShoppingCart);
        var om = db.GetCollection<OutboxMessageEntity>(MongoCollection.OutboxMessage);

        await sc.Indexes.CreateOneAsync(new CreateIndexModel<ShoppingCartEntity>(
            Builders<ShoppingCartEntity>.IndexKeys
                .Ascending(x => x.UserId),
            new CreateIndexOptions { Unique = true }));

        // Index for processing order (oldest first)
        await om.Indexes.CreateOneAsync(new CreateIndexModel<OutboxMessageEntity>(
            Builders<OutboxMessageEntity>.IndexKeys
                .Ascending(x => x.OccurredOnUtc),
            new CreateIndexOptions { Unique = false }));

        // Index for event type filtering
        await om.Indexes.CreateOneAsync(new CreateIndexModel<OutboxMessageEntity>(
            Builders<OutboxMessageEntity>.IndexKeys
                .Ascending(x => x.EventType),
            new CreateIndexOptions { Unique = false }));

        // Index for processed status
        await om.Indexes.CreateOneAsync(new CreateIndexModel<OutboxMessageEntity>(
            Builders<OutboxMessageEntity>.IndexKeys
                .Ascending(x => x.ProcessedOnUtc),
            new CreateIndexOptions { Unique = false }));

        // Index for claim status
        await om.Indexes.CreateOneAsync(new CreateIndexModel<OutboxMessageEntity>(
            Builders<OutboxMessageEntity>.IndexKeys
                .Ascending(x => x.ClaimedOnUtc),
            new CreateIndexOptions { Unique = false }));

        // Compound index for unprocessed and unclaimed messages
        await om.Indexes.CreateOneAsync(new CreateIndexModel<OutboxMessageEntity>(
            Builders<OutboxMessageEntity>.IndexKeys
                .Ascending(x => x.ProcessedOnUtc)
                .Ascending(x => x.ClaimedOnUtc),
            new CreateIndexOptions { Unique = false }));

        // Compound index for retry messages (next attempt time, processed status, attempt count)
        await om.Indexes.CreateOneAsync(new CreateIndexModel<OutboxMessageEntity>(
            Builders<OutboxMessageEntity>.IndexKeys
                .Ascending(x => x.NextAttemptOnUtc)
                .Ascending(x => x.ProcessedOnUtc)
                .Ascending(x => x.AttemptCount),
            new CreateIndexOptions { Unique = false }));

        // Compound index for retry eligibility (processed status, attempt count, max attempts)
        await om.Indexes.CreateOneAsync(new CreateIndexModel<OutboxMessageEntity>(
            Builders<OutboxMessageEntity>.IndexKeys
                .Ascending(x => x.ProcessedOnUtc)
                .Ascending(x => x.AttemptCount)
                .Ascending(x => x.MaxAttempts),
            new CreateIndexOptions { Unique = false }));
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/Exceptions/InfrastructureException.cs">
namespace Basket.Infrastructure.Exceptions;

public sealed class InfrastructureException : Exception
{
    #region Ctors

    public InfrastructureException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/GrpcClients/Extensions/GrpcClientExtension.cs">
#region using

using Basket.Infrastructure.GrpcClients.Interceptors;
using Catalog.Grpc;
using Discount.Grpc;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

#endregion

namespace Basket.Infrastructure.GrpcClients.Extensions;

public static class GrpcClientExtension
{
    #region Methods

    public static IServiceCollection AddGrpcClients(this IServiceCollection services, IConfiguration cfg)
    {
        // Catalog Grpc
        var catalogServiceUrl = cfg.GetValue<string>($"{GrpcClientCfg.Catalog.Section}:{GrpcClientCfg.Catalog.Url}")
            ?? throw new InvalidOperationException("Catalog service URL is not configured.");

        services.AddGrpcClient<CatalogGrpc.CatalogGrpcClient>(options =>
        {
            options.Address = new Uri(catalogServiceUrl);
        })
        .AddInterceptor<GrpcApiKeyInterceptor>()
        .ConfigurePrimaryHttpMessageHandler(() =>
        {
            return new HttpClientHandler
            {
                ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
            };
        });

        // Discount Grpc
        var discountServiceUrl = cfg.GetValue<string>($"{GrpcClientCfg.Discount.Section}:{GrpcClientCfg.Discount.Url}")
            ?? throw new InvalidOperationException("Discount service URL is not configured.");

        services.AddGrpcClient<DiscountGrpc.DiscountGrpcClient>(options =>
        {
            options.Address = new Uri(discountServiceUrl);
        })
        .AddInterceptor<GrpcApiKeyInterceptor>()
        .ConfigurePrimaryHttpMessageHandler(() =>
        {
            return new HttpClientHandler
            {
                ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
            };
        });

        services.AddSingleton<GrpcApiKeyInterceptor>();

        return services;
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/GrpcClients/Interceptors/GrpcApiKeyInterceptor.cs">
#region using

using Grpc.Core;
using Grpc.Core.Interceptors;
using Microsoft.Extensions.Configuration;

#endregion

namespace Basket.Infrastructure.GrpcClients.Interceptors;

public sealed class GrpcApiKeyInterceptor(IConfiguration cfg) : Interceptor
{
    #region Methods

    public override AsyncUnaryCall<TResponse> AsyncUnaryCall<TRequest, TResponse>(
        TRequest request,
        ClientInterceptorContext<TRequest, TResponse> context,
        AsyncUnaryCallContinuation<TRequest, TResponse> continuation)
    {
        var grpcKey = cfg.GetValue<string>($"{GrpcClientCfg.Catalog.Section}:{GrpcClientCfg.Catalog.ApiKey}")
            ?? throw new InvalidOperationException("gRPC Key is not configured.");
        var headers = context.Options.Headers ?? [];
        if (!headers.Any(h => h.Key.Equals(ReqHeaderName.GrpcKey, StringComparison.OrdinalIgnoreCase)))
        {
            headers.Add(ReqHeaderName.GrpcKey, grpcKey);
        }

        var newOptions = context.Options.WithHeaders(headers);
        var newContext = new ClientInterceptorContext<TRequest, TResponse>(
            context.Method,
            context.Host,
            newOptions);

        return base.AsyncUnaryCall(request, newContext, continuation);
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/Repositories/BaseRepository.cs">
#region using

using Basket.Domain.Attributes;
using MongoDB.Driver;
using System.Reflection;

#endregion

namespace Basket.Infrastructure.Repositories;

public class BaseRepository<T>
{
    #region Fields, Properties and Indexers

    protected readonly IMongoCollection<T> _collection;

    #endregion

    #region Ctors

    public BaseRepository(IMongoDatabase db)
    {
        var attribute = typeof(T).GetCustomAttribute<BsonCollectionAttribute>();
        _collection = db.GetCollection<T>(attribute?.CollectionName ?? typeof(T).Name.ToLowerInvariant());
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/Repositories/BasketRepository.cs">
#region using

using Basket.Application.Repositories;
using Basket.Domain.Entities;
using MongoDB.Driver;

#endregion

namespace Basket.Infrastructure.Repositories;

public sealed class BasketRepository : BaseRepository<ShoppingCartEntity>, IBasketRepository
{
    #region Ctors

    public BasketRepository(IMongoDatabase db) : base(db)
    {
    }

    #endregion

    #region Implementations

    public async Task<bool> DeleteBasketAsync(string userId, CancellationToken cancellationToken = default)
    {
        var result = await _collection.DeleteOneAsync(x => x.UserId == userId, cancellationToken);
        return result.IsAcknowledged;
    }

    public async Task<ShoppingCartEntity> GetBasketAsync(string userId, CancellationToken cancellationToken = default)
    {
        var basket = await _collection
            .Find(x => x.UserId == userId)
            .FirstOrDefaultAsync(cancellationToken);

        return basket ?? ShoppingCartEntity.Create(userId);
    }

    public async Task<bool> StoreBasketAsync(string userId, ShoppingCartEntity cart, CancellationToken cancellationToken = default)
    {
        var result = await _collection.ReplaceOneAsync(
            x => x.UserId == userId,
            cart,
            new ReplaceOptions { IsUpsert = true },
            cancellationToken);

        return result.IsAcknowledged;
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/Repositories/CachedBasketRepository.cs">
#region using

using Basket.Application.Repositories;
using Basket.Domain.Entities;
using Microsoft.Extensions.Caching.Distributed;
using Newtonsoft.Json;

#endregion

namespace Basket.Infrastructure.Repositories;

public sealed class CachedBasketRepository(IBasketRepository repository, IDistributedCache cache) : IBasketRepository
{
    #region Fields, Properties and Indexers

    private static readonly DistributedCacheEntryOptions _cacheOptions = new()
    {
        AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(1),
        SlidingExpiration = TimeSpan.FromHours(1)
    };

    #endregion

    #region Implementations

    public async Task<bool> DeleteBasketAsync(string userId, CancellationToken cancellationToken = default)
    {
        await repository.DeleteBasketAsync(userId, cancellationToken);
        await cache.RemoveAsync(userId, cancellationToken);

        return true;
    }

    public async Task<ShoppingCartEntity> GetBasketAsync(string userId, CancellationToken cancellationToken = default)
    {
        var cachedBasket = await cache.GetStringAsync(userId, cancellationToken);
        if (!string.IsNullOrEmpty(cachedBasket))
        {
            var result = JsonConvert.DeserializeObject<ShoppingCartEntity>(cachedBasket);
            return result!;
        }

        var basket = await repository.GetBasketAsync(userId, cancellationToken);
        await cache.SetStringAsync(userId, JsonConvert.SerializeObject(basket), _cacheOptions, cancellationToken);

        return basket;
    }

    public async Task<bool> StoreBasketAsync(string userId, ShoppingCartEntity cart, CancellationToken cancellationToken = default)
    {
        await repository.StoreBasketAsync(userId, cart, cancellationToken);
        await cache.SetStringAsync(userId, JsonConvert.SerializeObject(cart), _cacheOptions, cancellationToken);

        return true;
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/Repositories/OutboxRepository.cs">
#region using

using Basket.Application.Repositories;
using Basket.Domain.Entities;
using Basket.Infrastructure.Constants;
using MongoDB.Driver;

#endregion

namespace Basket.Infrastructure.Repositories;

public class OutboxRepository : IOutboxRepository
{
    #region Fields, Properties and Indexers

    private readonly IMongoCollection<OutboxMessageEntity> _collection;

    #endregion

    #region Ctors

    public OutboxRepository(IMongoDatabase db)
    {
        _collection = db.GetCollection<OutboxMessageEntity>(MongoCollection.OutboxMessage);
    }

    #endregion

    #region Implementations

    public async Task<bool> AddMessageAsync(OutboxMessageEntity message, CancellationToken cancellationToken = default)
    {
        var result = await _collection.ReplaceOneAsync(
            x => x.Id == message.Id,
            message,
            new ReplaceOptions { IsUpsert = true },
            cancellationToken);

        return result.IsAcknowledged;
    }

    public async Task<bool> UpdateMessagesAsync(IEnumerable<OutboxMessageEntity> messages, CancellationToken cancellationToken = default)
    {
        var bulkOperations = new List<WriteModel<OutboxMessageEntity>>();

        foreach (var message in messages)
        {
            var filter = Builders<OutboxMessageEntity>.Filter.Eq(x => x.Id, message.Id);
            var update = Builders<OutboxMessageEntity>.Update
                .Set(x => x.ProcessedOnUtc, message.ProcessedOnUtc)
                .Set(x => x.LastErrorMessage, message.LastErrorMessage)
                .Set(x => x.AttemptCount, message.AttemptCount)
                .Set(x => x.MaxAttempts, message.MaxAttempts)
                .Set(x => x.NextAttemptOnUtc, message.NextAttemptOnUtc)
                .Unset(x => x.ClaimedOnUtc);

            bulkOperations.Add(new UpdateOneModel<OutboxMessageEntity>(filter, update));
        }

        if (bulkOperations.Count == 0)
            return true;

        var result = await _collection.BulkWriteAsync(bulkOperations, cancellationToken: cancellationToken);

        return result.IsAcknowledged;
    }

    public async Task<List<OutboxMessageEntity>> GetAndClaimMessagesAsync(int batchSize, CancellationToken cancellationToken = default)
    {
        var now = DateTimeOffset.UtcNow;
        var claimTimeout = TimeSpan.FromMinutes(5);

        // First, release any expired claims
        await ReleaseExpiredClaimsAsync(claimTimeout, cancellationToken);

        var claimedMessages = new List<OutboxMessageEntity>();

        // Use atomic findOneAndUpdate in a loop to avoid race conditions
        // This ensures each message is claimed atomically, preventing duplicates
        for (int i = 0; i < batchSize; i++)
        {
            var filter = Builders<OutboxMessageEntity>.Filter.And(
                Builders<OutboxMessageEntity>.Filter.Eq(x => x.ProcessedOnUtc, null),
                Builders<OutboxMessageEntity>.Filter.Or(
                    Builders<OutboxMessageEntity>.Filter.Exists(x => x.ClaimedOnUtc, false),
                    Builders<OutboxMessageEntity>.Filter.Eq(x => x.ClaimedOnUtc, null)
                )
            );

            var update = Builders<OutboxMessageEntity>.Update
                .Set(x => x.ClaimedOnUtc, now);

            var options = new FindOneAndUpdateOptions<OutboxMessageEntity>
            {
                ReturnDocument = ReturnDocument.After,
                Sort = Builders<OutboxMessageEntity>.Sort.Ascending(x => x.OccurredOnUtc)
            };

            var claimedMessage = await _collection.FindOneAndUpdateAsync(filter, update, options, cancellationToken);

            if (claimedMessage == null)
                break; // No more messages to claim

            claimedMessages.Add(claimedMessage);
        }

        return claimedMessages;
    }

    public async Task<List<OutboxMessageEntity>> GetAndClaimRetryMessagesAsync(int batchSize, CancellationToken cancellationToken = default)
    {
        var now = DateTimeOffset.UtcNow;
        var claimTimeout = TimeSpan.FromMinutes(5);

        // First, release any expired claims
        await ReleaseExpiredClaimsAsync(claimTimeout, cancellationToken);

        var claimedMessages = new List<OutboxMessageEntity>();

        // Use atomic findOneAndUpdate in a loop to avoid race conditions
        // This ensures each retry message is claimed atomically, preventing duplicates
        for (int i = 0; i < batchSize; i++)
        {
            var filter = Builders<OutboxMessageEntity>.Filter.And(
                Builders<OutboxMessageEntity>.Filter.Eq(x => x.ProcessedOnUtc, null),
                Builders<OutboxMessageEntity>.Filter.Or(
                    Builders<OutboxMessageEntity>.Filter.Eq(x => x.NextAttemptOnUtc, null),
                    Builders<OutboxMessageEntity>.Filter.Lte(x => x.NextAttemptOnUtc, now)
                ),
                Builders<OutboxMessageEntity>.Filter.Or(
                    Builders<OutboxMessageEntity>.Filter.Exists(x => x.ClaimedOnUtc, false),
                    Builders<OutboxMessageEntity>.Filter.Eq(x => x.ClaimedOnUtc, null)
                )
            );

            var update = Builders<OutboxMessageEntity>.Update
                .Set(x => x.ClaimedOnUtc, now);

            var options = new FindOneAndUpdateOptions<OutboxMessageEntity>
            {
                ReturnDocument = ReturnDocument.After,
                Sort = Builders<OutboxMessageEntity>.Sort.Ascending(x => x.NextAttemptOnUtc).Ascending(x => x.OccurredOnUtc)
            };

            var claimedMessage = await _collection.FindOneAndUpdateAsync(filter, update, options, cancellationToken);

            if (claimedMessage == null)
                break; // No more messages to claim

            // Check if the message is eligible for retry (MongoDB doesn't support field-to-field comparison)
            if (claimedMessage.AttemptCount < claimedMessage.MaxAttempts)
            {
                claimedMessages.Add(claimedMessage);
            }
            else
            {
                // Message has exceeded max attempts, release the claim
                await _collection.UpdateOneAsync(
                    Builders<OutboxMessageEntity>.Filter.Eq(x => x.Id, claimedMessage.Id),
                    Builders<OutboxMessageEntity>.Update.Unset(x => x.ClaimedOnUtc),
                    cancellationToken: cancellationToken);
            }
        }

        return claimedMessages;
    }

    public async Task<bool> ReleaseExpiredClaimsAsync(TimeSpan claimTimeout, CancellationToken cancellationToken = default)
    {
        var now = DateTimeOffset.UtcNow;
        var expiredClaimFilter = Builders<OutboxMessageEntity>.Filter.And(
            Builders<OutboxMessageEntity>.Filter.Eq(x => x.ProcessedOnUtc, null),
            Builders<OutboxMessageEntity>.Filter.Exists(x => x.ClaimedOnUtc, true),
            Builders<OutboxMessageEntity>.Filter.Lt(x => x.ClaimedOnUtc, now.Subtract(claimTimeout))
        );

        var releaseUpdate = Builders<OutboxMessageEntity>.Update
            .Unset(x => x.ClaimedOnUtc);

        var result = await _collection.UpdateManyAsync(expiredClaimFilter, releaseUpdate, cancellationToken: cancellationToken);

        return result.IsAcknowledged;
    }

    public async Task<bool> ReleaseClaimsAsync(IEnumerable<OutboxMessageEntity> messages, CancellationToken cancellationToken = default)
    {
        var messageIds = messages.Select(m => m.Id).ToList();

        if (!messageIds.Any()) return true;

        var filter = Builders<OutboxMessageEntity>.Filter.In(x => x.Id, messageIds);
        var update = Builders<OutboxMessageEntity>.Update
            .Unset(x => x.ClaimedOnUtc);

        var result = await _collection.UpdateManyAsync(filter, update, cancellationToken: cancellationToken);

        return result.IsAcknowledged;
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/Services/CatalogGrpcService.cs">
#region using

using Basket.Application.Models.Responses.Externals;
using Basket.Application.Services;
using Catalog.Grpc;
using Microsoft.Extensions.Logging;

#endregion

namespace Basket.Infrastructure.Services;

public sealed class CatalogGrpcService(CatalogGrpc.CatalogGrpcClient grpcClient, ILogger<CatalogGrpcService> logger) : ICatalogGrpcService
{
    #region Methods

    public async Task<ProductReponse?> GetProductByIdAsync(string productId, CancellationToken cancellationToken = default)
    {
        try
        {
            var result = await grpcClient.GetProductByIdAsync(
                new GetProductByIdRequest { Id = productId },
                cancellationToken: cancellationToken);

            var product = result.Product;

            return new ProductReponse()
            {
                Id = Guid.Parse(product.Id),
                Price = (decimal)product.Price,
                Name = product.Name
            };
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex, "Failed to get product by ID {ProductId} from Catalog Grpc service", productId);
            return null;
        }
    }

    public async Task<GetAllProductsResponse?> GetProductsAsync(string[]? ids = null, string searchText = "", CancellationToken cancellationToken = default)
    {
        try
        {
            var request = new GetProductsRequest { SearchText = searchText };
            if (ids is not null && ids.Length > 0)
                request.Ids.AddRange(ids);

            var result = await grpcClient.GetProductsAsync(request, cancellationToken: cancellationToken);

            var response = new GetAllProductsResponse
            {
                Items = result.Products
                    .Select(p => new ProductReponse
                    {
                        Id = Guid.Parse(p.Id),
                        Name = p.Name,
                        Price = (decimal)p.Price,
                        Thumbnail = p.Thumbnail
                    })
                    .ToList()
            };

            return response;
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex, "Failed to get products from Catalog Grpc service");
            return null;
        }
    }

    public async Task<GetAllProductsResponse?> GetAllAvailableProductsAsync(string[]? ids = null, string searchText = "", CancellationToken cancellationToken = default)
    {
        try
        {
            var request = new GetAllAvailableProductsRequest { SearchText = searchText };

            if (ids is not null && ids.Length > 0)
                request.Ids.AddRange(ids);

            var result = await grpcClient.GetAllAvailableProductsAsync(request, cancellationToken: cancellationToken);

            var response = new GetAllProductsResponse
            {
                Items = result.Products
                    .Select(p => new ProductReponse
                    {
                        Id = Guid.Parse(p.Id),
                        Name = p.Name,
                        Price = (decimal)p.Price,
                        Thumbnail = p.Thumbnail
                    })
                    .ToList()
            };

            return response;
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex, "Failed to get all available products from Catalog Grpc service");
            return null;
        }
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/Services/DiscountGrpcService.cs">
#region using

using Basket.Application.Services;
using Discount.Grpc;
using Microsoft.Extensions.Logging;

#endregion

namespace Basket.Infrastructure.Services;

public sealed class DiscountGrpcService(DiscountGrpc.DiscountGrpcClient grpcClient, ILogger<DiscountGrpcService> logger) : IDiscountGrpcService
{
    public async Task<Application.Models.Responses.Externals.EvaluateCouponResponse?> EvaluateCouponAsync(string code, decimal amount, CancellationToken cancellationToken = default)
    {
        try
        {
            var request = new EvaluateCouponRequest { Amount = (double)amount, Code = code };

            var result = await grpcClient.EvaluateCouponAsync(
                request,
                cancellationToken: cancellationToken);

            return new Application.Models.Responses.Externals.EvaluateCouponResponse()
            {
                CouponCode = result.CouponCode,
                DiscountAmount = (decimal)result.DiscountAmount,
                FinalAmount = (decimal)result.FinalAmount,
                OriginalAmount = (decimal)result.OriginalAmount
            };
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex, "Failed to evaluate coupon {ProductId} from Discount Grpc service", code);
            return null;
        }
    }
}
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/Basket.Infrastructure.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <Protobuf Include="..\..\..\..\Shared\Contracts\Catalog.Contract\Protos\catalog.proto" GrpcServices="Client" />
    <Protobuf Include="..\..\..\..\Shared\Contracts\Discount.Contract\Protos\discount.proto" GrpcServices="Client" />
  </ItemGroup>
  
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Caching.StackExchangeRedis" />
    <PackageReference Include="MongoDB.Driver" />
    <PackageReference Include="Scrutor" />
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="Google.Protobuf" />
    <PackageReference Include="Grpc.Net.Client" />
    <PackageReference Include="Grpc.Tools">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\Basket.Application\Basket.Application.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/DependencyInjection.cs">
#region using

using Basket.Application.Repositories;
using Basket.Infrastructure.Data.Extensions;
using Basket.Infrastructure.GrpcClients.Extensions;
using Basket.Infrastructure.Repositories;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using MongoDB.Driver;
using StackExchange.Redis;

#endregion

namespace Basket.Infrastructure;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddInfrastructureServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Service")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithScopedLifetime());

        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Repository")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithSingletonLifetime());

        services.Decorate<IBasketRepository, CachedBasketRepository>();

        var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];
        var dbName = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DatabaseName}"];

        services.AddSingleton<IMongoClient>(sp =>
        {
            var settings = MongoClientSettings.FromConnectionString(conn);
            return new MongoClient(settings);
        });
        services.AddSingleton<IMongoDatabase>(sp =>
        {
            return sp.GetRequiredService<IMongoClient>().GetDatabase(dbName);
        });

        services.AddStackExchangeRedisCache(options =>
        {
            options.ConfigurationOptions = new ConfigurationOptions
            {
                EndPoints = { cfg[$"{RedisCacheCfg.Section}:{RedisCacheCfg.EndPoint}"]! },
                Password = cfg[$"{RedisCacheCfg.Section}:{RedisCacheCfg.Password}"]!,
                AbortOnConnectFail = false,
                ConnectRetry = 3,
                ConnectTimeout = 5000,
                DefaultDatabase = 0
            };
            options.InstanceName = cfg[$"{RedisCacheCfg.Section}:{RedisCacheCfg.InstanceName}"]!;
        });

        services.AddGrpcClients(cfg);

        return services;
    }

    public static WebApplication UseInfrastructure(this WebApplication app)
    {
        app.EnsureIndexesAsync().GetAwaiter();

        return app;
    }

    #endregion
}
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/GlobalUsing.cs">
global using Common.Configurations;
global using Common.Constants;
</file>

<file path="Services/Basket/Core/Basket.Infrastructure/InfrastructureMarker.cs">
namespace Basket.Infrastructure;

public sealed class InfrastructureMarker { }
</file>

<file path="Services/Basket/Worker/Basket.Worker.Outbox/BackgroundServices/OutboxBackgroundService.cs">
#region using

using Basket.Worker.Outbox.Processors;
using Common.Configurations;

#endregion

namespace Basket.Worker.Outbox.BackgroundServices;

internal class OutboxBackgroundService : BackgroundService
{
    #region Fields, Properties and Indexers

    private readonly int _processorFrequency;

    private readonly int _maxParallelism;

    private int _totalIterations = 0;

    private int _totalProcessedMessage = 0;

    private readonly IServiceScopeFactory _serviceScopeFactory;

    private readonly ILogger<OutboxBackgroundService> _logger;

    #endregion

    #region Ctors

    public OutboxBackgroundService(
        IServiceScopeFactory serviceScopeFactory,
        IConfiguration cfg,
        ILogger<OutboxBackgroundService> logger)
    {
        _processorFrequency = cfg.GetValue<int>($"{WorkerCfg.Outbox.Section}:{WorkerCfg.Outbox.ProcessorFrequency}", 5);
        _maxParallelism = cfg.GetValue<int>($"{WorkerCfg.Outbox.Section}:{WorkerCfg.Outbox.MaxParallelism}", 5);
        _serviceScopeFactory = serviceScopeFactory;
        _logger = logger;
    }

    #endregion

    #region Methods

    protected override async Task ExecuteAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Outbox processor started");

        var parallelOptions = new ParallelOptions
        {
            MaxDegreeOfParallelism = _maxParallelism,
            CancellationToken = cancellationToken
        };

        try
        {
            await Parallel.ForEachAsync(
                Enumerable.Range(0, _maxParallelism),
                parallelOptions,
                async (_, token) =>
                {
                    await ProcessOutboxMessagesAsync(token);
                });
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Outbox processor operation cancelled");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred while processing outbox messages");
        }
    }

    private async Task ProcessOutboxMessagesAsync(CancellationToken cancellationToken)
    {
        using var scope = _serviceScopeFactory.CreateScope();
        var outboxProcessor = scope.ServiceProvider.GetRequiredService<OutboxProcessor>();

        while (true)
        {
            int processedMessages = await outboxProcessor.ExecuteAsync(cancellationToken);
            var totalProcessedMessages = Interlocked.Add(ref _totalProcessedMessage, processedMessages);

            // Only log if there were messages processed or every 100 iterations
            var iterationCount = Interlocked.Increment(ref _totalIterations);
            if (processedMessages > 0 || iterationCount % 100 == 0)
            {
                _logger.LogInformation("Iteration {IterationCount}: Processed {ProcessedMessages} messages. Total: {TotalProcessedMessages}",
                    iterationCount, processedMessages, totalProcessedMessages);
            }

            await Task.Delay(TimeSpan.FromSeconds(_processorFrequency), cancellationToken);
        }
    }

    #endregion
}
</file>

<file path="Services/Basket/Worker/Basket.Worker.Outbox/Processors/OutboxProcessor.cs">
#region using

using Common.Configurations;
using Basket.Domain.Entities;
using Basket.Worker.Outbox.Structs;
using MassTransit;
using System.Collections.Concurrent;
using System.Text.Json;
using Basket.Application.Repositories;
using MongoDB.Driver;

#endregion

namespace Basket.Worker.Outbox.Processors;

internal sealed class OutboxProcessor
{
    #region Fields, Properties and Indexers

    private readonly int _batchSize;

    private static readonly ConcurrentDictionary<string, Type> TypeCache = new();

    private readonly IOutboxRepository _outboxRepo;

    private readonly IPublishEndpoint _publish;

    private readonly ILogger<OutboxProcessor> _logger;

    #endregion

    #region Ctors

    public OutboxProcessor(
        IOutboxRepository outboxRepo,
        IConfiguration cfg,
        IPublishEndpoint publish,
        ILogger<OutboxProcessor> logger)
    {
        _batchSize = cfg.GetValue<int>($"{WorkerCfg.Outbox.Section}:{WorkerCfg.Outbox.BatchSize}", 1000);
        _outboxRepo = outboxRepo;
        _publish = publish;
        _logger = logger;
    }

    #endregion

    #region Methods

    public async Task<int> ExecuteAsync(CancellationToken cancellationToken = default)
    {

        // Process both new messages and retry messages
        var newMessages = await _outboxRepo.GetAndClaimMessagesAsync(_batchSize, cancellationToken);
        var retryMessages = await _outboxRepo.GetAndClaimRetryMessagesAsync(_batchSize, cancellationToken);

        var allMessages = newMessages.Concat(retryMessages).ToList();

        if (allMessages.Count == 0) return 0;

        var updateQueue = new ConcurrentQueue<OutboxUpdate>();

        var publishTasks = allMessages
            .Select(message => ProcessMessageAsync(message, updateQueue, _publish, _logger, cancellationToken))
            .ToList();

        await Task.WhenAll(publishTasks);

        if (!updateQueue.IsEmpty)
        {
            // Convert OutboxUpdate to OutboxMessageEntity for bulk update
            var messagesToUpdate = updateQueue.Select(update =>
            {
                var message = allMessages.First(m => m.Id == update.Id);
                message.CompleteProcessing(update.ProcessedOnUtc, update.LastErrorMessage);
                return message;
            }).ToList();

            await _outboxRepo.UpdateMessagesAsync(messagesToUpdate, cancellationToken);
        }
        else
        {
            // If no messages were successfully processed, release the claims
            _logger.LogWarning("No messages were successfully processed, releasing claims");
            await _outboxRepo.ReleaseClaimsAsync(allMessages, cancellationToken);
        }

        if (allMessages.Count > 0)
        {
            _logger.LogInformation("Processed {Count} messages from outbox", allMessages.Count);
        }

        return allMessages.Count;
    }

    private static async Task ProcessMessageAsync(
        OutboxMessageEntity message,
        ConcurrentQueue<OutboxUpdate> updateQueue,
        IPublishEndpoint publish,
        ILogger<OutboxProcessor> logger,
        CancellationToken cancellationToken)
    {
        try
        {

            var messageType = GetOrAddMessageType(message.EventType!);
            var deserializedMessage = JsonSerializer.Deserialize(message.Content!, messageType)!;

            logger.LogInformation("Publishing message {Id} of type {EventType} (attempt {AttemptCount}/{MaxAttempts})",
                message.Id, message.EventType, message.AttemptCount, message.MaxAttempts);

            await publish.Publish(deserializedMessage, cancellationToken);

            // Increment attempt count for successful publish
            message.IncreaseAttemptCount();

            logger.LogInformation("Successfully published message {Id} of type {EventType} (attempt {AttemptCount})",
                message.Id, message.EventType, message.AttemptCount);

            // Success - mark as processed
            updateQueue.Enqueue(new OutboxUpdate(
                message.Id,
                DateTimeOffset.UtcNow,
                null,
                message.AttemptCount,
                null));

        }
        catch (Exception ex)
        {
            var currentTime = DateTimeOffset.UtcNow;
            message.RecordFailedAttempt(ex.ToString(), currentTime);

            if (message.IsPermanentlyFailed())
            {
                // Permanently failed - mark as processed with error
                updateQueue.Enqueue(new OutboxUpdate(
                    message.Id,
                    currentTime,
                    message.LastErrorMessage,
                    message.AttemptCount,
                    null));

                logger.LogError(ex, "Permanently failed to publish outbox message {Id} after {AttemptCount} attempts",
                    message.Id, message.AttemptCount);
            }
            else
            {
                // Schedule for retry
                updateQueue.Enqueue(new OutboxUpdate(
                    message.Id,
                    currentTime,
                    message.LastErrorMessage,
                    message.AttemptCount,
                    message.NextAttemptOnUtc));

                logger.LogWarning(ex, "Failed to publish outbox message {Id} (attempt {AttemptCount}/{MaxAttempts}), will retry at {NextAttemptOnUtc}",
                    message.Id, message.AttemptCount, message.MaxAttempts, message.NextAttemptOnUtc);
            }
        }
    }

    private static Type GetOrAddMessageType(string typename)
    {
        return TypeCache.GetOrAdd(typename, name => Type.GetType(name)!);
    }

    #endregion
}
</file>

<file path="Services/Basket/Worker/Basket.Worker.Outbox/Structs/OutboxUpdate.cs">
namespace Basket.Worker.Outbox.Structs;

public record struct OutboxUpdate(
    Guid Id,
    DateTimeOffset ProcessedOnUtc,
    string? LastErrorMessage,
    int AttemptCount,
    DateTimeOffset? NextAttemptOnUtc);
</file>

<file path="Services/Basket/Worker/Basket.Worker.Outbox/Basket.Worker.Outbox.csproj">
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <PropertyGroup>
    <UserSecretsId>dotnet-Basket.Worker.Outbox-87ed7ae0-8563-4f43-ba96-4374bbb8f7ec</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Basket.Application\Basket.Application.csproj" />
    <ProjectReference Include="..\..\Core\Basket.Domain\Basket.Domain.csproj" />
    <ProjectReference Include="..\..\Core\Basket.Infrastructure\Basket.Infrastructure.csproj" />
  </ItemGroup>
  
</Project>
</file>

<file path="Services/Basket/Worker/Basket.Worker.Outbox/DependencyInjection.cs">
#region using

using BuildingBlocks.Logging;
using System.Reflection;
using EventSourcing.MassTransit;
using Basket.Worker.Outbox.Processors;

#endregion

namespace Basket.Worker.Outbox;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddWorkerServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddSerilogLogging(cfg);
        services.AddMessageBroker(cfg, Assembly.GetExecutingAssembly());
        services.AddScoped<OutboxProcessor>();

        return services;
    }

    #endregion
}
</file>

<file path="Services/Basket/Worker/Basket.Worker.Outbox/Program.cs">
#region using

using Basket.Application;
using Basket.Infrastructure;
using Basket.Worker.Outbox;
using Basket.Worker.Outbox.BackgroundServices;

#endregion

var builder = Host.CreateApplicationBuilder(args);

builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddWorkerServices(builder.Configuration)
    .AddHostedService<OutboxBackgroundService>();

var host = builder.Build();

host.Run();
</file>

<file path="Services/Catalog/Api/Catalog.Api/Constants/ApiRoutes.cs">
namespace Catalog.Api.Constants;

public sealed class ApiRoutes
{
    public static class Product
    {
        #region Constants

        public const string Tags = "Products";

        private const string Base = "/products";

        private const string BaseAdmin = "/admin/products";

        public const string Create = $"{BaseAdmin}";

        public const string Delete = $"{BaseAdmin}/{{productId}}";

        public const string Update = $"{BaseAdmin}/{{productId}}";

        public const string Unpublish = $"{BaseAdmin}/{{productId}}/unpublish";

        public const string Publish = $"{BaseAdmin}/{{productId}}/publish";

        public const string GetProductById = $"{BaseAdmin}/{{productId}}";

        public const string GetProducts = $"{BaseAdmin}";

        public const string GetAllProducts = $"{BaseAdmin}/all";

        public const string GetPublicProductById = $"{Base}/{{productId}}";

        public const string GetPublicProducts = $"{Base}";

        #endregion
    }

    public static class Category
    {
        #region Constants

        public const string Tags = "Categories";

        private const string Base = "/categories";

        private const string BaseAdmin = "/admin/categories";

        public const string Create = $"{BaseAdmin}";

        public const string Update = $"{BaseAdmin}/{{categoryId}}";

        public const string Delete = $"{BaseAdmin}/{{categoryId}}";

        public const string GetAll = $"{Base}";

        public const string GetTree = $"{Base}/tree";

        #endregion
    }

    public static class Brand
    {
        #region Constants

        public const string Tags = "Brands";

        private const string Base = "/brands";

        private const string BaseAdmin = "/admin/brands";

        public const string Create = $"{BaseAdmin}";

        public const string Update = $"{BaseAdmin}/{{brandId}}";

        public const string Delete = $"{BaseAdmin}/{{brandId}}";

        public const string GetAll = $"{Base}";

        #endregion
    }

    public static class System
    {
        #region Constants

        public const string Tags = "System";

        private const string BaseAdmin = "/admin/system";

        public const string InitializeData = $"{BaseAdmin}/initialize-data";

        #endregion
    }
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/CreateBrand.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Catalog.Api.Constants;
using Catalog.Application.Features.Brand.Commands;
using Catalog.Application.Dtos.Brands;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class CreateBrand : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Brand.Create, HandleCreateBrandAsync)
            .WithTags(ApiRoutes.Brand.Tags)
            .WithName(nameof(CreateBrand))
            .Produces<ApiCreatedResponse<Guid>>(StatusCodes.Status201Created)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiCreatedResponse<Guid>> HandleCreateBrandAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromBody] CreateBrandDto req)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new CreateBrandCommand(req, Actor.User(currentUser.Email));

        var result = await sender.Send(command);

        return new ApiCreatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/CreateCategory.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Catalog.Api.Constants;
using Catalog.Application.Features.Category.Commands;
using Catalog.Application.Dtos.Categories;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class CreateCategory : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Category.Create, HandleCreateCategoryAsync)
            .WithTags(ApiRoutes.Category.Tags)
            .WithName(nameof(CreateCategory))
            .Produces<ApiCreatedResponse<Guid>>(StatusCodes.Status201Created)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiCreatedResponse<Guid>> HandleCreateCategoryAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromBody] CreateCategoryDto req)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new CreateCategoryCommand(req, Actor.User(currentUser.Email));

        var result = await sender.Send(command);

        return new ApiCreatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/CreateProduct.cs">
#region using

using BuildingBlocks.Exceptions;
using BuildingBlocks.Swagger.Extensions;
using Catalog.Api.Constants;
using Catalog.Api.Models;
using Catalog.Application.Features.Product.Commands;
using Catalog.Application.Dtos.Products;
using AutoMapper;
using Microsoft.AspNetCore.Mvc;
using Common.Constants;
using Common.Models;
using BuildingBlocks.Authentication.Extensions;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class CreateProduct : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Product.Create, HandleCreateProductAsync)
            .WithTags(ApiRoutes.Product.Tags)
            .WithName(nameof(CreateProduct))
            .WithMultipartForm<CreateProductRequest>()
            .Produces<ApiCreatedResponse<Guid>>(StatusCodes.Status201Created)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .DisableAntiforgery()
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiCreatedResponse<Guid>> HandleCreateProductAsync(
        ISender sender,
        IMapper mapper,
        IHttpContextAccessor httpContext,
        [FromForm] CreateProductRequest req)
    {
        if (req == null) throw new ClientValidationException(MessageCode.BadRequest);
        if ((req.ImageFiles == null || req.ImageFiles.Count == 0) && httpContext.HttpContext != null)
        {
            req.ImageFiles = httpContext.HttpContext.Request.Form.Files.ToList();
        }

        var dto = mapper.Map<CreateProductDto>(req);

        if (req.ImageFiles != null && req.ImageFiles.Count > 0)
        {
            dto.UploadImages ??= new();
            foreach (var file in req.ImageFiles!)
            {
                using var ms = new MemoryStream();
                await file.CopyToAsync(ms);
                dto.UploadImages.Add(new UploadFileBytes
                {
                    FileName = file.FileName,
                    Bytes = ms.ToArray(),
                    ContentType = file.ContentType
                });
            }
        }

        if (req.ThumbnailFile != null && req.ThumbnailFile.Length > 0)
        {
            using var ms = new MemoryStream();
            await req.ThumbnailFile.CopyToAsync(ms);

            dto.UploadThumbnail = new UploadFileBytes
            {
                FileName = req.ThumbnailFile.FileName,
                Bytes = ms.ToArray(),
                ContentType = req.ThumbnailFile.ContentType
            };
        }

        var currentUser = httpContext.GetCurrentUser();
        var command = new CreateProductCommand(dto, Actor.User(currentUser.Email));

        var result = await sender.Send(command);

        return new ApiCreatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/DeleteBrand.cs">
#region using

using Catalog.Api.Constants;
using Catalog.Application.Features.Brand.Commands;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class DeleteBrand : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapDelete(ApiRoutes.Brand.Delete, HandleDeleteBrandAsync)
            .WithTags(ApiRoutes.Brand.Tags)
            .WithName(nameof(DeleteBrand))
            .Produces<ApiDeletedResponse<Guid>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiDeletedResponse<Guid>> HandleDeleteBrandAsync(
        ISender sender,
        Guid brandId)
    {
        var command = new DeleteBrandCommand(brandId);

        await sender.Send(command);

        return new ApiDeletedResponse<Guid>(brandId);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/DeleteCategory.cs">
#region using

using Catalog.Api.Constants;
using Catalog.Application.Features.Category.Commands;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class DeleteCategory : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapDelete(ApiRoutes.Category.Delete, HandleDeleteCategoryAsync)
            .WithTags(ApiRoutes.Category.Tags)
            .WithName(nameof(DeleteCategory))
            .Produces<ApiDeletedResponse<Guid>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiDeletedResponse<Guid>> HandleDeleteCategoryAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        Guid categoryId)
    {
        var command = new DeleteCategoryCommand(categoryId);

        await sender.Send(command);

        return new ApiDeletedResponse<Guid>(categoryId);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/DeleteProduct.cs">
#region using

using Catalog.Api.Constants;
using Catalog.Application.Features.Product.Commands;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class DeleteProduct : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapDelete(ApiRoutes.Product.Delete, HandleDeleteProductAsync)
            .WithTags(ApiRoutes.Product.Tags)
            .WithName(nameof(DeleteProduct))
            .Produces<ApiDeletedResponse<Guid>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiDeletedResponse<Guid>> HandleDeleteProductAsync(
        ISender sender,
        [FromRoute] Guid productId)
    {
        var command = new DeleteProductCommand(productId);

        await sender.Send(command);

        return new ApiDeletedResponse<Guid>(productId);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/GetAllBrands.cs">
#region using

using Catalog.Api.Constants;
using Catalog.Application.Features.Brand.Queries;
using Catalog.Application.Models.Results;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class GetAllBrands : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Brand.GetAll, HandleGetAllBrandsAsync)
            .WithTags(ApiRoutes.Brand.Tags)
            .WithName(nameof(GetAllBrands))
            .Produces<ApiGetResponse<GetAllBrandsResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest);
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetAllBrandsResult>> HandleGetAllBrandsAsync(ISender sender)
    {
        var query = new GetAllBrandsQuery();
        var result = await sender.Send(query);

        return new ApiGetResponse<GetAllBrandsResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/GetAllCategories.cs">
#region using

using Catalog.Api.Constants;
using Catalog.Application.Features.Category.Queries;
using Catalog.Application.Models.Filters;
using Catalog.Application.Models.Results;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class GetAllCategories : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Category.GetAll, HandleGetAllCategoriesAsync)
            .WithTags(ApiRoutes.Category.Tags)
            .WithName(nameof(GetAllCategories))
            .Produces<ApiGetResponse<GetAllCategoriesResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest);
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetAllCategoriesResult>> HandleGetAllCategoriesAsync(
        ISender sender,
        [AsParameters] GetAllCategoriesFilter req)
    {
        var query = new GetAllCategoriesQuery(req);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetAllCategoriesResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/GetAllProducts.cs">
#region using

using Catalog.Api.Constants;
using Catalog.Application.Features.Product.Queries;
using Catalog.Application.Models.Filters;
using Catalog.Application.Models.Results;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class GetAllProducts : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Product.GetAllProducts, HandleGetAllProductsAsync)
            .WithTags(ApiRoutes.Product.Tags)
            .WithName(nameof(GetAllProducts))
            .Produces<ApiGetResponse<GetAllProductsResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetAllProductsResult>> HandleGetAllProductsAsync(
        ISender sender,
        [AsParameters] GetAllProductsFilter req)
    {
        var query = new GetAllProductsQuery(req);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetAllProductsResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/GetProductById.cs">
#region using

using Catalog.Api.Constants;
using Catalog.Application.Features.Product.Queries;
using Catalog.Application.Models.Results;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class GetProductById : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Product.GetProductById, HandleGetProductByIdAsync)
            .WithTags(ApiRoutes.Product.Tags)
            .WithName(nameof(GetProductById))
            .Produces<ApiGetResponse<GetProductByIdResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetProductByIdResult>> HandleGetProductByIdAsync(
        ISender sender,
        [FromRoute] Guid productId)
    {
        var query = new GetProductByIdQuery(productId);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetProductByIdResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/GetProducts.cs">
#region using

using Catalog.Api.Constants;
using Catalog.Application.Features.Product.Queries;
using Catalog.Application.Models.Filters;
using Catalog.Application.Models.Results;
using Common.Models;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class GetProducts : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Product.GetProducts, HandleGetProductsAsync)
            .WithTags(ApiRoutes.Product.Tags)
            .WithName(nameof(GetProducts))
            .Produces<ApiGetResponse<GetProductsResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetProductsResult>> HandleGetProductsAsync(
        ISender sender,
        [AsParameters] GetProductsFilter req,
        [AsParameters] PaginationRequest paging)
    {
        var query = new GetProductsQuery(req, paging);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetProductsResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/GetPublishProductById.cs">
#region using

using Catalog.Api.Constants;
using Catalog.Application.Features.Product.Queries;
using Catalog.Application.Models.Results;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class GetPublishProductById : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Product.GetPublicProductById, HandleGetPublishProductByIdAsync)
            .WithTags(ApiRoutes.Product.Tags)
            .WithName(nameof(GetPublishProductById))
            .Produces<ApiGetResponse<GetPublishProductByIdResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound);
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetPublishProductByIdResult>> HandleGetPublishProductByIdAsync(
        ISender sender,
        [FromRoute] Guid productId)
    {
        var query = new GetPublishProductByIdQuery(productId);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetPublishProductByIdResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/GetPublishProducts.cs">
#region using

using Catalog.Api.Constants;
using Catalog.Application.Features.Product.Queries;
using Catalog.Application.Models.Filters;
using Catalog.Application.Models.Results;
using Common.Models;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class GetPublishProducts : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Product.GetPublicProducts, HandleGetPublishProductsAsync)
            .WithTags(ApiRoutes.Product.Tags)
            .WithName(nameof(GetPublishProducts))
            .Produces<ApiGetResponse<GetPublishProductsResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound);
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetPublishProductsResult>> HandleGetPublishProductsAsync(
        ISender sender,
        [AsParameters] GetPublishProductsFilter req,
        [AsParameters] PaginationRequest paging)
    {
        var query = new GetPublishProductsQuery(req, paging);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetPublishProductsResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/GetTreeCategories.cs">
#region using

using Catalog.Api.Constants;
using Catalog.Application.Features.Category.Queries;
using Catalog.Application.Models.Results;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class GetTreeCategories : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Category.GetTree, HandleGetTreeCategoriesAsync)
            .WithTags(ApiRoutes.Category.Tags)
            .WithName(nameof(GetTreeCategories))
            .Produces<ApiGetResponse<GetTreeCategoriesResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound);
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetTreeCategoriesResult>> HandleGetTreeCategoriesAsync(ISender sender)
    {
        var query = new GetTreeCategoriesQuery();
        var result = await sender.Send(query);

        return new ApiGetResponse<GetTreeCategoriesResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/InitializeData.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Catalog.Api.Constants;
using Catalog.Application.Features.System;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class InitializeData : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.System.InitializeData, HandleInitializeDataAsync)
            .WithTags(ApiRoutes.System.Tags)
            .WithName(nameof(InitializeData))
            .Produces<ApiUpdatedResponse<bool>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<bool>> HandleInitializeDataAsync(
        ISender sender,
        IHttpContextAccessor httpContext)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new InitialDataCommand(Actor.User(currentUser.Email));
        var result = await sender.Send(command);

        return new ApiUpdatedResponse<bool>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/PublishProduct.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Catalog.Api.Constants;
using Catalog.Application.Features.Product.Commands;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class PublishProduct : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Product.Publish, HandlePublishProductAsync)
            .WithTags(ApiRoutes.Product.Tags)
            .WithName(nameof(PublishProduct))
            .Produces<ApiUpdatedResponse<Guid>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<Guid>> HandlePublishProductAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromRoute] Guid productId)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new PublishProductCommand(productId, Actor.User(currentUser.Email));
        var result = await sender.Send(command);

        return new ApiUpdatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/UnpublishProduct.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Catalog.Api.Constants;
using Catalog.Application.Features.Product.Commands;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class UnpublishProduct : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Product.Unpublish, HandleUnpublishProductAsync)
            .WithTags(ApiRoutes.Product.Tags)
            .WithName(nameof(UnpublishProduct))
            .Produces<ApiUpdatedResponse<Guid>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<Guid>> HandleUnpublishProductAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromRoute] Guid productId)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new UnpublishProductCommand(productId, Actor.User(currentUser.Email));
        var result = await sender.Send(command);

        return new ApiUpdatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/UpdateBrand.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Catalog.Api.Constants;
using Catalog.Application.Features.Brand.Commands;
using Catalog.Application.Dtos.Brands;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class UpdateBrand : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPut(ApiRoutes.Brand.Update, HandleUpdateBrandAsync)
            .WithTags(ApiRoutes.Brand.Tags)
            .WithName(nameof(UpdateBrand))
            .Produces<ApiUpdatedResponse<Guid>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<Guid>> HandleUpdateBrandAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        Guid brandId,
        [FromBody] UpdateBrandDto req)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new UpdateBrandCommand(brandId, req, Actor.User(currentUser.Email));

        var result = await sender.Send(command);

        return new ApiUpdatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/UpdateCategory.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Catalog.Api.Constants;
using Catalog.Application.Features.Category.Commands;
using Catalog.Application.Dtos.Categories;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class UpdateCategory : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPut(ApiRoutes.Category.Update, HandleUpdateCategoryAsync)
            .WithTags(ApiRoutes.Category.Tags)
            .WithName(nameof(UpdateCategory))
            .Produces<ApiUpdatedResponse<Guid>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<Guid>> HandleUpdateCategoryAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        Guid categoryId,
        [FromBody] UpdateCategoryDto req)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new UpdateCategoryCommand(categoryId, req, Actor.User(currentUser.Email));

        var result = await sender.Send(command);

        return new ApiUpdatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Endpoints/UpdateProduct.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using BuildingBlocks.Exceptions;
using BuildingBlocks.Swagger.Extensions;
using Catalog.Api.Constants;
using Catalog.Api.Models;
using Catalog.Application.Features.Product.Commands;
using Catalog.Application.Dtos.Products;
using Common.Constants;
using Common.Models;
using AutoMapper;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Catalog.Api.Endpoints;

public sealed class UpdateProduct : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPut(ApiRoutes.Product.Update, HandleUpdateProductAsync)
            .WithTags(ApiRoutes.Product.Tags)
            .WithName(nameof(UpdateProduct))
            .WithMultipartForm<UpdateProductRequest>()
            .Produces<ApiUpdatedResponse<Guid>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .DisableAntiforgery()
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<Guid>> HandleUpdateProductAsync(
        ISender sender,
        IMapper mapper,
        IHttpContextAccessor httpContext,
        [FromRoute] Guid productId,
        [FromForm] UpdateProductRequest req)
    {
        if (req == null) throw new ClientValidationException(MessageCode.BadRequest);
        if ((req.ImageFiles == null || req.ImageFiles.Count == 0) && httpContext.HttpContext != null)
        {
            req.ImageFiles = httpContext.HttpContext.Request.Form.Files.ToList();
        }

        var dto = mapper.Map<UpdateProductDto>(req);

        if (req.ImageFiles != null && req.ImageFiles.Count > 0)
        {
            dto.UploadImages ??= new();
            foreach (var file in req.ImageFiles!)
            {
                using var ms = new MemoryStream();
                await file.CopyToAsync(ms);
                dto.UploadImages.Add(new UploadFileBytes
                {
                    FileName = file.FileName,
                    Bytes = ms.ToArray(),
                    ContentType = file.ContentType
                });
            }
        }

        if (req.ThumbnailFile != null && req.ThumbnailFile.Length > 0)
        {
            using var ms = new MemoryStream();
            await req.ThumbnailFile.CopyToAsync(ms);

            dto.UploadThumbnail = new UploadFileBytes
            {
                FileName = req.ThumbnailFile.FileName,
                Bytes = ms.ToArray(),
                ContentType = req.ThumbnailFile.ContentType
            };
        }

        var currentUser = httpContext.GetCurrentUser();
        var command = new UpdateProductCommand(productId, dto, Actor.User(currentUser.Email));

        var result = await sender.Send(command);

        return new ApiUpdatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Mappings/CatalogApiMappingProfile.cs">
#region using

using AutoMapper;
using Catalog.Api.Models;
using Catalog.Application.Dtos.Products;

#endregion

namespace Catalog.Api.Mappings;

public sealed class CatalogApiMappingProfile : Profile
{
    #region Ctors

    public CatalogApiMappingProfile()
    {
        // CreateProductRequest -> CreateProductDto
        CreateMap<CreateProductRequest, CreateProductDto>()
            .ForMember(dest => dest.UploadImages, opt => opt.Ignore())
            .ForMember(dest => dest.UploadThumbnail, opt => opt.Ignore()); // Files are handled separately

        // UpdateProductRequest -> UpdateProductDto
        CreateMap<UpdateProductRequest, UpdateProductDto>()
            .ForMember(dest => dest.UploadImages, opt => opt.Ignore())
            .ForMember(dest => dest.UploadThumbnail, opt => opt.Ignore()); // Files are handled separately
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Models/CreateProductRequest.cs">
namespace Catalog.Api.Models;

public sealed class CreateProductRequest
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    public string? Sku { get; set; }

    public string? ShortDescription { get; set; }

    public string? LongDescription { get; set; }

    public decimal Price { get; set; }

    public decimal? SalePrice { get; set; }

    public List<string>? CategoryIds { get; set; }

    public List<IFormFile>? ImageFiles { get; set; }

    public IFormFile? ThumbnailFile { get; set; }

    public Guid? BrandId { get; set; }

    public List<string>? Colors { get; set; }

    public List<string>? Sizes { get; set; }

    public List<string>? Tags { get; set; }

    public bool Published { get; set; }

    public bool Featured { get; set; }

    public string? SEOTitle { get; set; }

    public string? SEODescription { get; set; }

    public string? Barcode { get; set; }

    public string? Unit { get; set; }

    public decimal? Weight { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Models/UpdateProductRequest.cs">
namespace Catalog.Api.Models;

public sealed class UpdateProductRequest
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    public string? Sku { get; set; }

    public string? ShortDescription { get; set; }

    public string? LongDescription { get; set; }

    public decimal Price { get; set; }

    public decimal? SalePrice { get; set; }

    public List<string>? CategoryIds { get; set; }

    public List<string>? CurrentImageUrls { get; set; }

    public List<IFormFile>? ImageFiles { get; set; }

    public IFormFile? ThumbnailFile { get; set; }

    public Guid? BrandId { get; set; }

    public List<string>? Colors { get; set; }

    public List<string>? Sizes { get; set; }

    public List<string>? Tags { get; set; }

    public bool Published { get; set; }

    public bool Featured { get; set; }

    public string? SEOTitle { get; set; }

    public string? SEODescription { get; set; }

    public string? Barcode { get; set; }

    public string? Unit { get; set; }

    public decimal? Weight { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Api/Catalog.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <UserSecretsId>68beccec-977d-4711-a7f7-5d8d06e5c2e0</UserSecretsId>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="AspNetCore.HealthChecks.MongoDb" />
    <PackageReference Include="AspNetCore.HealthChecks.MySql" />
    <PackageReference Include="AspNetCore.HealthChecks.NpgSql" />
    <PackageReference Include="AspNetCore.HealthChecks.Redis" />
    <PackageReference Include="AspNetCore.HealthChecks.SqlServer" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" />
    <PackageReference Include="AutoMapper" />
    <PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" />
    <PackageReference Include="Carter" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Catalog.Application\Catalog.Application.csproj" />
    <ProjectReference Include="..\..\Core\Catalog.Infrastructure\Catalog.Infrastructure.csproj" />
  </ItemGroup>
  
</Project>
</file>

<file path="Services/Catalog/Api/Catalog.Api/DependencyInjection.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using BuildingBlocks.Swagger.Extensions;
using Common.Configurations;
using Common.Constants;
using HealthChecks.UI.Client;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using System.Reflection;

#endregion

namespace Catalog.Api;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddApiServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services.AddCarter();

        // HealthChecks
        {
            var dbype = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DbType}"];
            var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];

            switch (dbype)
            {
                case DatabaseType.SqlServer:
                    services.AddHealthChecks()
                        .AddSqlServer(connectionString: conn!);
                    break;
                case DatabaseType.MySql:
                    services.AddHealthChecks()
                        .AddMySql(connectionString: conn!);
                    break;
                case DatabaseType.PostgreSql:
                    services.AddHealthChecks()
                        .AddNpgSql(connectionString: conn!);
                    break;
                default:
                    throw new Exception("Unsupported database type");
            }
        }

        services.AddHttpContextAccessor();
        services.AddAuthenticationAndAuthorization(cfg);
        services.AddSwaggerServices(cfg);

        // Register all AutoMapper profiles from the current assembly
        services.AddAutoMapper(Assembly.GetExecutingAssembly());

        return services;
    }

    public static WebApplication UseApi(this WebApplication app)
    {
        app.UseSerilogReqLogging();
        app.UsePrometheusEndpoint();
        app.MapCarter();
        app.UseExceptionHandler(options => { });
        app.UseHealthChecks("/health",
            new HealthCheckOptions
            {
                ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
            });

        app.UseAuthentication();
        app.UseAuthorization();
        app.UseSwaggerApi();

        app.MapGet("/", (IWebHostEnvironment env) => new ApiDefaultPathResponse
        {
            Service = "Catalog.Api",
            Status = "Running",
            Timestamp = DateTimeOffset.UtcNow,
            Environment = env.EnvironmentName,
            Endpoints = new Dictionary<string, string>
            {
                { "health", "/health" }
            },
            Message = "API is running..."
        });

        return app;
    }

    #endregion

}
</file>

<file path="Services/Catalog/Api/Catalog.Api/GlobalUsing.cs">
global using Carter;
global using MediatR;
global using Common.ValueObjects;
global using Common.Models.Reponses;
</file>

<file path="Services/Catalog/Api/Catalog.Api/Program.cs">
#region using

using Catalog.Api;
using Catalog.Application;
using Catalog.Infrastructure;

#endregion

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddApiServices(builder.Configuration);

var app = builder.Build();

// Configure the HTTP request pipeline.
app.UseApi();
app.UseInfrastructure();

app.Run();
</file>

<file path="Services/Catalog/Api/Catalog.Grpc/Interceptors/ApiKeyValidationInterceptor.cs">
#region using

using Common.Configurations;
using Common.Constants;
using Grpc.Core;
using Grpc.Core.Interceptors;

#endregion

namespace Catalog.Grpc.Interceptors;

public class ApiKeyValidationInterceptor(IConfiguration cfg) : Interceptor
{
    #region Methods

    public override async Task<TResponse> UnaryServerHandler<TRequest, TResponse>(
        TRequest request,
        ServerCallContext context,
        UnaryServerMethod<TRequest, TResponse> continuation)
    {
        var provided = context.RequestHeaders.FirstOrDefault(h => h.Key == ReqHeaderName.GrpcKey)?.Value;
        var grpcKey = cfg.GetValue<string>($"{AppConfigCfg.Section}:{AppConfigCfg.GrpcApiKey}");

        if (string.IsNullOrEmpty(provided) || !TimeConstantEquals(provided, grpcKey!))
        {
            throw new RpcException(new Status(StatusCode.Unauthenticated, MessageCode.Unauthorized));
        }

        return await continuation(request, context);
    }

    // Constant-time comparison to mitigate timing attacks (micro-optimization).
    private static bool TimeConstantEquals(string a, string b)
    {
        if (a.Length != b.Length) return false;
        var diff = 0;
        for (int i = 0; i < a.Length; i++)
            diff |= a[i] ^ b[i];
        return diff == 0;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Grpc/Services/CatalogGrpcService.cs">
#region using

using Catalog.Application.Features.Product.Queries;
using Catalog.Application.Models.Filters;
using Grpc.Core;
using MediatR;

#endregion

namespace Catalog.Grpc.Services;

public sealed class CatalogGrpcService(ISender sender) : CatalogGrpc.CatalogGrpcBase
{
    #region Methods

    public override async Task<GetProductByIdResponse> GetProductById(GetProductByIdRequest request, ServerCallContext context)
    {
        var result = await sender.Send(new GetProductByIdQuery(Guid.Parse(request.Id)));
        var response = new GetProductByIdResponse
        {
            Product = new Product
            {
                Id = result.Product.Id.ToString(),
                Name = result.Product.Name,
                Thumbnail = result.Product.Thumbnail?.PublicURL,
                Price = result.Product.SalePrice != null ? (double)result.Product.SalePrice : (double)result.Product.Price
            }
        };
        return response;
    }

    public override async Task<GetProductsResponse> GetProducts(GetProductsRequest request, ServerCallContext context)
    {
        var filter = new GetAllProductsFilter(request.SearchText, request.Ids?.Select(Guid.Parse).ToArray() ?? Array.Empty<Guid>());
        var query = new GetAllProductsQuery(filter);
        var result = await sender.Send(query);

        var response = new GetProductsResponse();

        if (result.Items != null)
        {
            response.Products.AddRange(result.Items.Select(p => new Product
            {
                Id = p.Id.ToString(),
                Name = p.Name ?? string.Empty,
                Thumbnail = p.Thumbnail?.PublicURL!,
                Price = p.SalePrice != null ? (double)p.SalePrice : (double)p.Price
            }));
        }

        return response;
    }

    public override async Task<GetCountProductResponse> GetCountProduct(GetCountProductRequest request, ServerCallContext context)
    {
        var query = new GetCountProductQuery();
        var result = await sender.Send(query);
        var response = new GetCountProductResponse
        {
            Count = result.Count
        };
        return response;
    }

    public override async Task<GetAllAvailableProductsResponse> GetAllAvailableProducts(GetAllAvailableProductsRequest request, ServerCallContext context)
    {
        var filter = new GetAllProductsFilter(request.SearchText, request.Ids?.Select(Guid.Parse).ToArray() ?? Array.Empty<Guid>());
        var query = new GetAllAvailableProductsQuery(filter);
        var result = await sender.Send(query);

        var response = new GetAllAvailableProductsResponse();

        if (result.Items != null)
        {
            response.Products.AddRange(result.Items.Select(p => new Product
            {
                Id = p.Id.ToString(),
                Name = p.Name ?? string.Empty,
                Thumbnail = p.Thumbnail?.PublicURL!,
                Price = p.SalePrice != null ? (double)p.SalePrice : (double)p.Price
            }));
        }

        return response;
    }
    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Grpc/Catalog.Grpc.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <ItemGroup>
    <Protobuf Include="..\..\..\..\Shared\Contracts\Catalog.Contract\Protos\catalog.proto" GrpcServices="Server" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="grpc.tools">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="microsoft.aspnetcore.grpc.jsontranscoding" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Contracts\Catalog.Contract\Catalog.Contract.csproj" />
    <ProjectReference Include="..\..\Core\Catalog.Application\Catalog.Application.csproj" />
    <ProjectReference Include="..\..\Core\Catalog.Infrastructure\Catalog.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Catalog/Api/Catalog.Grpc/DependencyInjection.cs">
#region using

using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using Catalog.Grpc.Interceptors;

#endregion

namespace Catalog.Grpc;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddGrpcServices(
       this IServiceCollection services,
       IConfiguration cfg)
    {
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services
            .AddGrpc(o =>
            {
                o.Interceptors.Add<ApiKeyValidationInterceptor>();
            })
            .AddJsonTranscoding();
        services.AddSingleton<ApiKeyValidationInterceptor>();

        return services;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Api/Catalog.Grpc/Program.cs">
#region using

using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using Catalog.Application;
using Catalog.Grpc;
using Catalog.Grpc.Services;
using Catalog.Infrastructure;

#endregion

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddGrpcServices(builder.Configuration);

var app = builder.Build();

app.UseSerilogReqLogging();
app.UsePrometheusEndpoint();

app.MapGrpcService<CatalogGrpcService>();
app.MapGet("/", () => "Catalog gRPC is running...");

app.Run();
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Abstractions/AuditableDto.cs">
namespace Catalog.Application.Dtos.Abstractions;

public abstract class AuditableDto : IAuditableDto
{
    #region Fields, Properties and Indexers

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}

public interface IAuditableDto : ICreationAuditDto, IModificationAuditDto { }
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Abstractions/DtoId.cs">
namespace Catalog.Application.Dtos.Abstractions;

public class DtoId<T> : IDtoId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    #endregion
}

public interface IDtoId<T>
{
    T Id { get; init; }
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Abstractions/EntityDto.cs">
namespace Catalog.Application.Dtos.Abstractions;

public abstract class EntityDto<T> : IDtoId<T>, IAuditableDto
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Abstractions/ICreationAuditDto.cs">
namespace Catalog.Application.Dtos.Abstractions;

public interface ICreationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Abstractions/IModificationAuditDto.cs">
namespace Catalog.Application.Dtos.Abstractions;

public interface IModificationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Brands/BrandDto.cs">
#region using

using Catalog.Application.Dtos.Abstractions;

#endregion

namespace Catalog.Application.Dtos.Brands;

public class BrandDto : DtoId<Guid>
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    public string? Slug { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Brands/CreateBrandDto.cs">
namespace Catalog.Application.Dtos.Brands;

public class CreateBrandDto
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Brands/UpdateBrandDto.cs">
namespace Catalog.Application.Dtos.Brands;

public class UpdateBrandDto
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Categories/CategoryDto.cs">
#region using

using Catalog.Application.Dtos.Abstractions;

#endregion

namespace Catalog.Application.Dtos.Categories;

public class CategoryDto : DtoId<Guid>
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    public string? Description { get; set; }

    public string? Slug { get; set; }

    public Guid? ParentId { get; set; }

    public string? ParentName { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Categories/CategoryTreeItemDto.cs">
#region using

using Catalog.Application.Dtos.Abstractions;

#endregion

namespace Catalog.Application.Dtos.Categories;

public class CategoryTreeItemDto : DtoId<Guid>
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    public string? Description { get; set; }

    public string? Slug { get; set; }

    public Guid? ParentId { get; set; }

    public bool HasChildren => Children?.Count > 0;

    public List<CategoryTreeItemDto>? Children { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Categories/CreateCategoryDto.cs">
namespace Catalog.Application.Dtos.Categories;

public class CreateCategoryDto
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    public string? Description { get; set; }

    public Guid? ParentId { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Categories/UpdateCategoryDto.cs">
namespace Catalog.Application.Dtos.Categories;

public class UpdateCategoryDto
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    public string? Description { get; set; }

    public Guid? ParentId { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Products/CreateProductDto.cs">
namespace Catalog.Application.Dtos.Products;

public class CreateProductDto
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    public string? Sku { get; set; }

    public string? ShortDescription { get; set; }

    public string? LongDescription { get; set; }

    public decimal Price { get; set; }

    public decimal? SalePrice { get; set; }

    public List<Guid>? CategoryIds { get; set; }

    public List<UploadFileBytes>? UploadImages { get; set; }

    public UploadFileBytes? UploadThumbnail { get; set; }

    public Guid? BrandId { get; set; }

    public List<string>? Colors { get; set; }

    public List<string>? Sizes { get; set; }

    public List<string>? Tags { get; set; }

    public bool Published { get; set; }

    public bool Featured { get; set; }

    public string? SEOTitle { get; set; }

    public string? SEODescription { get; set; }

    public string? Barcode { get; set; }

    public string? Unit { get; set; }

    public decimal? Weight { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Products/ProductDto.cs">
#region using

using Catalog.Application.Dtos.Abstractions;

#endregion

namespace Catalog.Application.Dtos.Products;

public class ProductDto : ProductInfoDto, IAuditableDto
{
    #region Fields, Properties and Indexers

    public string? Barcode { get; set; }

    public ProductImageDto? Thumbnail { get; set; }

    public List<ProductImageDto>? Images { get; set; }

    public List<Guid>? CategoryIds { get; set; }

    public Guid? BrandId { get; set; }

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Products/ProductImageDto.cs">
namespace Catalog.Application.Dtos.Products;

public class ProductImageDto
{
    #region Fields, Properties and Indexers

    public string? FileId { get; set; }

    public string? OriginalFileName { get; set; }

    public string? FileName { get; set; }

    public string? PublicURL { get; set; }

    #endregion
}

public class PublishProductImageDto
{
    #region Fields, Properties and Indexers

    public string? FileName { get; set; }

    public string? PublicURL { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Products/ProductInfoDto.cs">
#region using

using Catalog.Application.Dtos.Abstractions;
using Catalog.Domain.Enums;

#endregion

namespace Catalog.Application.Dtos.Products;

public class ProductInfoDto : DtoId<Guid>
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    public string? Sku { get; set; }

    public string? ShortDescription { get; set; }

    public string? LongDescription { get; set; }

    public string? Slug { get; set; }

    public decimal Price { get; set; }

    public decimal? SalePrice { get; set; }

    public List<string>? CategoryNames { get; set; }

    public ProductStatus Status { get; set; }

    public string DisplayStatus { get; set; } = default!;

    public List<string>? Colors { get; set; }

    public List<string>? Sizes { get; set; }

    public List<string>? Tags { get; set; }

    public bool Published { get; set; }

    public bool Featured { get; set; }

    public string? BrandName { get; set; }

    public string? SEOTitle { get; set; }

    public string? SEODescription { get; set; }

    public string? Unit { get; set; }

    public decimal? Weight { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Products/PublishProductDto.cs">
namespace Catalog.Application.Dtos.Products;

public class PublishProductDto : ProductInfoDto
{
    #region Fields, Properties and Indexers

    public PublishProductImageDto? Thumbnail { get; set; }

    public List<PublishProductImageDto>? Images { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Dtos/Products/UpdateProductDto.cs">
#region using

#endregion

namespace Catalog.Application.Dtos.Products;

public class UpdateProductDto
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    public string? Sku { get; set; }

    public string? ShortDescription { get; set; }

    public string? LongDescription { get; set; }

    public decimal Price { get; set; }

    public decimal? SalePrice { get; set; }

    public List<Guid>? CategoryIds { get; set; }

    public List<string>? CurrentImageUrls { get; set; }

    public List<UploadFileBytes>? UploadImages { get; set; }

    public UploadFileBytes? UploadThumbnail { get; set; }

    public string? CurrentThumbnailUrl { get; set; }

    public Guid? BrandId { get; set; }

    public List<string>? Colors { get; set; }

    public List<string>? Sizes { get; set; }

    public List<string>? Tags { get; set; }

    public bool Published { get; set; }

    public bool Featured { get; set; }

    public string? SEOTitle { get; set; }

    public string? SEODescription { get; set; }

    public string? Barcode { get; set; }

    public string? Unit { get; set; }

    public decimal? Weight { get; set; }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Exceptions/ApplicationException.cs">
namespace Catalog.Application.Exceptions;

public sealed class ApplicationException : Exception
{
    #region Ctors

    public ApplicationException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Brand/Commands/CreateBrandCommand.cs">
#region using

using Catalog.Application.Dtos.Brands;
using Catalog.Domain.Entities;
using Marten;

#endregion

namespace Catalog.Application.Features.Brand.Commands;

public record CreateBrandCommand(CreateBrandDto Dto, Actor Actor) : ICommand<Guid>;

public class CreateBrandCommandValidator : AbstractValidator<CreateBrandCommand>
{
    #region Ctors

    public CreateBrandCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Name)
                    .NotEmpty()
                    .WithMessage(MessageCode.BrandNameIsRequired);
            });
    }

    #endregion
}

public class CreateBrandCommandHandler(IDocumentSession session) : ICommandHandler<CreateBrandCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(CreateBrandCommand command, CancellationToken cancellationToken)
    {
        var dto = command.Dto;

        await session.BeginTransactionAsync(cancellationToken);

        var entity = BrandEntity.Create(
            id: Guid.NewGuid(),
            name: dto.Name!,
            slug: dto.Name!.Slugify(),
            performedBy: command.Actor.ToString());

        session.Store(entity);
        await session.SaveChangesAsync(cancellationToken);

        return entity.Id;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Brand/Commands/DeleteBrandCommand.cs">
#region using

using Catalog.Domain.Entities;
using Marten;
using MediatR;

#endregion

namespace Catalog.Application.Features.Brand.Commands;

public record DeleteBrandCommand(Guid BrandId) : ICommand<Unit>;

public class DeleteBrandCommandValidator : AbstractValidator<DeleteBrandCommand>
{
    #region Ctors

    public DeleteBrandCommandValidator()
    {
        RuleFor(x => x.BrandId)
            .NotEmpty()
            .WithMessage(MessageCode.BrandIdIsRequired);
    }

    #endregion
}

public class DeleteBrandCommandHandler(IDocumentSession session) : ICommandHandler<DeleteBrandCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(DeleteBrandCommand command, CancellationToken cancellationToken)
    {
        var brand = await session.LoadAsync<BrandEntity>(command.BrandId, cancellationToken)
            ?? throw new ClientValidationException(MessageCode.BrandIsNotExists, command.BrandId.ToString());

        session.Delete<BrandEntity>(brand.Id);
        await session.SaveChangesAsync(cancellationToken);

        return Unit.Value;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Brand/Commands/UpdateBrandCommand.cs">
#region using

using Catalog.Application.Dtos.Brands;
using Catalog.Domain.Entities;
using Marten;

#endregion

namespace Catalog.Application.Features.Brand.Commands;

public record UpdateBrandCommand(Guid BrandId, UpdateBrandDto Dto, Actor Actor) : ICommand<Guid>;

public class UpdateBrandCommandValidator : AbstractValidator<UpdateBrandCommand>
{
    #region Ctors

    public UpdateBrandCommandValidator()
    {
        RuleFor(x => x.BrandId)
            .NotEmpty()
            .WithMessage(MessageCode.BrandIdIsRequired);

        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Name)
                    .NotEmpty()
                    .WithMessage(MessageCode.BrandNameIsRequired);
            });
    }

    #endregion
}

public class UpdateBrandCommandHandler(IDocumentSession session) : ICommandHandler<UpdateBrandCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(UpdateBrandCommand command, CancellationToken cancellationToken)
    {
        await session.BeginTransactionAsync(cancellationToken);

        var entity = await session.LoadAsync<BrandEntity>(command.BrandId, cancellationToken)
            ?? throw new ClientValidationException(MessageCode.BrandIsNotExists, command.BrandId);

        var dto = command.Dto;

        entity.Update(
            name: dto.Name!,
            slug: dto.Name!.Slugify(),
            performedBy: command.Actor.ToString());

        session.Store(entity);
        await session.SaveChangesAsync(cancellationToken);

        return entity.Id;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Brand/Queries/GetAllBrandsQuery.cs">
#region using

using AutoMapper;
using Catalog.Application.Dtos.Brands;
using Catalog.Application.Models.Results;
using Catalog.Domain.Entities;
using Marten;

#endregion

namespace Catalog.Application.Features.Brand.Queries;

public sealed record GetAllBrandsQuery : IQuery<GetAllBrandsResult>;

public sealed class GetAllBrandsQueryHandler(IDocumentSession session, IMapper mapper)
    : IQueryHandler<GetAllBrandsQuery, GetAllBrandsResult>
{
    #region Implementations

    public async Task<GetAllBrandsResult> Handle(GetAllBrandsQuery query, CancellationToken cancellationToken)
    {
        var result = await session.Query<BrandEntity>()
            .OrderByDescending(x => x.CreatedOnUtc)
            .ToListAsync(token: cancellationToken);

        var response = new GetAllBrandsResult(mapper.Map<List<BrandDto>>(result));

        return response;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Category/Commands/CreateCategoryCommand.cs">
#region using

using Catalog.Application.Dtos.Categories;
using Catalog.Domain.Entities;
using Marten;
using Microsoft.EntityFrameworkCore;

#endregion

namespace Catalog.Application.Features.Category.Commands;

public record CreateCategoryCommand(CreateCategoryDto Dto, Actor Actor) : ICommand<Guid>;

public class CreateCategoryCommandValidator : AbstractValidator<CreateCategoryCommand>
{
    #region Ctors

    public CreateCategoryCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Name)
                    .NotEmpty()
                    .WithMessage(MessageCode.CategoryNameIsRequired);
            });
    }

    #endregion
}

public class CreateCategoryCommandHandler(IDocumentSession session) : ICommandHandler<CreateCategoryCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(CreateCategoryCommand command, CancellationToken cancellationToken)
    {
        var dto = command.Dto;

        await session.BeginTransactionAsync(cancellationToken);

        // Validate ParentId if provided
        if (dto.ParentId.HasValue)
        {
            var parentExists = await session.Query<CategoryEntity>()
                .AnyAsync(x => x.Id == dto.ParentId.Value, token: cancellationToken);

            if (!parentExists)
            {
                throw new ClientValidationException(MessageCode.CategoryIsNotExists, dto.ParentId.Value);
            }
        }

        var entity = CategoryEntity.Create(
            id: Guid.NewGuid(),
            name: dto.Name!,
            desctiption: dto.Description ?? string.Empty,
            slug: dto.Name!.Slugify(),
            performedBy: command.Actor.ToString(),
            parentId: dto.ParentId);

        session.Store(entity);
        await session.SaveChangesAsync(cancellationToken);

        return entity.Id;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Category/Commands/DeleteCategoryCommand.cs">
#region using

using Catalog.Domain.Entities;
using Marten;
using MediatR;
using Microsoft.EntityFrameworkCore;

#endregion

namespace Catalog.Application.Features.Category.Commands;

public record DeleteCategoryCommand(Guid CategoryId) : ICommand<Unit>;

public class DeleteCategoryCommandValidator : AbstractValidator<DeleteCategoryCommand>
{
    #region Ctors

    public DeleteCategoryCommandValidator()
    {
        RuleFor(x => x.CategoryId)
            .NotEmpty()
            .WithMessage(MessageCode.CategoryIdIsRequired);
    }

    #endregion
}

public class DeleteCategoryCommandHandler(IDocumentSession session) : ICommandHandler<DeleteCategoryCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(DeleteCategoryCommand command, CancellationToken cancellationToken)
    {
        var category = await session.LoadAsync<CategoryEntity>(command.CategoryId, cancellationToken)
            ?? throw new ClientValidationException(MessageCode.CategoryIsNotExists, command.CategoryId.ToString());

        // Check if category has children
        var hasChildren = await session.Query<CategoryEntity>()
            .AnyAsync(x => x.ParentId == command.CategoryId, token: cancellationToken);

        if (hasChildren)
        {
            throw new ClientValidationException(MessageCode.CategoryHasChildren);
        }

        session.Delete<CategoryEntity>(category.Id);
        await session.SaveChangesAsync(cancellationToken);

        return Unit.Value;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Category/Commands/UpdateCategoryCommand.cs">
#region using

using Catalog.Application.Dtos.Categories;
using Catalog.Domain.Entities;
using Marten;
using Microsoft.EntityFrameworkCore;

#endregion

namespace Catalog.Application.Features.Category.Commands;

public record UpdateCategoryCommand(Guid CategoryId, UpdateCategoryDto Dto, Actor Actor) : ICommand<Guid>;

public class UpdateCategoryCommandValidator : AbstractValidator<UpdateCategoryCommand>
{
    #region Ctors

    public UpdateCategoryCommandValidator()
    {
        RuleFor(x => x.CategoryId)
            .NotEmpty()
            .WithMessage(MessageCode.CategoryIdIsRequired);

        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Name)
                    .NotEmpty()
                    .WithMessage(MessageCode.CategoryNameIsRequired);
            });
    }

    #endregion
}

public class UpdateCategoryCommandHandler(IDocumentSession session) : ICommandHandler<UpdateCategoryCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(UpdateCategoryCommand command, CancellationToken cancellationToken)
    {
        await session.BeginTransactionAsync(cancellationToken);

        var entity = await session.LoadAsync<CategoryEntity>(command.CategoryId, cancellationToken)
            ?? throw new ClientValidationException(MessageCode.CategoryIsNotExists, command.CategoryId);

        var dto = command.Dto;

        // Validate ParentId if provided
        if (dto.ParentId.HasValue)
        {
            // Cannot set parent to itself
            if (dto.ParentId.Value == command.CategoryId)
            {
                throw new ClientValidationException(MessageCode.CategoryCannotBeItsOwnParent);
            }

            var parentExists = await session.Query<CategoryEntity>()
                .AnyAsync(x => x.Id == dto.ParentId.Value, token: cancellationToken);

            if (!parentExists)
            {
                throw new ClientValidationException(MessageCode.CategoryIsNotExists, dto.ParentId.Value);
            }
        }

        entity.Update(
            name: dto.Name!,
            desciption: dto.Description ?? string.Empty,
            slug: dto.Name!.Slugify(),
            performedBy: command.Actor.ToString(),
            parentId: dto.ParentId);

        session.Store(entity);
        await session.SaveChangesAsync(cancellationToken);

        return entity.Id;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Category/Queries/GetAllCategoriesQuery.cs">
#region using

using AutoMapper;
using Catalog.Application.Dtos.Categories;
using Catalog.Application.Models.Filters;
using Catalog.Application.Models.Results;
using Catalog.Domain.Entities;
using Marten;
using Microsoft.EntityFrameworkCore;

#endregion

namespace Catalog.Application.Features.Category.Queries;

public sealed record GetAllCategoriesQuery(GetAllCategoriesFilter Filter) : IQuery<GetAllCategoriesResult>;

public sealed class GetAllCategoriesQueryHandler(IDocumentSession session, IMapper mapper)
    : IQueryHandler<GetAllCategoriesQuery, GetAllCategoriesResult>
{
    #region Implementations

    public async Task<GetAllCategoriesResult> Handle(GetAllCategoriesQuery query, CancellationToken cancellationToken)
    {
        var filter = query.Filter;
        var result = await session.Query<CategoryEntity>()
            .Where(x => filter.ParentId == null || x.ParentId == filter.ParentId)
            .OrderByDescending(x => x.CreatedOnUtc)
            .ToListAsync(token: cancellationToken);

        var categories = mapper.Map<List<CategoryDto>>(result);

        foreach (var item in categories)
        {
            if (!item.ParentId.HasValue) continue;

            var parrent = categories.FirstOrDefault(x => x.Id == item.ParentId.Value);

            if (parrent == null) continue;

            item.ParentName = parrent.Name;
        }

        var response = new GetAllCategoriesResult(categories);

        return response;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Category/Queries/GetTreeCategoriesQuery.cs">
#region using

using Catalog.Application.Dtos.Categories;
using Catalog.Application.Models.Results;
using Catalog.Domain.Entities;
using Marten;
using Microsoft.EntityFrameworkCore;

#endregion
namespace Catalog.Application.Features.Category.Queries;

public sealed record GetTreeCategoriesQuery : IQuery<GetTreeCategoriesResult>;

public sealed class GetTreeCategoriesQueryHandler(IDocumentSession session)
    : IQueryHandler<GetTreeCategoriesQuery, GetTreeCategoriesResult>
{
    #region Implementations

    public async Task<GetTreeCategoriesResult> Handle(GetTreeCategoriesQuery query, CancellationToken cancellationToken)
    {
        var flat = await session.Query<CategoryEntity>()
            .Select(x => new CategoryTreeItemDto
            {
                Id = x.Id,
                Name = x.Name,
                Description = x.Description,
                Slug = x.Slug,
                ParentId = x.ParentId
            })
            .ToListAsync(token: cancellationToken);

        var byId = flat.ToDictionary(x => x.Id);
        var roots = new List<CategoryTreeItemDto>(capacity: flat.Count);

        foreach (var node in flat)
        {
            if (node.ParentId is { } pid && pid != node.Id && byId.TryGetValue(pid, out var parent))
            {
                parent.Children ??= [];
                parent.Children.Add(node);
            }
            else
            {
                roots.Add(node);
            }
        }

        var response = new GetTreeCategoriesResult(roots);

        return response;
    }

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/Commands/ChangeProductStatusCommand.cs">
#region using

using Catalog.Domain.Entities;
using Catalog.Domain.Enums;
using Catalog.Domain.Events;
using Marten;
using MediatR;

#endregion

namespace Catalog.Application.Features.Product.Commands;

public record ChangeProductStatusCommand(Guid ProductId, ProductStatus Status, Actor Actor) : ICommand<Guid>;

public class ChangeProductStatusCommandValidator : AbstractValidator<ChangeProductStatusCommand>
{
    #region Ctors

    public ChangeProductStatusCommandValidator()
    {
        RuleFor(x => x.ProductId)
            .NotEmpty()
            .WithMessage(MessageCode.ProductIdIsRequired);

        RuleFor(x => x.Status)
            .Must(status => Enum.IsDefined(typeof(ProductStatus), status))
            .WithMessage(MessageCode.StatusIsRequired);
    }

    #endregion
}

public class ChangeProductStatusCommandHandler(IDocumentSession session, IMediator mediator) : ICommandHandler<ChangeProductStatusCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(ChangeProductStatusCommand command, CancellationToken cancellationToken)
    {
        await session.BeginTransactionAsync(cancellationToken);

        var entity = await session.LoadAsync<ProductEntity>(command.ProductId)
            ?? throw new ClientValidationException(MessageCode.ProductIsNotExists, command.ProductId);

        entity.ChangeStatus(command.Status, command.Actor.ToString());
        session.Store(entity);

        var @event = new UpsertedProductDomainEvent(
            entity.Id,
            entity.Name!,
            entity.Sku!,
            entity.Slug!,
            entity.Price,
            entity.SalePrice,
            entity.CategoryIds?.Select(id => id.ToString()).ToList(),
            entity.Images?.Select(img => img.PublicURL).Where(url => !string.IsNullOrWhiteSpace(url)).Cast<string>().ToList(),
            entity.Thumbnail?.PublicURL!,
            entity.Status,
            entity.CreatedOnUtc,
            entity.CreatedBy!,
            entity.LastModifiedOnUtc,
            entity.LastModifiedBy);

        await mediator.Publish(@event, cancellationToken);
        await session.SaveChangesAsync(cancellationToken);

        return entity.Id;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/Commands/CreateProductCommand.cs">
#region using

using AutoMapper;
using Catalog.Application.Dtos.Products;
using Catalog.Application.Services;
using Catalog.Domain.Entities;
using Marten;
using MediatR;

#endregion

namespace Catalog.Application.Features.Product.Commands;

public record CreateProductCommand(CreateProductDto Dto, Actor Actor) : ICommand<Guid>;

public class CreateProductCommandValidator : AbstractValidator<CreateProductCommand>
{
    #region Ctors

    public CreateProductCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Name)
                    .NotEmpty()
                    .WithMessage(MessageCode.ProductNameIsRequired);

                RuleFor(x => x.Dto.Sku)
                    .NotEmpty()
                    .WithMessage(MessageCode.SkuIsRequired);

                RuleFor(x => x.Dto.ShortDescription)
                    .NotEmpty()
                    .WithMessage(MessageCode.ShortDescriptionIsRequired);

                RuleFor(x => x.Dto.LongDescription)
                    .NotEmpty()
                    .WithMessage(MessageCode.LongDescriptionIsRequired);

                RuleFor(x => x.Dto.Price)
                    .NotEmpty()
                    .WithMessage(MessageCode.PriceIsRequired)
                    .GreaterThan(1)
                    .WithMessage(MessageCode.PriceIsRequired);

                RuleFor(x => x.Dto.UploadThumbnail)
                    .NotNull()
                    .WithMessage(MessageCode.ThumbnailIsRequired);
            });

    }

    #endregion
}

public class CreateProductCommandHandler(IMapper mapper,
    IDocumentSession session,
    IMinIOCloudService minIO,
    ISender sender) : ICommandHandler<CreateProductCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(CreateProductCommand command, CancellationToken cancellationToken)
    {
        var dto = command.Dto;

        await session.BeginTransactionAsync(cancellationToken);

        await ValidateCategoryAsync(dto.CategoryIds, cancellationToken);
        await ValidateBrandAsync(dto.BrandId, cancellationToken);

        var entity = ProductEntity.Create(
            id: Guid.NewGuid(),
            name: dto.Name!,
            sku: dto.Sku!,
            slug: dto.Name!.Slugify(),
            shortDescription: dto.ShortDescription!,
            longDescription: dto.LongDescription!,
            price: dto.Price,
            salePrice: dto.SalePrice,
            categoryIds: dto.CategoryIds?.Distinct().ToList(),
            brandId: dto.BrandId,
            performedBy: command.Actor.ToString());

        await UploadImagesAsync(dto.UploadImages, entity, cancellationToken);
        await UploadThumbnailAsync(dto.UploadThumbnail, entity, cancellationToken);

        entity.UpdateColors(dto.Colors?.Distinct().ToList(), command.Actor.ToString());
        entity.UpdateSizes(dto.Sizes?.Distinct().ToList(), command.Actor.ToString());
        entity.UpdateTags(dto.Tags?.Distinct().ToList(), command.Actor.ToString());
        entity.UpdateSEO(dto.SEOTitle, dto.SEODescription, command.Actor.ToString());
        entity.UpdateFeatured(dto.Featured, command.Actor.ToString());
        entity.UpdateBarcode(dto.Barcode, command.Actor.ToString());
        entity.UpdateUnitAndWeight(dto.Unit, dto.Weight, command.Actor.ToString());

        if (command.Dto.Published)
        {
            entity.Publish(command.Actor.ToString());
        }

        session.Store(entity);

        await session.SaveChangesAsync(cancellationToken);

        if (entity.Published)
        {
            await sender.Send(new PublishProductCommand(entity.Id, command.Actor), cancellationToken);
        }

        return entity.Id;
    }

    #endregion

    #region Methods

    private async Task UploadThumbnailAsync(UploadFileBytes? image, ProductEntity entity, CancellationToken cancellationToken)
    {
        var result = await minIO.UploadFilesAsync([image!], AppConstants.Bucket.Products, true, cancellationToken);
        var thumbnail = result.FirstOrDefault();
        entity.AddOrUpdateThumbnail(mapper.Map<ProductImageEntity>(thumbnail));
    }

    private async Task UploadImagesAsync(
        List<UploadFileBytes>? filesDto,
        ProductEntity entity,
        CancellationToken cancellationToken)
    {
        if (filesDto != null && filesDto.Any())
        {
            var result = await minIO.UploadFilesAsync(filesDto, AppConstants.Bucket.Products, true, cancellationToken);
            entity.AddOrUpdateImages(mapper.Map<List<ProductImageEntity>>(result));
        }
    }

    private async Task ValidateCategoryAsync(List<Guid>? inputCategoryIds, CancellationToken cancellationToken = default)
    {
        if (inputCategoryIds is { Count: > 0 })
        {
            var categories = await session.Query<CategoryEntity>().ToListAsync(token: cancellationToken);

            var existingIds = categories.Select(c => c.Id).ToHashSet();
            var invalidIds = inputCategoryIds.Where(id => !existingIds.Contains(id)).ToList();

            if (invalidIds.Any())
            {
                throw new ClientValidationException(MessageCode.CategoryIsNotExists, string.Join(", ", invalidIds));
            }
        }
    }

    private async Task ValidateBrandAsync(Guid? brandId, CancellationToken cancellationToken = default)
    {
        if (brandId.HasValue)
        {
            var brands = await session.Query<BrandEntity>().ToListAsync(token: cancellationToken);
            var existingIds = brands.Select(b => b.Id).ToHashSet();
            if (!existingIds.Contains(brandId.Value))
            {
                throw new ClientValidationException(MessageCode.BrandIsNotExists, brandId);
            }
        }
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/Commands/DeleteProductCommand.cs">
#region using

using Catalog.Domain.Entities;
using Catalog.Domain.Events;
using Marten;
using MediatR;

#endregion

namespace Catalog.Application.Features.Product.Commands;

public record DeleteProductCommand(Guid ProductId) : ICommand<Unit>;

public class DeleteProductCommandValidator : AbstractValidator<DeleteProductCommand>
{
    #region Ctors

    public DeleteProductCommandValidator()
    {
        RuleFor(x => x.ProductId)
            .NotEmpty()
            .WithMessage(MessageCode.ProductIdIsRequired);
    }

    #endregion
}

public class DeleteProductCommandHandler(IDocumentSession session, IMediator mediator) : ICommandHandler<DeleteProductCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(DeleteProductCommand command, CancellationToken cancellationToken)
    {
        var product = await session.LoadAsync<ProductEntity>(command.ProductId)
            ?? throw new ClientValidationException(MessageCode.ProductIsNotExists, command.ProductId.ToString());

        session.Delete<ProductEntity>(product.Id);

        var @event = new DeletedUnPublishedProductDomainEvent(product.Id);

        await mediator.Publish(@event, cancellationToken);
        await session.SaveChangesAsync(cancellationToken);

        return Unit.Value;
    }

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/Commands/PublishProductCommand.cs">
#region using

using Catalog.Domain.Entities;
using Catalog.Domain.Events;
using Marten;
using MediatR;

#endregion

namespace Catalog.Application.Features.Product.Commands;

public record PublishProductCommand(Guid ProductId, Actor Actor) : ICommand<Guid>;

public class PublishProductCommandValidator : AbstractValidator<PublishProductCommand>
{
    #region Ctors

    public PublishProductCommandValidator()
    {
        RuleFor(x => x.ProductId)
            .NotEmpty()
            .WithMessage(MessageCode.ProductIdIsRequired);

        //RuleFor(x => x.Status)
        //    .IsInEnum()
        //    .Must(status => Enum.IsDefined(typeof(ProductStatus), status))
        //    .WithMessage(MessageCode.StatusIsInvalid);
    }

    #endregion
}

public class PublishProductCommandHandler(IDocumentSession session, IMediator mediator) : ICommandHandler<PublishProductCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(PublishProductCommand command, CancellationToken cancellationToken)
    {
        await session.BeginTransactionAsync(cancellationToken);

        var entity = await session.LoadAsync<ProductEntity>(command.ProductId, cancellationToken)
                ?? throw new ClientValidationException(MessageCode.ProductIsNotExists, command.ProductId);

        entity.Publish(command.Actor.ToString());
        session.Store(entity);

        var @event = new UpsertedProductDomainEvent(
            entity.Id,
            entity.Name!,
            entity.Sku!,
            entity.Slug!,
            entity.Price,
            entity.SalePrice,
            entity.CategoryIds?.Select(id => id.ToString()).ToList(),
            entity.Images?.Select(img => img.PublicURL).Where(url => !string.IsNullOrWhiteSpace(url)).Cast<string>().ToList(),
            entity.Thumbnail?.PublicURL!,
            entity.Status,
            entity.CreatedOnUtc,
            entity.CreatedBy!,
            entity.LastModifiedOnUtc,
            entity.LastModifiedBy);

        await mediator.Publish(@event, cancellationToken);
        await session.SaveChangesAsync(cancellationToken);

        return entity.Id;
    }

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/Commands/UnpublishProductCommand.cs">
#region using

using Catalog.Domain.Entities;
using Catalog.Domain.Events;
using Marten;
using MediatR;

#endregion

namespace Catalog.Application.Features.Product.Commands;

public record UnpublishProductCommand(Guid ProductId, Actor Actor) : ICommand<Guid>;

public class UnpublishProductCommandValidator : AbstractValidator<UnpublishProductCommand>
{
    #region Ctors

    public UnpublishProductCommandValidator()
    {
        RuleFor(x => x.ProductId)
            .NotEmpty()
            .WithMessage(MessageCode.ProductIdIsRequired);

        //RuleFor(x => x.Status)
        //    .IsInEnum()
        //    .Must(status => Enum.IsDefined(typeof(ProductStatus), status))
        //    .WithMessage(MessageCode.StatusIsInvalid);
    }

    #endregion
}

public class UnpublishProductCommandHandler(IDocumentSession session, IMediator mediator) : ICommandHandler<UnpublishProductCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(UnpublishProductCommand command, CancellationToken cancellationToken)
    {
        await session.BeginTransactionAsync(cancellationToken);

        var entity = await session.LoadAsync<ProductEntity>(command.ProductId)
            ?? throw new ClientValidationException(MessageCode.ProductIsNotExists, command.ProductId);

        entity.Unpublish(command.Actor.ToString());
        session.Store(entity);

        var @event = new DeletedUnPublishedProductDomainEvent(entity.Id);

        await mediator.Publish(@event, cancellationToken);
        await session.SaveChangesAsync(cancellationToken);

        return entity.Id;
    }

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/Commands/UpdateProductCommand.cs">
#region using

using AutoMapper;
using Catalog.Application.Dtos.Products;
using Catalog.Application.Services;
using Catalog.Domain.Entities;
using Catalog.Domain.Events;
using Marten;
using MediatR;

#endregion

namespace Catalog.Application.Features.Product.Commands;

public record UpdateProductCommand(Guid ProductId, UpdateProductDto Dto, Actor Actor) : ICommand<Guid>;

public class UpdateProductCommandValidator : AbstractValidator<UpdateProductCommand>
{
    #region Ctors

    public UpdateProductCommandValidator()
    {
        RuleFor(x => x.ProductId)
            .NotEmpty()
            .WithMessage(MessageCode.ProductIdIsRequired);

        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Name)
                    .NotEmpty()
                    .WithMessage(MessageCode.ProductNameIsRequired);

                RuleFor(x => x.Dto.Sku)
                    .NotEmpty()
                    .WithMessage(MessageCode.SkuIsRequired);

                RuleFor(x => x.Dto.ShortDescription)
                    .NotEmpty()
                    .WithMessage(MessageCode.ShortDescriptionIsRequired);

                RuleFor(x => x.Dto.LongDescription)
                    .NotEmpty()
                    .WithMessage(MessageCode.LongDescriptionIsRequired);

                RuleFor(x => x.Dto.Price)
                    .NotEmpty()
                    .WithMessage(MessageCode.PriceIsRequired)
                    .GreaterThan(1)
                    .WithMessage(MessageCode.PriceIsRequired);
            });
    }

    #endregion
}

public class UpdateProductCommandHandler(IMapper mapper,
    IDocumentSession session,
    IMinIOCloudService minIO,
    IMediator mediator,
    ISender sender) : ICommandHandler<UpdateProductCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(UpdateProductCommand command, CancellationToken cancellationToken)
    {
        await session.BeginTransactionAsync(cancellationToken);

        var entity = await session.LoadAsync<ProductEntity>(command.ProductId)
            ?? throw new ClientValidationException(MessageCode.ProductIsNotExists, command.ProductId);

        var currentPublishStatus = entity.Published;
        var dto = command.Dto;

        await ValidateCategoryAsync(dto.CategoryIds, cancellationToken);
        await ValidateBrandAsync(dto.BrandId, cancellationToken);

        entity.Update(name: dto.Name!,
            sku: dto.Sku!,
            slug: dto.Name!.Slugify(),
            shortDescription: dto.ShortDescription!,
            longDescription: dto.LongDescription!,
            price: dto.Price,
            salePrice: dto.SalePrice,
            categoryIds: dto.CategoryIds?.Distinct().ToList(),
            brandId: dto.BrandId,
            performedBy: command.Actor.ToString());

        await UploadImagesAsync(dto.UploadImages, dto.CurrentImageUrls, entity, cancellationToken);
        await UploadThumbnailAsync(dto.UploadThumbnail, entity, cancellationToken);

        entity.UpdateColors(dto.Colors?.Distinct().ToList(), command.Actor.ToString());
        entity.UpdateSizes(dto.Sizes?.Distinct().ToList(), command.Actor.ToString());
        entity.UpdateTags(dto.Tags?.Distinct().ToList(), command.Actor.ToString());
        entity.UpdateSEO(dto.SEOTitle, dto.SEODescription, command.Actor.ToString());
        entity.UpdateFeatured(dto.Featured, command.Actor.ToString());
        entity.UpdateBarcode(dto.Barcode, command.Actor.ToString());
        entity.UpdateUnitAndWeight(dto.Unit, dto.Weight, command.Actor.ToString());

        if (command.Dto.Published)
        {
            entity.Publish(command.Actor.ToString());
        }
        else
        {
            entity.Unpublish(command.Actor.ToString());
        }

        session.Store(entity);

        var @event = new UpsertedProductDomainEvent(
            entity.Id,
            entity.Name!,
            entity.Sku!,
            entity.Slug!,
            entity.Price,
            entity.SalePrice,
            entity.CategoryIds?.Select(id => id.ToString()).ToList(),
            entity.Images?.Select(img => img.PublicURL).Where(url => !string.IsNullOrWhiteSpace(url)).Cast<string>().ToList(),
            entity.Thumbnail?.PublicURL!,
            entity.Status,
            entity.CreatedOnUtc,
            entity.CreatedBy!,
            entity.LastModifiedOnUtc,
            entity.LastModifiedBy);

        await mediator.Publish(@event, cancellationToken);
        await session.SaveChangesAsync(cancellationToken);

        if (command.Dto.Published)
        {
            await sender.Send(new PublishProductCommand(entity.Id, command.Actor), cancellationToken);
        }
        else
        {
            await sender.Send(new UnpublishProductCommand(entity.Id, command.Actor), cancellationToken);
        }

        return entity.Id;
    }

    #endregion

    #region Methods

    private async Task UploadImagesAsync(
        List<UploadFileBytes>? filesDto,
        List<string>? currentImageUrls,
        ProductEntity entity,
        CancellationToken cancellationToken)
    {
        var newImages = new List<ProductImageEntity>();
        if (filesDto != null && filesDto.Any())
        {
            var result = await minIO.UploadFilesAsync(filesDto, AppConstants.Bucket.Products, true, cancellationToken);
            newImages = mapper.Map<List<ProductImageEntity>>(result);
        }
        entity.AddOrUpdateImages(newImages, currentImageUrls);
    }

    private async Task UploadThumbnailAsync(UploadFileBytes? image, ProductEntity entity, CancellationToken cancellationToken)
    {
        if (image == null) return;

        var result = await minIO.UploadFilesAsync([image], AppConstants.Bucket.Products, true, cancellationToken);
        var thumbnail = result.FirstOrDefault();
        entity.AddOrUpdateThumbnail(mapper.Map<ProductImageEntity>(thumbnail));
    }

    private async Task ValidateCategoryAsync(List<Guid>? inputCategoryIds, CancellationToken cancellationToken = default)
    {
        if (inputCategoryIds is { Count: > 0 })
        {
            var categories = await session.Query<CategoryEntity>().ToListAsync(token: cancellationToken);

            var existingIds = categories.Select(c => c.Id).ToHashSet();
            var invalidIds = inputCategoryIds.Where(id => !existingIds.Contains(id)).ToList();

            if (invalidIds.Any())
            {
                throw new ClientValidationException(MessageCode.CategoryIsNotExists, string.Join(", ", invalidIds));
            }
        }
    }

    private async Task ValidateBrandAsync(Guid? brandId, CancellationToken cancellationToken = default)
    {
        if (brandId.HasValue)
        {
            var brands = await session.Query<BrandEntity>().ToListAsync(token: cancellationToken);
            var existingIds = brands.Select(b => b.Id).ToHashSet();
            if (!existingIds.Contains(brandId.Value))
            {
                throw new ClientValidationException(MessageCode.BrandIsNotExists, brandId);
            }
        }
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/EventHandlers/Domain/DeletedUnPublishedProductDomainEventHandler.cs">
#region using

using Catalog.Domain.Entities;
using Catalog.Domain.Events;
using EventSourcing.Events.Catalog;
using Marten;
using MediatR;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;

#endregion

namespace Catalog.Application.Features.Product.EventHandlers.Domain;

public sealed class DeletedUnPublishedProductDomainEventHandler(
    IDocumentSession session,
    ILogger<UpsertedProductDomainEventHandler> logger) : INotificationHandler<DeletedUnPublishedProductDomainEvent>
{
    #region Implementations

    public async Task Handle(DeletedUnPublishedProductDomainEvent @event, CancellationToken cancellationToken)
    {
        logger.LogInformation("Domain Event handled: {DomainEvent}", @event.GetType().Name);

        await PushToOutboxAsync(@event, cancellationToken);
    }

    #endregion

    #region Methods

    private async Task PushToOutboxAsync(DeletedUnPublishedProductDomainEvent @event, CancellationToken cancellationToken)
    {
        var message = new DeletedUnPublishedProductIntegrationEvent
        {
            Id = Guid.NewGuid().ToString(),
            ProductId = @event.ProductId
        };

        var outboxMessage = OutboxMessageEntity.Create(
            id: Guid.NewGuid(),
            eventType: message.EventType!,
            content: JsonConvert.SerializeObject(message),
            occurredOnUtc: DateTimeOffset.UtcNow);

        session.Store(outboxMessage);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/EventHandlers/Domain/UpsertedProductDomainEventHandler.cs">
#region using

using Catalog.Domain.Entities;
using Catalog.Domain.Events;
using EventSourcing.Events.Catalog;
using Marten;
using MediatR;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;

#endregion

namespace Catalog.Application.Features.Product.EventHandlers.Domain;

public sealed class UpsertedProductDomainEventHandler(
    IDocumentSession session,
    ILogger<UpsertedProductDomainEventHandler> logger) : INotificationHandler<UpsertedProductDomainEvent>
{
    #region Implementations

    public async Task Handle(UpsertedProductDomainEvent @event, CancellationToken cancellationToken)
    {
        logger.LogInformation("Domain Event handled: {DomainEvent}", @event.GetType().Name);

        await PushToOutboxAsync(@event, cancellationToken);
    }

    #endregion

    #region Methods

    private async Task PushToOutboxAsync(UpsertedProductDomainEvent @event, CancellationToken cancellationToken)
    {
        var message = new UpsertedProductIntegrationEvent
        {
            Id = Guid.NewGuid().ToString(),
            ProductId = @event.Id,
            Name = @event.Name,
            Sku = @event.Sku,
            Slug = @event.Slug,
            Price = @event.Price,
            SalePrice = @event.SalePrice,
            Categories = @event.Categories,
            Images = @event.Images,
            Thumbnail = @event.Thumbnail,
            Status = (int)@event.Status,
            CreatedOnUtc = @event.CreatedOnUtc,
            CreatedBy = @event.CreatedBy,
            LastModifiedOnUtc = @event.LastModifiedOnUtc,
            LastModifiedBy = @event.LastModifiedBy
        };

        var outboxMessage = OutboxMessageEntity.Create(
            id: Guid.NewGuid(),
            eventType: message.EventType!,
            content: JsonConvert.SerializeObject(message),
            occurredOnUtc: DateTimeOffset.UtcNow);

        session.Store(outboxMessage);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/Queries/GetAllAvailableProductsQuery.cs">
#region using

using AutoMapper;
using Catalog.Application.Dtos.Products;
using Catalog.Application.Models.Filters;
using Catalog.Application.Models.Results;
using Catalog.Domain.Entities;
using Marten;

#endregion

namespace Catalog.Application.Features.Product.Queries;

public sealed record GetAllAvailableProductsQuery(GetAllProductsFilter Filter) : IQuery<GetAllAvailableProductsResult>;

public sealed class GetAllAvailableProductsQueryHandler(IDocumentSession session, IMapper mapper)
    : IQueryHandler<GetAllAvailableProductsQuery, GetAllAvailableProductsResult>
{
    #region Implementations

    public async Task<GetAllAvailableProductsResult> Handle(GetAllAvailableProductsQuery query, CancellationToken cancellationToken)
    {
        var filter = query.Filter;
        var productQuery = session.Query<ProductEntity>().Where(x => x.Published && x.Status == Domain.Enums.ProductStatus.InStock);

        if (!filter.SearchText.IsNullOrWhiteSpace())
        {
            var search = filter.SearchText.Trim();
            productQuery = productQuery.Where(x => x.Name != null && x.Name.Contains(search));
        }
        if (filter.Ids?.Length > 0)
        {
            productQuery = productQuery.Where(x => filter.Ids.Contains(x.Id));
        }

        var result = await productQuery
            .OrderByDescending(x => x.CreatedOnUtc)
            .ToListAsync(cancellationToken);

        var products = result.ToList();
        var items = mapper.Map<List<ProductDto>>(products);

        if (items.Count > 0)
        {
            var categories = await session.Query<CategoryEntity>()
            .ToListAsync(cancellationToken);
            var brands = await session.Query<BrandEntity>()
                .ToListAsync(cancellationToken);

            foreach (var item in items)
            {
                var product = result.FirstOrDefault(p => p.Id == item.Id);

                if (product == null) continue;

                if (product.CategoryIds != null && product.CategoryIds.Count > 0)
                {
                    foreach (var categoryId in product.CategoryIds)
                    {
                        var category = categories.FirstOrDefault(c => c.Id == categoryId);
                        if (category != null)
                        {
                            item.CategoryNames ??= [];
                            item.CategoryNames.Add(category.Name!);
                        }
                    }
                }

                if (product.BrandId.HasValue)
                {
                    var brand = brands.FirstOrDefault(b => b.Id == product.BrandId.Value);
                    if (brand != null)
                    {
                        item.BrandName = brand.Name;
                    }
                }
            }
        }

        var reponse = new GetAllAvailableProductsResult(items);

        return reponse;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/Queries/GetAllProductsQuery.cs">
#region using

using AutoMapper;
using Catalog.Application.Dtos.Products;
using Catalog.Application.Models.Filters;
using Catalog.Application.Models.Results;
using Catalog.Domain.Entities;
using Marten;

#endregion

namespace Catalog.Application.Features.Product.Queries;

public sealed record GetAllProductsQuery(GetAllProductsFilter Filter) : IQuery<GetAllProductsResult>;

public sealed class GetAllProductsQueryHandler(IDocumentSession session, IMapper mapper)
    : IQueryHandler<GetAllProductsQuery, GetAllProductsResult>
{
    #region Implementations

    public async Task<GetAllProductsResult> Handle(GetAllProductsQuery query, CancellationToken cancellationToken)
    {
        var filter = query.Filter;
        var productQuery = session.Query<ProductEntity>().AsQueryable();

        if (!filter.SearchText.IsNullOrWhiteSpace())
        {
            var search = filter.SearchText.Trim();
            productQuery = productQuery.Where(x => x.Name != null && x.Name.Contains(search));
        }
        if (filter.Ids?.Length > 0)
        {
            productQuery = productQuery.Where(x => filter.Ids.Contains(x.Id));
        }

        var result = await productQuery
            .OrderByDescending(x => x.CreatedOnUtc)
            .ToListAsync(cancellationToken);

        var items = mapper.Map<List<ProductDto>>(result);

        if (items.Count > 0)
        {
            var categories = await session.Query<CategoryEntity>()
            .ToListAsync(cancellationToken);
            var brands = await session.Query<BrandEntity>()
                .ToListAsync(cancellationToken);

            foreach (var item in items)
            {
                var product = result.FirstOrDefault(p => p.Id == item.Id);

                if (product == null) continue;

                if (product.CategoryIds != null && product.CategoryIds.Count > 0)
                {
                    foreach (var categoryId in product.CategoryIds)
                    {
                        var category = categories.FirstOrDefault(c => c.Id == categoryId);
                        if (category != null)
                        {
                            item.CategoryNames ??= [];
                            item.CategoryNames.Add(category.Name!);
                            item.CategoryIds ??= [];
                            item.CategoryIds.Add(category.Id);
                        }
                    }
                }

                if (product.BrandId.HasValue)
                {
                    var brand = brands.FirstOrDefault(b => b.Id == product.BrandId.Value);
                    if (brand != null)
                    {
                        item.BrandName = brand.Name;
                        item.BrandId = brand.Id;
                    }
                }
            }
        }

        var response = new GetAllProductsResult(items);

        return response;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/Queries/GetCountProductsQuery.cs">
#region using

using Catalog.Application.Models.Results;
using Catalog.Domain.Entities;
using Marten;

#endregion

namespace Catalog.Application.Features.Product.Queries;

public sealed record GetCountProductQuery : IQuery<GetCountProductsResult>;

public sealed class GetCountProductQueryHandler(IDocumentSession session)
    : IQueryHandler<GetCountProductQuery, GetCountProductsResult>
{
    #region Implementations

    public async Task<GetCountProductsResult> Handle(GetCountProductQuery query, CancellationToken cancellationToken)
    {
        var productQuery = session.Query<ProductEntity>().AsQueryable();
        var totalCount = await productQuery.CountAsync(cancellationToken);

        return new GetCountProductsResult(totalCount);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/Queries/GetProductByIdQuery.cs">
#region using

using AutoMapper;
using Catalog.Application.Dtos.Products;
using Catalog.Application.Models.Results;
using Catalog.Domain.Entities;
using Marten;

#endregion

namespace Catalog.Application.Features.Product.Queries;

public sealed record GetProductByIdQuery(Guid ProductId) : IQuery<GetProductByIdResult>;

public sealed class GetProductByIdQueryHandler(IDocumentSession session, IMapper mapper)
    : IQueryHandler<GetProductByIdQuery, GetProductByIdResult>
{
    #region Implementations

    public async Task<GetProductByIdResult> Handle(GetProductByIdQuery query, CancellationToken cancellationToken)
    {
        var result = await session.LoadAsync<ProductEntity>(query.ProductId)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound, query.ProductId);

        var categories = await session.Query<CategoryEntity>()
            .ToListAsync(cancellationToken);
        var brands = await session.Query<BrandEntity>()
            .ToListAsync(cancellationToken);

        var reponse = mapper.Map<ProductDto>(result);

        if (result.CategoryIds != null && result.CategoryIds.Count > 0)
        {
            foreach (var categoryId in result.CategoryIds)
            {
                var category = categories.FirstOrDefault(c => c.Id == categoryId);
                if (category != null)
                {
                    reponse.CategoryNames ??= [];
                    reponse.CategoryNames.Add(category.Name!);
                    reponse.CategoryIds ??= [];
                    reponse.CategoryIds.Add(category.Id);
                }
            }
        }

        if (result.BrandId.HasValue)
        {
            var brand = brands.FirstOrDefault(b => b.Id == result.BrandId.Value);
            if (brand != null)
            {
                reponse.BrandName = brand.Name;
                reponse.BrandId = brand.Id;
            }
        }

        return new GetProductByIdResult(reponse);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/Queries/GetProductsQuery.cs">
#region using

using AutoMapper;
using Catalog.Application.Dtos.Products;
using Catalog.Application.Models.Filters;
using Catalog.Application.Models.Results;
using Catalog.Domain.Entities;
using Marten;
using Marten.Pagination;

#endregion

namespace Catalog.Application.Features.Product.Queries;

public sealed record GetProductsQuery(
    GetProductsFilter Filter,
    PaginationRequest Paging) : IQuery<GetProductsResult>;

public sealed class GetProductsQueryHandler(IDocumentSession session, IMapper mapper)
    : IQueryHandler<GetProductsQuery, GetProductsResult>
{
    #region Implementations

    public async Task<GetProductsResult> Handle(GetProductsQuery query, CancellationToken cancellationToken)
    {
        var filter = query.Filter;
        var paging = query.Paging;
        var productQuery = session.Query<ProductEntity>().AsQueryable();

        if (!filter.SearchText.IsNullOrWhiteSpace())
        {
            var search = filter.SearchText.Trim();
            productQuery = productQuery.Where(x => x.Name != null && x.Name.Contains(search));
        }
        if (filter.Ids?.Length > 0)
        {
            productQuery = productQuery.Where(x => filter.Ids.Contains(x.Id));
        }

        var totalCount = await productQuery.CountAsync(cancellationToken);
        var result = await productQuery
            .OrderByDescending(x => x.CreatedOnUtc)
            .ToPagedListAsync(paging.PageNumber, paging.PageSize, cancellationToken);

        var products = result.ToList();
        var items = mapper.Map<List<ProductDto>>(products);

        if (items.Count > 0)
        {
            var categories = await session.Query<CategoryEntity>()
            .ToListAsync(cancellationToken);
            var brands = await session.Query<BrandEntity>()
                .ToListAsync(cancellationToken);

            foreach (var item in items)
            {
                var product = result.FirstOrDefault(p => p.Id == item.Id);

                if (product == null) continue;

                if (product.CategoryIds != null && product.CategoryIds.Count > 0)
                {
                    foreach (var categoryId in product.CategoryIds)
                    {
                        var category = categories.FirstOrDefault(c => c.Id == categoryId);
                        if (category != null)
                        {
                            item.CategoryNames ??= [];
                            item.CategoryNames.Add(category.Name!);
                            item.CategoryIds ??= [];
                            item.CategoryIds.Add(category.Id);
                        }
                    }
                }

                if (product.BrandId.HasValue)
                {
                    var brand = brands.FirstOrDefault(b => b.Id == product.BrandId.Value);
                    if (brand != null)
                    {
                        item.BrandName = brand.Name;
                        item.BrandId = brand.Id;
                    }
                }
            }
        }

        var reponse = new GetProductsResult(items, totalCount, paging);

        return reponse;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/Queries/GetPublishProductByIdQuery.cs">
#region using

using AutoMapper;
using Catalog.Application.Dtos.Products;
using Catalog.Application.Models.Results;
using Catalog.Domain.Entities;
using Marten;

#endregion

namespace Catalog.Application.Features.Product.Queries;

public sealed record GetPublishProductByIdQuery(Guid ProductId) : IQuery<GetPublishProductByIdResult>;

public sealed class GetPublishProductByIdQueryHandler(IDocumentSession session, IMapper mapper)
    : IQueryHandler<GetPublishProductByIdQuery, GetPublishProductByIdResult>
{
    #region Implementations

    public async Task<GetPublishProductByIdResult> Handle(GetPublishProductByIdQuery query, CancellationToken cancellationToken)
    {
        var result = await session.Query<ProductEntity>()
            .Where(x => x.Id == query.ProductId && x.Published)
            .SingleOrDefaultAsync(cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound, query.ProductId);

        var categories = await session.Query<CategoryEntity>()
            .ToListAsync(cancellationToken);
        var brands = await session.Query<BrandEntity>()
            .ToListAsync(cancellationToken);

        var reponse = mapper.Map<PublishProductDto>(result);

        if (result.CategoryIds != null && result.CategoryIds.Count > 0)
        {
            foreach (var categoryId in result.CategoryIds)
            {
                var category = categories.FirstOrDefault(c => c.Id == categoryId);
                if (category != null)
                {
                    reponse.CategoryNames ??= [];
                    reponse.CategoryNames.Add(category.Name!);
                }
            }
        }

        if (result.BrandId.HasValue)
        {
            var brand = brands.FirstOrDefault(b => b.Id == result.BrandId.Value);
            if (brand != null)
            {
                reponse.BrandName = brand.Name;
            }
        }

        return new GetPublishProductByIdResult(reponse);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/Product/Queries/GetPublishProductsQuery.cs">
#region using

using AutoMapper;
using Catalog.Application.Dtos.Products;
using Catalog.Application.Models.Filters;
using Catalog.Application.Models.Results;
using Catalog.Domain.Entities;
using Marten;
using Marten.Pagination;

#endregion

namespace Catalog.Application.Features.Product.Queries;

public sealed record GetPublishProductsQuery(
    GetPublishProductsFilter Filter,
    PaginationRequest Paging) : IQuery<GetPublishProductsResult>;

public sealed class GetPublishProductsQueryHandler(IDocumentSession session, IMapper mapper)
    : IQueryHandler<GetPublishProductsQuery, GetPublishProductsResult>
{
    #region Implementations

    public async Task<GetPublishProductsResult> Handle(GetPublishProductsQuery query, CancellationToken cancellationToken)
    {
        var filter = query.Filter;
        var paging = query.Paging;
        var productQuery = session.Query<ProductEntity>().Where(x => x.Published);

        if (!filter.SearchText.IsNullOrWhiteSpace())
        {
            var search = filter.SearchText.Trim();
            productQuery = productQuery.Where(x => x.Name != null && x.Name.Contains(search));
        }

        var totalCount = await productQuery.CountAsync(cancellationToken);
        var result = await productQuery
            .OrderByDescending(x => x.CreatedOnUtc)
            .ToPagedListAsync(paging.PageNumber, paging.PageSize, cancellationToken);

        var products = result.ToList();
        var items = mapper.Map<List<PublishProductDto>>(products);

        if (items.Count > 0)
        {
            var categories = await session.Query<CategoryEntity>()
            .ToListAsync(cancellationToken);
            var brands = await session.Query<BrandEntity>()
                .ToListAsync(cancellationToken);

            foreach (var item in items)
            {
                var product = result.FirstOrDefault(p => p.Id == item.Id);

                if (product == null) continue;

                if (product.CategoryIds != null && product.CategoryIds.Count > 0)
                {
                    foreach (var categoryId in product.CategoryIds)
                    {
                        var category = categories.FirstOrDefault(c => c.Id == categoryId);
                        if (category != null)
                        {
                            item.CategoryNames ??= [];
                            item.CategoryNames.Add(category.Name!);
                        }
                    }
                }

                if (product.BrandId.HasValue)
                {
                    var brand = brands.FirstOrDefault(b => b.Id == product.BrandId.Value);
                    if (brand != null)
                    {
                        item.BrandName = brand.Name;
                    }
                }
            }
        }

        var reponse = new GetPublishProductsResult(items, totalCount, paging);

        return reponse;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Features/System/InitialDataCommand.cs">
#region using

using Catalog.Application.Services;
using Marten;

#endregion

namespace Catalog.Application.Features.System;

public sealed record InitialDataCommand(Actor Actor) : ICommand<bool>;

public sealed class InitialDataCommandHandler(
    IDocumentSession session,
    ISeedDataService seedDataService) : ICommandHandler<InitialDataCommand, bool>
{
    #region Implementations

    public async Task<bool> Handle(InitialDataCommand command, CancellationToken cancellationToken)
    {
        var result = await seedDataService.SeedDataAsync(session, cancellationToken);
        return result;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Mappings/CatalogMappingProfile.cs">
#region using

using AutoMapper;
using Catalog.Application.Dtos.Brands;
using Catalog.Application.Dtos.Categories;
using Catalog.Application.Dtos.Products;
using Catalog.Application.Models.Results;
using Catalog.Domain.Entities;

#endregion

namespace Catalog.Application.Mappings;

public sealed class CatalogMappingProfile : Profile
{
    #region Ctors

    public CatalogMappingProfile()
    {
        CreateProductMappings();
        CreateCategoryMappings();
        CreateBrandMappings();
        CreateImageMappings();
        CreateResultMappings();
    }

    #endregion

    #region Methods

    private void CreateProductMappings()
    {
        // ProductEntity -> ProductDto
        CreateMap<ProductEntity, ProductDto>()
            .ForMember(dest => dest.DisplayStatus, opt => opt.MapFrom(src => src.Status.GetDescription()));
        // All other properties (including Status) auto-map by convention

        // ProductEntity -> PublishProductDto
        CreateMap<ProductEntity, PublishProductDto>()
            .ForMember(dest => dest.DisplayStatus, opt => opt.MapFrom(src => src.Status.GetDescription()));
        // All other properties (including Status) auto-map by convention

        // ProductEntity -> GetProductByIdResult
        CreateMap<ProductEntity, GetProductByIdResult>()
            .ForMember(dest => dest.Product, opt => opt.MapFrom(src => src));
    }

    private void CreateCategoryMappings()
    {
        // CategoryEntity -> CategoryDto
        CreateMap<CategoryEntity, CategoryDto>();
        // All properties auto-map by convention
    }

    private void CreateBrandMappings()
    {
        // BrandEntity -> BrandDto
        CreateMap<BrandEntity, BrandDto>();
        // All properties auto-map by convention
    }

    private void CreateImageMappings()
    {
        // ProductImageEntity -> ProductImageDto
        CreateMap<ProductImageEntity, ProductImageDto>();

        // ProductImageEntity -> PublishProductImageDto
        CreateMap<ProductImageEntity, PublishProductImageDto>()
            .ForMember(dest => dest.FileName, opt => opt.MapFrom(src => src.FileName))
            .ForMember(dest => dest.PublicURL, opt => opt.MapFrom(src => src.PublicURL));

        // UploadFileBytes -> ProductImageEntity (used in commands)
        CreateMap<UploadFileBytes, ProductImageEntity>()
            .ForMember(dest => dest.FileId, opt => opt.Ignore())
            .ForMember(dest => dest.OriginalFileName, opt => opt.MapFrom(src => src.FileName))
            .ForMember(dest => dest.FileName, opt => opt.Ignore())
            .ForMember(dest => dest.PublicURL, opt => opt.Ignore());

        CreateMap<UploadFileResult, ProductImageEntity>()
            .ReverseMap();
    }

    private void CreateResultMappings()
    {
        // ProductEntity -> GetPublishProductByIdResult
        CreateMap<ProductEntity, GetPublishProductByIdResult>()
            .ForMember(dest => dest.Product, opt => opt.MapFrom(src => src));
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Filters/GetAllCategoriesFilter.cs">
namespace Catalog.Application.Models.Filters;

public record class GetAllCategoriesFilter(Guid? ParentId);
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Filters/GetAllProductsFilter.cs">
namespace Catalog.Application.Models.Filters;

public record class GetAllProductsFilter(string? SearchText, Guid[]? Ids);
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Filters/GetProductsFilter.cs">
namespace Catalog.Application.Models.Filters;

public record class GetProductsFilter(string? SearchText, Guid[]? Ids);
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Filters/GetPublishProductsFilter.cs">
namespace Catalog.Application.Models.Filters;

public record class GetPublishProductsFilter(string? SearchText);
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Results/GetAllAvailableProductsResult.cs">
#region using

using Catalog.Application.Dtos.Products;

#endregion

namespace Catalog.Application.Models.Results;

public sealed class GetAllAvailableProductsResult
{
    #region Fields, Properties and Indexers

    public List<ProductDto> Items { get; init; }

    #endregion

    #region Ctors

    public GetAllAvailableProductsResult(List<ProductDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Results/GetAllBrandsResult.cs">
#region using

using Catalog.Application.Dtos.Brands;

#endregion

namespace Catalog.Application.Models.Results;

public sealed class GetAllBrandsResult
{
    #region Fields, Properties and Indexers

    public List<BrandDto> Items { get; init; }

    #endregion

    #region Ctors

    public GetAllBrandsResult(List<BrandDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Results/GetAllCategoriesResult.cs">
#region using

using Catalog.Application.Dtos.Categories;

#endregion

namespace Catalog.Application.Models.Results;

public sealed class GetAllCategoriesResult
{
    #region Fields, Properties and Indexers

    public List<CategoryDto> Items { get; init; }

    #endregion

    #region Ctors

    public GetAllCategoriesResult(List<CategoryDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Results/GetAllProductsResult.cs">
#region using

using Catalog.Application.Dtos.Products;

#endregion

namespace Catalog.Application.Models.Results;

public sealed class GetAllProductsResult
{
    #region Fields, Properties and Indexers

    public List<ProductDto> Items { get; init; }

    #endregion

    #region Ctors

    public GetAllProductsResult(List<ProductDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Results/GetCountProductsResult.cs">
namespace Catalog.Application.Models.Results;

public sealed class GetCountProductsResult
{
    #region Fields, Properties and Indexers

    public int Count { get; set; }

    #endregion

    #region Ctors

    public GetCountProductsResult(int count)
    {
        Count = count;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Results/GetProductByIdResult.cs">
#region using

using Catalog.Application.Dtos.Products;

#endregion

namespace Catalog.Application.Models.Results;

public sealed class GetProductByIdResult
{
    #region Fields, Properties and Indexers

    public ProductDto Product { get; init; }

    #endregion

    #region Ctors

    public GetProductByIdResult(ProductDto product)
    {
        Product = product;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Results/GetProductsResult.cs">
#region using

using Catalog.Application.Dtos.Products;

#endregion

namespace Catalog.Application.Models.Results;

public sealed class GetProductsResult
{
    #region Fields, Properties and Indexers

    public List<ProductDto> Items { get; init; }

    public PagingResult Paging { get; init; }

    #endregion

    #region Ctors

    public GetProductsResult(
        List<ProductDto> items,
        long totalCount,
        PaginationRequest pagination)
    {
        Items = items;
        Paging = PagingResult.Of(totalCount, pagination);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Results/GetPublishProductByIdResult.cs">
#region using

using Catalog.Application.Dtos.Products;

#endregion

namespace Catalog.Application.Models.Results;

public sealed class GetPublishProductByIdResult
{
    #region Fields, Properties and Indexers

    public PublishProductDto Product { get; init; }

    #endregion

    #region Ctors

    public GetPublishProductByIdResult(PublishProductDto product)
    {
        Product = product;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Results/GetPublishProductsResult.cs">
#region using

using Catalog.Application.Dtos.Products;

#endregion

namespace Catalog.Application.Models.Results;

public sealed class GetPublishProductsResult
{
    #region Fields, Properties and Indexers

    public List<PublishProductDto> Items { get; init; }

    public PagingResult Paging { get; init; }

    #endregion

    #region Ctors

    public GetPublishProductsResult(
        List<PublishProductDto> items,
        long totalCount,
        PaginationRequest pagination)
    {
        Items = items;
        Paging = PagingResult.Of(totalCount, pagination);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Models/Results/GetTreeCategoriesResult.cs">
#region using

using Catalog.Application.Dtos.Categories;

#endregion

namespace Catalog.Application.Models.Results;

public sealed class GetTreeCategoriesResult
{
    #region Fields, Properties and Indexers

    public List<CategoryTreeItemDto>? Items { get; init; }

    #endregion

    #region Ctors

    public GetTreeCategoriesResult(List<CategoryTreeItemDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Repositories/IOutboxRepository.cs">
#region using

using Catalog.Domain.Entities;

#endregion

namespace Catalog.Application.Repositories;

public interface IOutboxRepository
{
    #region Methods

    Task<bool> AddMessageAsync(OutboxMessageEntity message, CancellationToken cancellationToken = default);

    Task<bool> UpdateMessagesAsync(IEnumerable<OutboxMessageEntity> messages, CancellationToken cancellationToken = default);

    Task<List<OutboxMessageEntity>> GetAndClaimMessagesAsync(int batchSize, CancellationToken cancellationToken = default);

    Task<List<OutboxMessageEntity>> GetAndClaimRetryMessagesAsync(int batchSize, CancellationToken cancellationToken = default);

    Task<bool> ReleaseClaimsAsync(IEnumerable<OutboxMessageEntity> messages, CancellationToken cancellationToken = default);

    Task<bool> ReleaseExpiredClaimsAsync(TimeSpan claimTimeout, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Services/IMinIOCloudService.cs">
namespace Catalog.Application.Services;

public interface IMinIOCloudService
{
    #region Methods

    Task<List<UploadFileResult>> UploadFilesAsync(
        List<UploadFileBytes> files,
        string bucketName,
        bool isPublicBucket = false,
        CancellationToken ct = default);

    Task<string> GetShareLinkAsync(string bucketName, string objectName, int expireTime);

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Application/Services/ISeedDataService.cs">
#region using

using Marten;

#endregion

namespace Catalog.Application.Services;

public interface ISeedDataService
{
    #region Methods

    Task<bool> SeedDataAsync(IDocumentSession session, CancellationToken cancellationToken);

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/ApplicationMarker.cs">
namespace Catalog.Application;

public sealed class ApplicationMarker { }
</file>

<file path="Services/Catalog/Core/Catalog.Application/Catalog.Application.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="AutoMapper" />
    <PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" />
    <PackageReference Include="Marten" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" />
    <PackageReference Include="Scrutor" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\Catalog.Domain\Catalog.Domain.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Features\Brand\EventHandlers\" />
    <Folder Include="Features\Category\EventHandlers\" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Catalog/Core/Catalog.Application/DependencyInjection.cs">
#region using

using BuildingBlocks.Behaviors;
using BuildingBlocks.Exceptions.Handler;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.FeatureManagement;
using System.Reflection;

#endregion

namespace Catalog.Application;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddApplicationServices(this IServiceCollection services)
    {
        services.AddExceptionHandler<CustomExceptionHandler>();
        services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
        services.AddMediatR(config =>
        {
            config.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
            config.AddOpenBehavior(typeof(ValidationBehavior<,>));
            config.AddOpenBehavior(typeof(LoggingBehavior<,>));
        });
        services.AddFeatureManagement();

        // Register all AutoMapper profiles from the current assembly
        services.AddAutoMapper(Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Application/GlobalUsing.cs">
global using BuildingBlocks.CQRS;
global using FluentValidation;
global using Common.Models;
global using Common.Constants;
global using Common.Extensions;
global using BuildingBlocks.Pagination;
global using BuildingBlocks.Exceptions;
global using Common.ValueObjects;
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Abstractions/Aggregate.cs">
namespace Catalog.Domain.Abstractions;

public abstract class Aggregate<TId> : Entity<TId>, IAggregate<TId>
{
    #region Fields, Properties and Indexers

    private readonly List<IDomainEvent> _domainEvents = new();

    #endregion

    #region Implementations

    public IReadOnlyList<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    public void AddDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }

    public IDomainEvent[] ClearDomainEvents()
    {
        IDomainEvent[] dequeuedEvents = _domainEvents.ToArray();

        _domainEvents.Clear();

        return dequeuedEvents;
    }

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Abstractions/Entity.cs">
namespace Catalog.Domain.Abstractions;

public abstract class Entity<T> : IEntityId<T>, IAuditable
{
    #region Fields, Properties and Indexers

    public T Id { get; set; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Abstractions/EntityId.cs">
namespace Catalog.Domain.Abstractions;

public abstract class EntityId<T> : IEntityId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; set; } = default!;

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Abstractions/IAggregate.cs">
namespace Catalog.Domain.Abstractions;

public interface IAggregate<T> : IAggregate, IEntityId<T>
{
}

public interface IAggregate : ICreationAuditable, IModificationAuditable
{
    #region Fields, Properties and Indexers

    IReadOnlyList<IDomainEvent> DomainEvents { get; }

    IDomainEvent[] ClearDomainEvents();

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Abstractions/IAuditable.cs">
namespace Catalog.Domain.Abstractions;

public interface IAuditable : ICreationAuditable, IModificationAuditable { }
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Abstractions/ICreationAuditable.cs">
namespace Catalog.Domain.Abstractions;

public interface ICreationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Abstractions/IDomainEvent.cs">
#region using

using MediatR;

#endregion

namespace Catalog.Domain.Abstractions;

public interface IDomainEvent : INotification
{
    #region Fields, Properties and Indexers

    Guid EventId => Guid.NewGuid();

    public DateTimeOffset OccurredOn => DateTime.Now;

    public string EventType => GetType()?.AssemblyQualifiedName ?? string.Empty;

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Abstractions/IEntityId.cs">
namespace Catalog.Domain.Abstractions;

public interface IEntityId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; set; }

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Abstractions/IModificationAuditable.cs">
namespace Catalog.Domain.Abstractions;

public interface IModificationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Entities/BrandEntity.cs">
#region using

using Catalog.Domain.Abstractions;

#endregion

namespace Catalog.Domain.Entities;

public sealed class BrandEntity : Entity<Guid>
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    public string? Slug { get; set; }

    #endregion

    #region Factories

    public static BrandEntity Create(Guid id,
        string name,
        string slug,
        string performedBy)
    {
        return new BrandEntity()
        {
            Id = id,
            Name = name,
            Slug = slug,
            CreatedBy = performedBy,
            LastModifiedBy = performedBy,
            CreatedOnUtc = DateTimeOffset.UtcNow,
            LastModifiedOnUtc = DateTimeOffset.UtcNow,
        };
    }

    #endregion

    #region Methods

    public void Update(string name,
        string slug,
        string performedBy)
    {
        Name = name;
        Slug = slug;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Entities/CategoryEntity.cs">
#region using

using Catalog.Domain.Abstractions;

#endregion

namespace Catalog.Domain.Entities;

public sealed class CategoryEntity : Entity<Guid>
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    public string? Description { get; set; }

    public string? Slug { get; set; }

    public Guid? ParentId { get; set; }

    #endregion

    #region Factories

    public static CategoryEntity Create(Guid id,
        string name,
        string desctiption,
        string slug,
        string performedBy,
        Guid? parentId = null)
    {
        return new CategoryEntity()
        {
            Id = id,
            Name = name,
            Description = desctiption,
            Slug = slug,
            ParentId = parentId,
            CreatedBy = performedBy,
            LastModifiedBy = performedBy,
            CreatedOnUtc = DateTimeOffset.UtcNow,
            LastModifiedOnUtc = DateTimeOffset.UtcNow,
        };
    }

    #endregion

    #region Methods

    public void Update(string name,
        string desciption,
        string slug,
        string performedBy,
        Guid? parentId = null)
    {
        Name = name;
        Description = desciption;
        Slug = slug;
        ParentId = parentId;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Entities/OutboxMessageEntity.cs">
#region using

using Catalog.Domain.Abstractions;

#endregion

namespace Catalog.Domain.Entities;

public sealed class OutboxMessageEntity : EntityId<Guid>
{
    #region Fields, Properties and Indexers

    public string? EventType { get; set; }

    public string? Content { get; set; }

    public DateTimeOffset OccurredOnUtc { get; set; }

    public DateTimeOffset? ProcessedOnUtc { get; set; }

    public string? LastErrorMessage { get; set; }

    public DateTimeOffset? ClaimedOnUtc { get; set; }

    public int AttemptCount { get; set; }

    public int MaxAttempts { get; set; }

    public DateTimeOffset? NextAttemptOnUtc { get; set; }

    #endregion

    #region Factories

    public static OutboxMessageEntity Create(Guid id, string eventType, string content, DateTimeOffset occurredOnUtc)
    {
        return new OutboxMessageEntity()
        {
            Id = id,
            EventType = eventType,
            Content = content,
            OccurredOnUtc = occurredOnUtc,
            MaxAttempts = AppConstants.MaxAttempts,
            AttemptCount = 0
        };
    }

    #endregion

    #region Methods

    public void CompleteProcessing(DateTimeOffset processedOnUtc, string? lastErrorMessage = null)
    {
        ProcessedOnUtc = processedOnUtc;
        LastErrorMessage = lastErrorMessage;
        ClaimedOnUtc = null;
        NextAttemptOnUtc = null;
    }

    public void Claim(DateTimeOffset claimedOnUtc)
    {
        ClaimedOnUtc = claimedOnUtc;
    }

    public void SetRetryProperties(int attemptCount, int maxAttempts, DateTimeOffset? nextAttemptOnUtc, string? lastErrorMessage)
    {
        AttemptCount = attemptCount;
        MaxAttempts = maxAttempts;
        NextAttemptOnUtc = nextAttemptOnUtc;
        LastErrorMessage = lastErrorMessage;
    }

    public void RecordFailedAttempt(string errorMessage, DateTimeOffset currentTime)
    {
        IncreaseAttemptCount();

        if (AttemptCount >= MaxAttempts)
        {
            LastErrorMessage = $"Max attempts ({MaxAttempts}) exceeded. Last error: {errorMessage}";
            NextAttemptOnUtc = null;
        }
        else
        {
            // Calculate exponential backoff with jitter
            var baseDelay = TimeSpan.FromSeconds(Math.Pow(2, AttemptCount - 1));
            var maxDelay = TimeSpan.FromMinutes(5);
            var jitter = TimeSpan.FromMilliseconds(Random.Shared.Next(0, 1000));
            var delay = TimeSpan.FromTicks(Math.Min(baseDelay.Ticks, maxDelay.Ticks)) + jitter;

            NextAttemptOnUtc = currentTime + delay;
            LastErrorMessage = errorMessage;
        }
    }

    public void IncreaseAttemptCount()
    {
        AttemptCount++;
    }

    public bool CanRetry(DateTimeOffset currentTime)
    {
        return AttemptCount < MaxAttempts &&
               (NextAttemptOnUtc == null || currentTime >= NextAttemptOnUtc.Value);
    }

    public bool IsPermanentlyFailed()
    {
        return AttemptCount >= MaxAttempts;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Entities/ProductEntity.cs">
#region using

using Catalog.Domain.Abstractions;
using Catalog.Domain.Enums;
using Catalog.Domain.Exceptions;
using System.Data;

#endregion

namespace Catalog.Domain.Entities;

public sealed class ProductEntity : Aggregate<Guid>
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    public string? Sku { get; set; }

    public string? ShortDescription { get; set; }

    public string? LongDescription { get; set; }

    public string? Slug { get; set; }

    public string? Barcode { get; set; }

    public decimal Price { get; set; }

    public decimal? SalePrice { get; set; }

    public List<Guid>? CategoryIds { get; set; }

    public List<ProductImageEntity>? Images { get; set; }

    public ProductImageEntity? Thumbnail { get; set; }

    public List<string>? Colors { get; set; }

    public List<string>? Sizes { get; set; }

    public List<string>? Tags { get; set; }

    public bool Published { get; set; }

    public bool Featured { get; set; }

    public ProductStatus Status { get; set; }

    public Guid? BrandId { get; set; }

    public string? SEOTitle { get; set; }

    public string? SEODescription { get; set; }

    public string? Unit { get; set; }

    public decimal? Weight { get; set; }

    #endregion

    #region Factories

    public static ProductEntity Create(Guid id,
        string name,
        string sku,
        string shortDescription,
        string longDescription,
        string slug,
        decimal price,
        decimal? salePrice,
        List<Guid>? categoryIds,
        Guid? brandId,
        string performedBy)
    {
        var product = new ProductEntity
        {
            Id = id,
            Name = name,
            Sku = sku,
            ShortDescription = shortDescription,
            LongDescription = longDescription,
            Slug = slug,
            Price = price,
            SalePrice = salePrice,
            Status = ProductStatus.OutOfStock,
            Published = false,
            CategoryIds = categoryIds,
            BrandId = brandId,
            CreatedBy = performedBy,
            LastModifiedBy = performedBy,
            CreatedOnUtc = DateTimeOffset.UtcNow,
            LastModifiedOnUtc = DateTimeOffset.UtcNow
        };

        return product;
    }

    #endregion

    #region Methods

    public void Update(string name,
        string sku,
        string shortDescription,
        string longDescription,
        string slug,
        decimal price,
        decimal? salePrice,
        List<Guid>? categoryIds,
        Guid? brandId,
        string performedBy)
    {
        Name = name;
        Sku = sku;
        ShortDescription = shortDescription;
        LongDescription = longDescription;
        Slug = slug;
        Price = price;
        SalePrice = salePrice;
        CategoryIds = categoryIds;
        BrandId = brandId;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    public void AddOrUpdateImages(IEnumerable<ProductImageEntity>? newImgs = null, IEnumerable<string>? curentImageUrls = null)
    {
        if ((newImgs == null || !newImgs.Any()) &&
            (curentImageUrls == null || !curentImageUrls.Any())) return;

        Images ??= new List<ProductImageEntity>();

        var oldByUrl = Images
            .Where(i => !string.IsNullOrWhiteSpace(i.PublicURL))
            .ToDictionary(i => i.PublicURL!, StringComparer.OrdinalIgnoreCase);

        var keepOld = (curentImageUrls ?? Enumerable.Empty<string>())
            .Where(u => !string.IsNullOrWhiteSpace(u) && oldByUrl.ContainsKey(u))
            .Select(u => oldByUrl[u]);

        var result = (newImgs ?? Enumerable.Empty<ProductImageEntity>())
            .Concat(keepOld)
            .GroupBy(i => string.IsNullOrWhiteSpace(i.FileId) ? i.PublicURL : i.FileId,
                     StringComparer.OrdinalIgnoreCase)
            .Select(g => g.First())
            .ToList();

        Images = result;
    }

    public void AddOrUpdateThumbnail(ProductImageEntity? newImg = null, string? curentImageUrl = null)
    {
        if (newImg == null && string.IsNullOrWhiteSpace(curentImageUrl))
        {
            return;
        }

        if (Thumbnail != null &&
            !string.IsNullOrWhiteSpace(Thumbnail.PublicURL) &&
            Thumbnail.PublicURL!.Equals(curentImageUrl, StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        Thumbnail = newImg;
    }

    public void Publish(string performedBy)
    {
        Published = true;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    public void Unpublish(string performedBy)
    {
        Published = false;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    public void ChangeStatus(ProductStatus status, string performedBy)
    {
        if (Status == status)
        {
            throw new DomainException(MessageCode.DecisionFlowIllegal);
        }

        Status = status;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    public void UpdateFeatured(bool featured, string performedBy)
    {
        Featured = featured;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    public void UpdateSEO(string? seoTitle, string? seoDescription, string performedBy)
    {
        SEOTitle = seoTitle;
        SEODescription = seoDescription;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    public void UpdateColors(List<string>? colors, string performedBy)
    {
        Colors = colors;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    public void UpdateSizes(List<string>? sizes, string performedBy)
    {
        Sizes = sizes;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    public void UpdateTags(List<string>? tags, string performedBy)
    {
        Tags = tags;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    public void UpdateBarcode(string? barcode, string performedBy)
    {
        Barcode = barcode;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    public void UpdateUnitAndWeight(string? unit, decimal? weight, string performedBy)
    {
        Unit = unit;
        Weight = weight;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Entities/ProductImageEntity.cs">
namespace Catalog.Domain.Entities;

public sealed class ProductImageEntity
{
    #region Fields, Properties and Indexers

    public string? FileId { get; set; }

    public string? OriginalFileName { get; set; }

    public string? FileName { get; set; }

    public string? PublicURL { get; set; }

    #endregion

}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Enums/ProductStatus.cs">
#region using

using System.ComponentModel;

#endregion

namespace Catalog.Domain.Enums;

public enum ProductStatus
{
    [Description("In Stock")]
    InStock = 1,

    [Description("Out of Stock")]
    OutOfStock = 2
}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Events/DeletedUnPublishedProductDomainEvent.cs">
#region using

using Catalog.Domain.Abstractions;

#endregion

namespace Catalog.Domain.Events;

public sealed record DeletedUnPublishedProductDomainEvent(Guid ProductId) : IDomainEvent;
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Events/UpsertedProductDomainEvent.cs">
#region using

using Catalog.Domain.Abstractions;
using Catalog.Domain.Enums;

#endregion

namespace Catalog.Domain.Events;

public sealed record UpsertedProductDomainEvent(
    Guid Id,
    string Name,
    string Sku,
    string Slug,
    decimal Price,
    decimal? SalePrice,
    List<string>? Categories,
    List<string>? Images,
    string Thumbnail,
    ProductStatus Status,
    DateTimeOffset CreatedOnUtc,
    string CreatedBy,
    DateTimeOffset? LastModifiedOnUtc,
    string? LastModifiedBy) : IDomainEvent;
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Exceptions/DomainException.cs">
namespace Catalog.Domain.Exceptions;

public sealed class DomainException : Exception
{
    public DomainException(string message) : base(message)
    {
    }
}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/ValueObjects/Money.cs">
#region using

using Catalog.Domain.Exceptions;

#endregion

namespace Catalog.Domain.ValueObjects;

public sealed record Money(decimal Amount, string Currency)
{
    public static Money From(decimal amount, string currency)
    {
        if (amount < 0) throw new DomainException(MessageCode.MoneyCannotBeNegative);
        if (string.IsNullOrWhiteSpace(currency)) throw new DomainException(MessageCode.CurrencyIsRequired);
        return new Money(amount, currency.ToUpperInvariant());
    }
}
</file>

<file path="Services/Catalog/Core/Catalog.Domain/Catalog.Domain.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="MediatR" />
    <PackageReference Include="Newtonsoft.Json" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Catalog/Core/Catalog.Domain/GlobalUsing.cs">
global using Common.Constants;
</file>

<file path="Services/Catalog/Core/Catalog.Infrastructure/Data/BrandSeedData.cs">
#region using

using Catalog.Domain.Entities;

#endregion

namespace Catalog.Infrastructure.Data;

public static class BrandSeedData
{
    #region Constants

    public static readonly Guid ZaraId = Guid.Parse("f4d5e6f7-8a9b-4c1e-0f1a-4b3c2d1e2f10");
    public static readonly Guid GucciId = Guid.Parse("f4d5e6f7-8a9b-4c1e-0f1a-4b3c2d1e2f11");
    public static readonly Guid ChanelId = Guid.Parse("f4d5e6f7-8a9b-4c1e-0f1a-4b3c2d1e2f12");
    public static readonly Guid LouisVuittonId = Guid.Parse("f4d5e6f7-8a9b-4c1e-0f1a-4b3c2d1e2f13");
    public static readonly Guid MangoId = Guid.Parse("f4d5e6f7-8a9b-4c1e-0f1a-4b3c2d1e2f14");
    public static readonly Guid AppleId = Guid.Parse("f4d5e6f7-8a9b-4c1e-0f1a-4b3c2d1e2f15");
    public static readonly Guid SamsungId = Guid.Parse("f4d5e6f7-8a9b-4c1e-0f1a-4b3c2d1e2f16");
    public static readonly Guid XiaomiId = Guid.Parse("f4d5e6f7-8a9b-4c1e-0f1a-4b3c2d1e2f17");
    public static readonly Guid OppoId = Guid.Parse("f4d5e6f7-8a9b-4c1e-0f1a-4b3c2d1e2f18");
    public static readonly Guid HuaweiId = Guid.Parse("f4d5e6f7-8a9b-4c1e-0f1a-4b3c2d1e2f19");
    public static readonly Guid RealmeId = Guid.Parse("f4d5e6f7-8a9b-4c1e-0f1a-4b3c2d1e2f20");

    #endregion

    #region Methods

    public static BrandEntity[] GetBrands(string performedBy)
    {
        return new[]
        {
            BrandEntity.Create(
                id: ZaraId,
                name: "Zara",
                slug: "zara",
                performedBy: performedBy),

            BrandEntity.Create(
                id: GucciId,
                name: "Gucci",
                slug: "gucci",
                performedBy: performedBy),

            BrandEntity.Create(
                id: ChanelId,
                name: "Chanel",
                slug: "chanel",
                performedBy: performedBy),

            BrandEntity.Create(
                id: LouisVuittonId,
                name: "Louis Vuitton",
                slug: "louis-vuitton",
                performedBy: performedBy),

            BrandEntity.Create(
                id: MangoId,
                name: "Mango",
                slug: "mango",
                performedBy: performedBy),

            BrandEntity.Create(
                id: AppleId,
                name: "Apple",
                slug: "apple",
                performedBy: performedBy),

            BrandEntity.Create(
                id: SamsungId,
                name: "Samsung",
                slug: "samsung",
                performedBy: performedBy),

            BrandEntity.Create(
                id: XiaomiId,
                name: "Xiaomi",
                slug: "xiaomi",
                performedBy: performedBy),

            BrandEntity.Create(
                id: OppoId,
                name: "Oppo",
                slug: "oppo",
                performedBy: performedBy),

            BrandEntity.Create(
                id: HuaweiId,
                name: "Huawei",
                slug: "huawei",
                performedBy: performedBy),

            BrandEntity.Create(
                id: RealmeId,
                name: "Realme",
                slug: "realme",
                performedBy: performedBy)
        };
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Infrastructure/Data/CategorySeedData.cs">
#region using

using Catalog.Domain.Entities;

#endregion

namespace Catalog.Infrastructure.Data;

public static class CategorySeedData
{
    #region Constants

    public static readonly Guid ElectronicsId = Guid.Parse("a2d8c5a8-2a64-4b6d-a1c0-0c8b4b9c1a11");
    public static readonly Guid PhonesId = Guid.Parse("b61c0f19-8d1c-4a2e-8f9a-3b5a85d17e12");
    public static readonly Guid LaptopsId = Guid.Parse("6f6b1e0b-65b0-4c42-9a8d-2a5b3e7c8f13");
    public static readonly Guid FashionId = Guid.Parse("c9f4a1b2-1b23-4db3-8f1e-9c3d1a2b3c14");
    public static readonly Guid MenFashionId = Guid.Parse("d1a2b3c4-5e6f-4a1b-9c8d-7e6f5a4b3c15");
    public static readonly Guid WomenFashionId = Guid.Parse("e2b3c4d5-6f7a-4b1c-8d9e-6f5a4b3c2d16");
    public static readonly Guid HomeId = Guid.Parse("f3c4d5e6-7a8b-4c1d-9e8f-5a4b3c2d1e17");

    #endregion

    #region Methods

    public static CategoryEntity[] GetCategories(string performedBy)
    {
        return new[]
        {
            CategoryEntity.Create(
                id: ElectronicsId,
                name: "Electronics",
                desctiption: "Electronic devices & accessories",
                slug: "electronics",
                performedBy: performedBy),

            CategoryEntity.Create(
                id: PhonesId,
                name: "Phones",
                desctiption: "Smartphones & accessories",
                slug: "phones",
                parentId: ElectronicsId,
                performedBy: performedBy),

            CategoryEntity.Create(
                id: LaptopsId,
                name: "Laptops",
                desctiption: "Laptops & accessories",
                slug: "laptops",
                parentId: ElectronicsId,
                performedBy: performedBy),

            CategoryEntity.Create(
                id: FashionId,
                name: "Fashion",
                desctiption: "Clothing, shoes & accessories",
                slug: "fashion",
                performedBy: performedBy),

            CategoryEntity.Create(
                id: MenFashionId,
                name: "Men",
                desctiption: "Men's fashion",
                slug: "men",
                parentId: FashionId,
                performedBy: performedBy),

            CategoryEntity.Create(
                id: WomenFashionId,
                name: "Women",
                desctiption: "Women's fashion",
                slug: "women",
                parentId: FashionId,
                performedBy: performedBy),

            CategoryEntity.Create(
                id: HomeId,
                name: "Home & Living",
                desctiption: "Household goods & furniture",
                slug: "home-living",
                performedBy: performedBy)
        };
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Infrastructure/Data/InitialData.cs">
#region using

using Catalog.Application.Services;
using Marten;
using Marten.Schema;
using Microsoft.Extensions.DependencyInjection;
using Polly;

#endregion

namespace Catalog.Infrastructure.Data;

public sealed class InitialData : IInitialData
{
    #region Fields, Properties and Indexers

    private readonly IServiceProvider _serviceProvider;

    #endregion

    #region Ctors

    public InitialData(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    #endregion

    #region Implementations

    public async Task Populate(IDocumentStore store, CancellationToken cancellation)
    {
        var retryPolicy = Policy
            .Handle<Exception>()
            .WaitAndRetryAsync(5, i => TimeSpan.FromSeconds(5 * i));

        var circuitBreakerPolicy = Policy
            .Handle<Exception>()
            .CircuitBreakerAsync(2, TimeSpan.FromSeconds(30));

        var result = await retryPolicy
            .WrapAsync(circuitBreakerPolicy)
            .ExecuteAsync(async (ct) =>
            {
                try
                {
                    await using var session = store.LightweightSession();
                    using var scope = _serviceProvider.CreateScope();
                    var seedDataService = scope.ServiceProvider.GetRequiredService<ISeedDataService>();
                    await seedDataService.SeedDataAsync(session, ct);
                    return true;
                }
                catch (Exception)
                {
                    return false;
                }
            }, cancellation);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Infrastructure/Data/ProductSeedData.cs">
#region using

using Catalog.Domain.Entities;

#endregion

namespace Catalog.Infrastructure.Data;

public static class ProductSeedData
{
    #region Constants

    public const int TargetProductCount = 15;

    #endregion

    #region Methods

    public static ProductEntity[] GetAllProducts(string performedBy)
    {
        return new[]
        {
            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c21"),
                name: "iPhone 15 Pro",
                sku: "IPHONE-15-PRO-001",
                shortDescription: "Latest iPhone with A17 Pro chip and titanium design",
                longDescription: "The iPhone 15 Pro features a 6.1-inch Super Retina XDR display, A17 Pro chip for exceptional performance, advanced camera system with 48MP main camera, and titanium construction for durability. Available in Natural Titanium, Blue Titanium, White Titanium, and Black Titanium.",
                slug: "iphone-15-pro",
                price: 29990000,
                salePrice: 27990000,
                categoryIds: new List<Guid> { CategorySeedData.PhonesId, CategorySeedData.ElectronicsId },
                brandId: BrandSeedData.AppleId,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c22"),
                name: "Samsung Galaxy S24 Ultra",
                sku: "SAMSUNG-S24-ULTRA-001",
                shortDescription: "Premium Android flagship with S Pen and advanced AI features",
                longDescription: "The Samsung Galaxy S24 Ultra features a 6.8-inch Dynamic AMOLED 2X display, Snapdragon 8 Gen 3 processor, 200MP main camera with 100x Space Zoom, integrated S Pen, and AI-powered features. Built with titanium frame for premium durability.",
                slug: "samsung-galaxy-s24-ultra",
                price: 27990000,
                salePrice: null,
                categoryIds: new List<Guid> { CategorySeedData.PhonesId, CategorySeedData.ElectronicsId },
                brandId: BrandSeedData.SamsungId,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c23"),
                name: "MacBook Pro 16-inch M3 Pro",
                sku: "MACBOOK-PRO-16-M3-001",
                shortDescription: "Powerful laptop for professionals with M3 Pro chip",
                longDescription: "The MacBook Pro 16-inch features the M3 Pro chip with up to 12-core CPU and 19-core GPU, 16.2-inch Liquid Retina XDR display, up to 36GB unified memory, and all-day battery life. Perfect for video editing, software development, and creative work.",
                slug: "macbook-pro-16-inch-m3-pro",
                price: 59990000,
                salePrice: null,
                categoryIds: new List<Guid> { CategorySeedData.LaptopsId, CategorySeedData.ElectronicsId },
                brandId: BrandSeedData.AppleId,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c24"),
                name: "Dell XPS 15",
                sku: "DELL-XPS-15-001",
                shortDescription: "Premium Windows laptop with OLED display",
                longDescription: "The Dell XPS 15 features a 15.6-inch OLED 3.5K display, Intel Core i7 processor, NVIDIA RTX graphics, up to 32GB RAM, and premium build quality. Ideal for content creators and professionals.",
                slug: "dell-xps-15",
                price: 45990000,
                salePrice: 42990000,
                categoryIds: new List<Guid> { CategorySeedData.LaptopsId, CategorySeedData.ElectronicsId },
                brandId: null,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c25"),
                name: "o S Mi Nam C in",
                sku: "ZARA-SHIRT-MEN-001",
                shortDescription: "o s mi nam c in cht liu cotton cao cp",
                longDescription: "o s mi nam thit k c in vi cht liu cotton 100% mm mi, thong kh. Form dng va vn, ph hp cho cng s v cc dp trang trng. C nhiu mu sc v size t S n XXL.",
                slug: "ao-so-mi-nam-co-dien",
                price: 890000,
                salePrice: 690000,
                categoryIds: new List<Guid> { CategorySeedData.MenFashionId, CategorySeedData.FashionId },
                brandId: BrandSeedData.ZaraId,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c26"),
                name: "Qun Jeans N Skinny",
                sku: "ZARA-JEANS-WOMEN-001",
                shortDescription: "Qun jeans n dng skinny co gin cao cp",
                longDescription: "Qun jeans n dng skinny vi cht liu denim co gin, m st to dng p. Thit k hin i vi nhiu mu sc nh xanh m, xanh nht, en. Ph hp mix & match vi nhiu trang phc khc nhau.",
                slug: "quan-jeans-nu-skinny",
                price: 1290000,
                salePrice: 990000,
                categoryIds: new List<Guid> { CategorySeedData.WomenFashionId, CategorySeedData.FashionId },
                brandId: BrandSeedData.ZaraId,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c27"),
                name: "o Khoc Nam Bomber",
                sku: "MANGO-JACKET-MEN-001",
                shortDescription: "o khoc nam bomber phong cch streetwear",
                longDescription: "o khoc nam bomber vi thit k hin i, phong cch streetwear. Cht liu polyester chng nc nh, c lp lt m p. Ph hp cho ma thu ng, c nhiu mu sc tr trung.",
                slug: "ao-khoac-nam-bomber",
                price: 1890000,
                salePrice: null,
                categoryIds: new List<Guid> { CategorySeedData.MenFashionId, CategorySeedData.FashionId },
                brandId: BrandSeedData.MangoId,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c28"),
                name: "Giy Th Thao N",
                sku: "ZARA-SNEAKERS-WOMEN-001",
                shortDescription: "Giy th thao n  cao su m i",
                longDescription: "Giy th thao n vi thit k nng ng,  cao su chng trt v m lt m i. Ph hp cho i b, chy b v cc hot ng th thao hng ngy. C nhiu size v mu sc.",
                slug: "giay-the-thao-nu",
                price: 1590000,
                salePrice: 1290000,
                categoryIds: new List<Guid> { CategorySeedData.WomenFashionId, CategorySeedData.FashionId },
                brandId: BrandSeedData.ZaraId,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c29"),
                name: "Ti Xch Gucci",
                sku: "GUCCI-HANDBAG-001",
                shortDescription: "Ti xch cao cp Gucci da tht",
                longDescription: "Ti xch Gucci c lm t da tht cao cp vi logo GG c trng. Thit k sang trng, ph hp cho cc dp quan trng. C nhiu mu sc v kch thc khc nhau.",
                slug: "tui-xach-gucci",
                price: 45900000,
                salePrice: null,
                categoryIds: new List<Guid> { CategorySeedData.WomenFashionId, CategorySeedData.FashionId },
                brandId: BrandSeedData.GucciId,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c30"),
                name: "Bn Lm Vic G",
                sku: "DESK-WOOD-001",
                shortDescription: "Bn lm vic g t nhin thit k hin i",
                longDescription: "Bn lm vic c lm t g t nhin cao cp, b mt ph sn bo v chng try xc. Thit k hin i vi ngn ko tin li. Kch thc ph hp cho khng gian vn phng v lm vic ti nh.",
                slug: "ban-lam-viec-go",
                price: 4590000,
                salePrice: 3990000,
                categoryIds: new List<Guid> { CategorySeedData.HomeId },
                brandId: null,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c31"),
                name: "Gh Vn Phng Ergonomic",
                sku: "CHAIR-ERGONOMIC-001",
                shortDescription: "Gh vn phng ergonomic h tr lng tt",
                longDescription: "Gh vn phng thit k ergonomic vi m lng v m ngi m i. C th iu chnh  cao, ta lng v tay vn. Ph hp cho lm vic lu di, gim mt mi v au lng.",
                slug: "ghe-van-phong-ergonomic",
                price: 3290000,
                salePrice: null,
                categoryIds: new List<Guid> { CategorySeedData.HomeId },
                brandId: null,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c32"),
                name: "n Bn LED",
                sku: "LAMP-LED-DESK-001",
                shortDescription: "n bn LED iu chnh  sng",
                longDescription: "n bn LED vi cng ngh chiu sng khng chi mt, c th iu chnh  sng v gc chiu. Thit k hin i, tit kim in nng. Ph hp cho hc tp v lm vic ban m.",
                slug: "den-ban-led",
                price: 890000,
                salePrice: 690000,
                categoryIds: new List<Guid> { CategorySeedData.HomeId },
                brandId: null,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c33"),
                name: "T Sch 5 Tng",
                sku: "BOOKSHELF-5-TIER-001",
                shortDescription: "T sch 5 tng g cng nghip",
                longDescription: "T sch 5 tng c lm t g cng nghip MDF cao cp, b mt ph melamine chng m. Thit k n gin, d lp rp. Ph hp  trng by sch,  trang tr v cc vt dng khc.",
                slug: "tu-sach-5-tang",
                price: 2490000,
                salePrice: null,
                categoryIds: new List<Guid> { CategorySeedData.HomeId },
                brandId: null,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c34"),
                name: "Xiaomi Redmi Note 13 Pro",
                sku: "XIAOMI-REDMI-NOTE-13-001",
                shortDescription: "Smartphone gi r hiu nng cao",
                longDescription: "Xiaomi Redmi Note 13 Pro vi mn hnh AMOLED 6.67 inch, chip Snapdragon 7s Gen 2, camera 200MP, pin 5100mAh sc nhanh 67W. Gi c phi chng vi hiu nng mnh m.",
                slug: "xiaomi-redmi-note-13-pro",
                price: 7990000,
                salePrice: 6990000,
                categoryIds: new List<Guid> { CategorySeedData.PhonesId, CategorySeedData.ElectronicsId },
                brandId: null,
                performedBy: performedBy),

            ProductEntity.Create(
                id: Guid.Parse("a1b2c3d4-e5f6-4a1b-9c8d-7e6f5a4b3c35"),
                name: "o Thun Nam C Trn",
                sku: "ZARA-TSHIRT-MEN-001",
                shortDescription: "o thun nam c trn cht liu cotton",
                longDescription: "o thun nam c trn vi cht liu cotton 100% mm mi, thong mt. Thit k n gin, d phi . C nhiu mu sc c bn nh trng, en, xm, xanh navy. Ph hp cho ma h.",
                slug: "ao-thun-nam-co-tron",
                price: 490000,
                salePrice: null,
                categoryIds: new List<Guid> { CategorySeedData.MenFashionId, CategorySeedData.FashionId },
                brandId: BrandSeedData.ZaraId,
                performedBy: performedBy)
        };
    }

    public static string GetThumbnailUrl(string productName)
    {
        return productName.ToLower() switch
        {
            "iphone 15 pro" => "https://images.unsplash.com/photo-1592750475338-74b7b21085ab?w=800&h=800&fit=crop",
            "samsung galaxy s24 ultra" => "https://images.unsplash.com/photo-1610945265064-0e34e5519bbf?w=800&h=800&fit=crop",
            "macbook pro 16-inch m3 pro" => "https://images.unsplash.com/photo-1541807084-5c52b6b3adef?w=800&h=800&fit=crop",
            "dell xps 15" => "https://images.unsplash.com/photo-1496181133206-80ce9b88a853?w=800&h=800&fit=crop",
            "o s mi nam c in" => "https://images.unsplash.com/photo-1642764873654-9eef0467b342?w=800&h=800&fit=crop",
            "qun jeans n skinny" => "https://images.unsplash.com/photo-1542272604-787c3835535d?w=800&h=800&fit=crop",
            "o khoc nam bomber" => "https://images.unsplash.com/photo-1551028719-00167b16eac5?w=800&h=800&fit=crop",
            "giy th thao n" => "https://images.unsplash.com/photo-1542291026-7eec264c27ff?w=800&h=800&fit=crop",
            "ti xch gucci" => "https://images.unsplash.com/photo-1590874103328-eac38a683ce7?w=800&h=800&fit=crop",
            "bn lm vic g" => "https://images.unsplash.com/photo-1586023492125-27b2c045efd7?w=800&h=800&fit=crop",
            "gh vn phng ergonomic" => "https://images.unsplash.com/photo-1506439773649-6e0eb8cfb237?w=800&h=800&fit=crop",
            "n bn led" => "https://images.unsplash.com/photo-1507473885765-e6ed057f782c?w=800&h=800&fit=crop",
            "t sch 5 tng" => "https://images.unsplash.com/photo-1586023492125-27b2c045efd7?w=800&h=800&fit=crop",
            "xiaomi redmi note 13 pro" => "https://images.unsplash.com/photo-1511707171634-5f897ff02aa9?w=800&h=800&fit=crop",
            "o thun nam c trn" => "https://images.unsplash.com/photo-1521572163474-6864f9cf17ab?w=800&h=800&fit=crop",
            _ => "https://images.unsplash.com/photo-1441986300917-64674bd600d8?w=800&h=800&fit=crop"
        };
    }

    public static List<string> GetProductImages(string productName)
    {
        return productName.ToLower() switch
        {
            "iphone 15 pro" => new List<string>
            {
                "https://images.unsplash.com/photo-1592750475338-74b7b21085ab?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1511707171634-5f897ff02aa9?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1556656793-08538906a9f8?w=1200&h=1200&fit=crop"
            },
            "samsung galaxy s24 ultra" => new List<string>
            {
                "https://images.unsplash.com/photo-1610945265064-0e34e5519bbf?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1511707171634-5f897ff02aa9?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1556656793-08538906a9f8?w=1200&h=1200&fit=crop"
            },
            "macbook pro 16-inch m3 pro" => new List<string>
            {
                "https://images.unsplash.com/photo-1541807084-5c52b6b3adef?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1496181133206-80ce9b88a853?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1525547719571-a2d4ac8945e2?w=1200&h=1200&fit=crop"
            },
            "dell xps 15" => new List<string>
            {
                "https://images.unsplash.com/photo-1496181133206-80ce9b88a853?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1541807084-5c52b6b3adef?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1525547719571-a2d4ac8945e2?w=1200&h=1200&fit=crop"
            },
            "o s mi nam c in" => new List<string>
            {
                "https://images.unsplash.com/photo-1594938291221-94f18b6fa0e1?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1622445275576-721325763afe?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1603252109303-2751441dd157?w=1200&h=1200&fit=crop"
            },
            "qun jeans n skinny" => new List<string>
            {
                "https://images.unsplash.com/photo-1542272604-787c3835535d?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1582418702059-97ebafbcdb1d?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1541099649105-f69ad21f3246?w=1200&h=1200&fit=crop"
            },
            "o khoc nam bomber" => new List<string>
            {
                "https://images.unsplash.com/photo-1551028719-00167b16eac5?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1539533018447-63fcce2678e3?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1556821840-3a63f95609a7?w=1200&h=1200&fit=crop"
            },
            "giy th thao n" => new List<string>
            {
                "https://images.unsplash.com/photo-1542291026-7eec264c27ff?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1460353581641-37baddab0fa2?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1606107557195-0e29a4b5b4aa?w=1200&h=1200&fit=crop"
            },
            "ti xch gucci" => new List<string>
            {
                "https://images.unsplash.com/photo-1590874103328-eac38a683ce7?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1553062407-98eeb64c6a62?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1594223274512-ad4803739b7c?w=1200&h=1200&fit=crop"
            },
            "bn lm vic g" => new List<string>
            {
                "https://images.unsplash.com/photo-1586023492125-27b2c045efd7?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1532372320572-cda25653a26d?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1581539250439-c96689b516dd?w=1200&h=1200&fit=crop"
            },
            "gh vn phng ergonomic" => new List<string>
            {
                "https://images.unsplash.com/photo-1506439773649-6e0eb8cfb237?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1586023492125-27b2c045efd7?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1532372320572-cda25653a26d?w=1200&h=1200&fit=crop"
            },
            "n bn led" => new List<string>
            {
                "https://images.unsplash.com/photo-1507473885765-e6ed057f782c?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1526170375885-4d8ecf77b99f?w=1200&h=1200&fit=crop"
            },
            "t sch 5 tng" => new List<string>
            {
                "https://images.unsplash.com/photo-1586023492125-27b2c045efd7?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1532372320572-cda25653a26d?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=1200&h=1200&fit=crop"
            },
            "xiaomi redmi note 13 pro" => new List<string>
            {
                "https://images.unsplash.com/photo-1511707171634-5f897ff02aa9?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1592750475338-74b7b21085ab?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1556656793-08538906a9f8?w=1200&h=1200&fit=crop"
            },
            "o thun nam c trn" => new List<string>
            {
                "https://images.unsplash.com/photo-1521572163474-6864f9cf17ab?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1594938291221-94f18b6fa0e1?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1622445275576-721325763afe?w=1200&h=1200&fit=crop"
            },
            _ => new List<string>
            {
                "https://images.unsplash.com/photo-1441986300917-64674bd600d8?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1441986300917-64674bd600d8?w=1200&h=1200&fit=crop",
                "https://images.unsplash.com/photo-1441986300917-64674bd600d8?w=1200&h=1200&fit=crop"
            }
        };
    }

    public static void AddProductImages(ProductEntity product)
    {
        var thumbnail = new ProductImageEntity
        {
            PublicURL = GetThumbnailUrl(product.Name!),
            FileName = $"{product.Slug}-thumbnail.jpg",
            OriginalFileName = $"{product.Slug}-thumbnail.jpg"
        };

        var images = GetProductImages(product.Name!).Select(url => new ProductImageEntity
        {
            PublicURL = url,
            FileName = $"{product.Slug}-{Guid.NewGuid()}.jpg",
            OriginalFileName = $"{product.Slug}-{Guid.NewGuid()}.jpg"
        }).ToList();

        product.AddOrUpdateThumbnail(thumbnail);
        product.AddOrUpdateImages(images);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Infrastructure/Exceptions/InfrastructureException.cs">
namespace Catalog.Infrastructure.Exceptions;

public sealed class InfrastructureException : Exception
{
    #region Ctors

    public InfrastructureException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Infrastructure/Repositories/OutboxRepository.cs">
#region using

using Catalog.Application.Repositories;
using Catalog.Domain.Entities;
using Marten;
using Microsoft.Extensions.Logging;

#endregion

namespace Catalog.Infrastructure.Repositories;

public class OutboxRepository(IDocumentSession session, ILogger<OutboxRepository> logger) : IOutboxRepository
{
    #region Implementations

    public async Task<bool> AddMessageAsync(OutboxMessageEntity message, CancellationToken cancellationToken = default)
    {
        logger.LogDebug("Adding outbox message {MessageId} of type {EventType}", message.Id, message.EventType);

        session.Store(message);
        await session.SaveChangesAsync(cancellationToken);

        logger.LogInformation("Successfully added outbox message {MessageId} of type {EventType}", message.Id, message.EventType);
        return true;
    }

    public async Task<bool> UpdateMessagesAsync(IEnumerable<OutboxMessageEntity> messages, CancellationToken cancellationToken = default)
    {
        var messageList = messages.ToList();
        logger.LogDebug("Updating {Count} outbox messages", messageList.Count);

        foreach (var message in messageList)
        {
            session.Store(message);
        }
        await session.SaveChangesAsync(cancellationToken);

        logger.LogInformation("Successfully updated {Count} outbox messages", messageList.Count);
        return true;
    }

    public async Task<List<OutboxMessageEntity>> GetAndClaimMessagesAsync(int batchSize, CancellationToken cancellationToken = default)
    {
        var now = DateTimeOffset.UtcNow;
        var claimTimeout = TimeSpan.FromMinutes(5);
        var expiredTime = now.Subtract(claimTimeout);

        logger.LogDebug("Attempting to claim up to {BatchSize} unprocessed outbox messages", batchSize);

        //await session.BeginTransactionAsync(cancellationToken);

        try
        {
            // Query for unprocessed messages that are not claimed or have expired claims
            var messagesToClaim = await session.Query<OutboxMessageEntity>()
                .Where(x => x.ProcessedOnUtc == null
                    && (x.ClaimedOnUtc == null || x.ClaimedOnUtc < expiredTime))
                .OrderBy(x => x.OccurredOnUtc)
                .Take(batchSize)
                .ToListAsync(cancellationToken);

            if (!messagesToClaim.Any())
            {
                await session.SaveChangesAsync(cancellationToken);
                logger.LogDebug("No unprocessed messages found to claim");
                return [];
            }

            // Claim the messages
            foreach (var message in messagesToClaim)
            {
                message.Claim(now);
                session.Store(message);
            }

            await session.SaveChangesAsync(cancellationToken);

            logger.LogInformation("Successfully claimed {Count} outbox messages", messagesToClaim.Count);
            return messagesToClaim.ToList();
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error occurred while claiming outbox messages");
            return [];
        }
    }

    public async Task<List<OutboxMessageEntity>> GetAndClaimRetryMessagesAsync(int batchSize, CancellationToken cancellationToken = default)
    {
        var now = DateTimeOffset.UtcNow;
        var claimTimeout = TimeSpan.FromMinutes(5);
        var expiredTime = now.Subtract(claimTimeout);

        logger.LogDebug("Attempting to claim up to {BatchSize} retry outbox messages", batchSize);

        //await session.BeginTransactionAsync(cancellationToken);

        try
        {
            // Query for retry messages
            var allRetryMessages = await session.Query<OutboxMessageEntity>()
                .Where(x => x.ProcessedOnUtc == null
                    && x.AttemptCount < x.MaxAttempts
                    && (x.NextAttemptOnUtc == null || x.NextAttemptOnUtc <= now)
                    && (x.ClaimedOnUtc == null || x.ClaimedOnUtc < expiredTime))
                .OrderBy(x => x.OccurredOnUtc)
                .Take(batchSize * 2)
                .ToListAsync(cancellationToken);

            var retryMessages = allRetryMessages
                .OrderBy(x => x.NextAttemptOnUtc ?? x.OccurredOnUtc)
                .ThenBy(x => x.OccurredOnUtc)
                .Take(batchSize)
                .ToList();

            if (!retryMessages.Any())
            {
                await session.SaveChangesAsync(cancellationToken);
                logger.LogDebug("No retry messages found to claim");
                return [];
            }

            // Claim the messages
            foreach (var message in retryMessages)
            {
                message.Claim(now);
                session.Store(message);
            }

            await session.SaveChangesAsync(cancellationToken);

            logger.LogInformation("Successfully claimed {Count} retry outbox messages", retryMessages.Count);
            return retryMessages.ToList();
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error occurred while claiming retry outbox messages");
            return [];
        }
    }

    public async Task<bool> ReleaseExpiredClaimsAsync(TimeSpan claimTimeout, CancellationToken cancellationToken = default)
    {
        var expiredTime = DateTimeOffset.UtcNow.Subtract(claimTimeout);

        logger.LogDebug("Releasing expired claims older than {ExpiredTime}", expiredTime);

        var expiredMessages = await session.Query<OutboxMessageEntity>()
            .Where(x => x.ProcessedOnUtc == null
                && x.ClaimedOnUtc != null
                && x.ClaimedOnUtc < expiredTime)
            .ToListAsync(cancellationToken);

        if (!expiredMessages.Any())
        {
            logger.LogDebug("No expired claims found to release");
            return true;
        }

        foreach (var message in expiredMessages)
        {
            message.ClaimedOnUtc = null;
            session.Store(message);
        }

        await session.SaveChangesAsync(cancellationToken);

        logger.LogInformation("Successfully released {Count} expired claims", expiredMessages.Count);
        return true;
    }

    public async Task<bool> ReleaseClaimsAsync(IEnumerable<OutboxMessageEntity> messages, CancellationToken cancellationToken = default)
    {
        var messageList = messages.ToList();
        logger.LogDebug("Releasing claims for {Count} outbox messages", messageList.Count);

        foreach (var message in messageList)
        {
            message.ClaimedOnUtc = null;
            session.Store(message);
        }

        await session.SaveChangesAsync(cancellationToken);

        logger.LogInformation("Successfully released claims for {Count} outbox messages", messageList.Count);
        return true;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Infrastructure/Services/MinIOCloudService.cs">
#region using

using System.Text.Json;
using Catalog.Application.Services;
using Minio;
using Minio.DataModel.Args;
using Minio.Exceptions;

#endregion

namespace Catalog.Infrastructure.Services;

public sealed class MinIOCloudService : IMinIOCloudService
{
    #region Fields, Properties and Indexers

    private readonly IMinioClient _minioClient;

    private readonly string _endPoint;

    #endregion

    #region Ctors

    public MinIOCloudService(IMinioClient minioClient)
    {
        _minioClient = minioClient;
        _endPoint = _minioClient.Config.Endpoint;
    }

    #endregion

    #region Implementations

    public async Task<List<UploadFileResult>> UploadFilesAsync(
        List<UploadFileBytes> files,
        string bucketName,
        bool isPublicBucket = false,
        CancellationToken ct = default)
    {
        var results = new List<UploadFileResult>();
        if (files == null || files.Count == 0) return results;

        try
        {
            await EnsureBucketAsync(bucketName, isPublicBucket, ct);

            foreach (var f in files)
            {
                var fileCloudId = Guid.NewGuid();
                var ext = Path.GetExtension(f.FileName);
                var objectName = $"{fileCloudId:N}{ext}";

                using var stream = new MemoryStream(f.Bytes, 0, f.Bytes.Length, writable: false, publiclyVisible: true);

                var putArgs = new PutObjectArgs()
                    .WithBucket(bucketName)
                    .WithObject(objectName)
                    .WithStreamData(stream)
                    .WithObjectSize(stream.Length)
                    .WithContentType(f.ContentType);

                var putResp = await _minioClient.PutObjectAsync(putArgs, ct);

                results.Add(new UploadFileResult
                {
                    FileId = fileCloudId.ToString(),
                    FolderName = bucketName,
                    OriginalFileName = f.FileName,
                    FileName = objectName,
                    FileSize = f.Bytes.LongLength,
                    ContentType = f.ContentType,
                    PublicURL = isPublicBucket ? $"{_endPoint}/{bucketName}/{objectName}" : string.Empty,
                });
            }

            return results;
        }
        catch (MinioException e)
        {
            throw new InfrastructureException(e.Message);
        }
    }

    public async Task<string> GetShareLinkAsync(string bucketName, string objectName, int expireTimeMinutes)
    {
        try
        {
            var args = new PresignedGetObjectArgs()
                .WithBucket(bucketName)
                .WithObject(objectName)
                .WithExpiry(expireTimeMinutes * 60);

            return await _minioClient.PresignedGetObjectAsync(args);
        }
        catch (Exception e)
        {
            throw new InfrastructureException(e.Message);
        }
    }

    #endregion

    #region Helpers

    private async Task EnsureBucketAsync(string bucketName, bool isPublicBucket, CancellationToken ct)
    {
        var exists = await _minioClient
            .BucketExistsAsync(new BucketExistsArgs().WithBucket(bucketName), ct);

        if (!exists)
        {
            await _minioClient.MakeBucketAsync(new MakeBucketArgs().WithBucket(bucketName), ct);

            if (isPublicBucket)
            {
                // Set read-only bucket policy
                var policy = new
                {
                    Version = "2012-10-17",
                    Statement = new[]
                    {
                        new
                        {
                            Effect = "Allow",
                            Principal = "*",
                            Action = new[] { "s3:GetObject" },
                            Resource = $"arn:aws:s3:::{bucketName}/*"
                        }
                    }
                };

                var policyJson = JsonSerializer.Serialize(policy);
                await _minioClient.SetPolicyAsync(
                    new SetPolicyArgs().WithBucket(bucketName).WithPolicy(policyJson), ct
                );
            }
        }
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Infrastructure/Services/SeedDataService.cs">
#region using

using Common.ValueObjects;
using Catalog.Application.Services;
using Catalog.Domain.Entities;
using Catalog.Infrastructure.Data;
using Marten;

#endregion

namespace Catalog.Infrastructure.Services;

public sealed class SeedDataService : ISeedDataService
{
    #region Implementations

    public async Task<bool> SeedDataAsync(IDocumentSession session, CancellationToken cancellationToken)
    {
        var hasChanges = false;
        var performedBy = Actor.System("catalog-service").ToString();

        if (!await session.Query<CategoryEntity>().AnyAsync(cancellationToken))
        {
            hasChanges = true;
            var categories = CategorySeedData.GetCategories(performedBy);
            session.Store(categories);
        }

        if (!await session.Query<BrandEntity>().AnyAsync(cancellationToken))
        {
            hasChanges = true;
            var brands = BrandSeedData.GetBrands(performedBy);
            session.Store(brands);
        }

        var productChanges = await SeedProductDataAsync(session, cancellationToken);
        if (productChanges)
        {
            hasChanges = true;
        }

        if (hasChanges)
        {
            await session.SaveChangesAsync(cancellationToken);
        }

        return hasChanges;
    }

    #endregion

    #region Private Methods

    private async Task<bool> SeedProductDataAsync(IDocumentSession session, CancellationToken cancellation)
    {
        var currentCount = await session.Query<ProductEntity>().CountAsync(cancellation);

        if (currentCount >= ProductSeedData.TargetProductCount)
        {
            return false;
        }

        var productsToCreate = ProductSeedData.TargetProductCount - currentCount;
        var allProducts = ProductSeedData.GetAllProducts(Actor.System("catalog-service").ToString());
        var productsToSeed = allProducts.Take(productsToCreate).ToArray();

        foreach (var product in productsToSeed)
        {
            ProductSeedData.AddProductImages(product);
        }

        session.Store(productsToSeed);

        return productsToSeed.Any();
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Infrastructure/Catalog.Infrastructure.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="Marten" />
    <PackageReference Include="Minio" />
    <PackageReference Include="Polly" />
    <PackageReference Include="Polly.Extensions.Http" />
    <PackageReference Include="Refit.HttpClientFactory" />
    <PackageReference Include="Scrutor" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\Catalog.Application\Catalog.Application.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Catalog/Core/Catalog.Infrastructure/DependencyInjection.cs">
#region using

using Marten;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Minio;

#endregion

namespace Catalog.Infrastructure;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddInfrastructureServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddMarten(opts =>
        {
            opts.Connection(cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"]!);
            opts.UseSystemTextJsonForSerialization();
        }).UseLightweightSessions();

        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Service")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithScopedLifetime());

        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Repository")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithScopedLifetime());

        services.AddMinio(configureClient => configureClient
                    .WithEndpoint(cfg[$"{MinIoCfg.Section}:{MinIoCfg.Endpoint}"])
                    .WithCredentials(cfg[$"{MinIoCfg.Section}:{MinIoCfg.AccessKey}"], cfg[$"{MinIoCfg.Section}:{MinIoCfg.SecretKey}"])
                    .WithSSL(cfg.GetValue<bool>(cfg[$"{MinIoCfg.Section}:{MinIoCfg.Secure}"]!))
                    .Build());

        //services.InitializeMartenWith<InitialData>();

        return services;
    }

    public static WebApplication UseInfrastructure(this WebApplication app)
    {
        return app;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Core/Catalog.Infrastructure/GlobalUsing.cs">
global using Common.Models;
global using Common.Configurations;
global using Catalog.Infrastructure.Exceptions;
</file>

<file path="Services/Catalog/Core/Catalog.Infrastructure/InfrastructureMarker.cs">
namespace Catalog.Infrastructure;

public sealed class InfrastructureMarker { }
</file>

<file path="Services/Catalog/Worker/Catalog.Woker.Outbox/BackgroundServices/OutboxBackgroundService.cs">
#region using

using Common.Configurations;
using Catalog.Worker.Outbox.Processors;

#endregion

namespace Catalog.Worker.Outbox.BackgroundServices;

internal class OutboxBackgroundService : BackgroundService
{
    #region Fields, Properties and Indexers

    private readonly int _processorFrequency;

    private readonly int _maxParallelism;

    private int _totalIterations = 0;

    private int _totalProcessedMessage = 0;

    private readonly IServiceScopeFactory _serviceScopeFactory;

    private readonly ILogger<OutboxBackgroundService> _logger;

    #endregion

    #region Ctors

    public OutboxBackgroundService(
        IServiceScopeFactory serviceScopeFactory,
        IConfiguration cfg,
        ILogger<OutboxBackgroundService> logger)
    {
        _processorFrequency = cfg.GetValue<int>($"{WorkerCfg.Outbox.Section}:{WorkerCfg.Outbox.ProcessorFrequency}", 5);
        _maxParallelism = cfg.GetValue<int>($"{WorkerCfg.Outbox.Section}:{WorkerCfg.Outbox.MaxParallelism}", 5);
        _serviceScopeFactory = serviceScopeFactory;
        _logger = logger;
    }

    #endregion

    #region Methods

    protected override async Task ExecuteAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Outbox processor started");

        var parallelOptions = new ParallelOptions
        {
            MaxDegreeOfParallelism = _maxParallelism,
            CancellationToken = cancellationToken
        };

        try
        {
            await Parallel.ForEachAsync(
                Enumerable.Range(0, _maxParallelism),
                parallelOptions,
                async (_, token) =>
                {
                    await ProcessOutboxMessages(token);
                });
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Outbox processor operation cancelled");
        }
        catch (Exception ex)
        {
            _logger.LogError("An error occurred while processing outbox messages {MESSAGE}", ex.Message);
        }
    }

    private async Task ProcessOutboxMessages(CancellationToken cancellationToken)
    {
        using var scope = _serviceScopeFactory.CreateScope();
        var outboxProcessor = scope.ServiceProvider.GetRequiredService<OutboxProcessor>();

        while (true)
        {
            int processedMessages = await outboxProcessor.ExecuteAsync(cancellationToken);
            var totalProcessedMessages = Interlocked.Add(ref _totalProcessedMessage, processedMessages);

            // Only log if there were messages processed or every 100 iterations
            var iterationCount = Interlocked.Increment(ref _totalIterations);
            if (processedMessages > 0 || iterationCount % 100 == 0)
            {
                _logger.LogInformation("Iteration {IterationCount}: Processed {ProcessedMessages} messages. Total: {TotalProcessedMessages}",
                    iterationCount, processedMessages, totalProcessedMessages);
            }

            await Task.Delay(TimeSpan.FromSeconds(_processorFrequency), cancellationToken);
        }
    }

    #endregion
}
</file>

<file path="Services/Catalog/Worker/Catalog.Woker.Outbox/Processors/OutboxProcessor.cs">
#region using

using Common.Configurations;
using Catalog.Domain.Entities;
using Catalog.Worker.Outbox.Structs;
using MassTransit;
using System.Collections.Concurrent;
using System.Text.Json;
using Catalog.Application.Repositories;

#endregion

namespace Catalog.Worker.Outbox.Processors;

internal sealed class OutboxProcessor
{
    #region Fields, Properties and Indexers

    private readonly int _batchSize;

    private static readonly ConcurrentDictionary<string, Type> TypeCache = new();

    private readonly IOutboxRepository _outboxRepo;

    private readonly IPublishEndpoint _publish;

    private readonly ILogger<OutboxProcessor> _logger;

    #endregion

    #region Ctors

    public OutboxProcessor(
        IOutboxRepository outboxRepo,
        IConfiguration cfg,
        IPublishEndpoint publish,
        ILogger<OutboxProcessor> logger)
    {
        _batchSize = cfg.GetValue<int>($"{WorkerCfg.Outbox.Section}:{WorkerCfg.Outbox.BatchSize}", 1000);
        _outboxRepo = outboxRepo;
        _publish = publish;
        _logger = logger;
    }

    #endregion

    #region Methods

    public async Task<int> ExecuteAsync(CancellationToken cancellationToken = default)
    {
        // Process both new messages and retry messages
        var newMessages = await _outboxRepo.GetAndClaimMessagesAsync(_batchSize, cancellationToken);
        var retryMessages = await _outboxRepo.GetAndClaimRetryMessagesAsync(_batchSize, cancellationToken);

        var allMessages = newMessages.Concat(retryMessages).ToList();

        if (allMessages.Count == 0) return 0;

        var updateQueue = new ConcurrentQueue<OutboxUpdate>();

        var publishTasks = allMessages
            .Select(message => ProcessMessageAsync(message, updateQueue, _publish, _logger, cancellationToken))
            .ToList();

        await Task.WhenAll(publishTasks);

        if (!updateQueue.IsEmpty)
        {
            // Convert OutboxUpdate to OutboxMessageEntity for bulk update
            var messagesToUpdate = updateQueue.Select(update =>
            {
                var message = allMessages.First(m => m.Id == update.Id);
                if (update.ProcessedOnUtc != default)
                {
                    message.CompleteProcessing(update.ProcessedOnUtc, update.LastErrorMessage);
                }
                else
                {
                    // Retry case - update retry properties
                    message.ClaimedOnUtc = null;
                    message.SetRetryProperties(
                        update.AttemptCount,
                        message.MaxAttempts,
                        update.NextAttemptOnUtc,
                        update.LastErrorMessage);
                }
                return message;
            }).ToList();

            await _outboxRepo.UpdateMessagesAsync(messagesToUpdate, cancellationToken);
        }
        else
        {
            // If no messages were successfully processed, release the claims
            _logger.LogWarning("No messages were successfully processed, releasing claims");
            await _outboxRepo.ReleaseClaimsAsync(allMessages, cancellationToken);
        }

        if (allMessages.Count > 0)
        {
            _logger.LogInformation("Processed {Count} messages from outbox", allMessages.Count);
        }

        return allMessages.Count;
    }

    private static async Task ProcessMessageAsync(
        OutboxMessageEntity message,
        ConcurrentQueue<OutboxUpdate> updateQueue,
        IPublishEndpoint publish,
        ILogger<OutboxProcessor> logger,
        CancellationToken cancellationToken)
    {
        try
        {
            var messageType = GetOrAddMessageType(message.EventType!);
            var deserializedMessage = JsonSerializer.Deserialize(message.Content!, messageType)!;

            logger.LogInformation("Publishing message {Id} of type {EventType} (attempt {AttemptCount}/{MaxAttempts})",
                message.Id, message.EventType, message.AttemptCount, message.MaxAttempts);

            await publish.Publish(deserializedMessage, cancellationToken);

            // Increment attempt count for successful publish
            message.IncreaseAttemptCount();

            logger.LogInformation("Successfully published message {Id} of type {EventType} (attempt {AttemptCount})",
                message.Id, message.EventType, message.AttemptCount);

            // Success - mark as processed
            updateQueue.Enqueue(new OutboxUpdate(
                message.Id,
                DateTimeOffset.UtcNow,
                null,
                message.AttemptCount,
                null));
        }
        catch (Exception ex)
        {
            var currentTime = DateTimeOffset.UtcNow;
            message.RecordFailedAttempt(ex.ToString(), currentTime);

            if (message.IsPermanentlyFailed())
            {
                // Permanently failed - mark as processed with error
                updateQueue.Enqueue(new OutboxUpdate(
                    message.Id,
                    currentTime,
                    message.LastErrorMessage,
                    message.AttemptCount,
                    null));

                logger.LogError(ex, "Permanently failed to publish outbox message {Id} after {AttemptCount} attempts",
                    message.Id, message.AttemptCount);
            }
            else
            {
                // Schedule for retry
                updateQueue.Enqueue(new OutboxUpdate(
                    message.Id,
                    currentTime,
                    message.LastErrorMessage,
                    message.AttemptCount,
                    message.NextAttemptOnUtc));

                logger.LogWarning(ex, "Failed to publish outbox message {Id} (attempt {AttemptCount}/{MaxAttempts}), will retry at {NextAttemptOnUtc}",
                    message.Id, message.AttemptCount, message.MaxAttempts, message.NextAttemptOnUtc);
            }
        }
    }

    private static Type GetOrAddMessageType(string typename)
    {
        return TypeCache.GetOrAdd(typename, name => Type.GetType(name)!);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Worker/Catalog.Woker.Outbox/Structs/OutboxUpdate.cs">
namespace Catalog.Worker.Outbox.Structs;

public record struct OutboxUpdate(
    Guid Id,
    DateTimeOffset ProcessedOnUtc,
    string? LastErrorMessage,
    int AttemptCount,
    DateTimeOffset? NextAttemptOnUtc);
</file>

<file path="Services/Catalog/Worker/Catalog.Woker.Outbox/Catalog.Worker.Outbox.csproj">
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <PropertyGroup>
    <UserSecretsId>dotnet-Worker-7f7483a9-e5da-45da-b9d6-631ff820055e</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Catalog.Domain\Catalog.Domain.csproj" />
    <ProjectReference Include="..\..\Core\Catalog.Infrastructure\Catalog.Infrastructure.csproj" />
  </ItemGroup>
</Project>
</file>

<file path="Services/Catalog/Worker/Catalog.Woker.Outbox/DependencyInjection.cs">
#region using

using BuildingBlocks.Logging;
using EventSourcing.MassTransit;
using Catalog.Worker.Outbox.Processors;
using System.Reflection;

#endregion

namespace Catalog.Worker.Outbox;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddWorkerServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddSerilogLogging(cfg);
        services.AddMessageBroker(cfg, Assembly.GetExecutingAssembly());
        services.AddScoped<OutboxProcessor>();

        return services;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Worker/Catalog.Woker.Outbox/Program.cs">
#region using

using Catalog.Application;
using Catalog.Infrastructure;
using Catalog.Worker.Outbox;
using Catalog.Worker.Outbox.BackgroundServices;

#endregion

var builder = Host.CreateApplicationBuilder(args);

builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddWorkerServices(builder.Configuration)
    .AddHostedService<OutboxBackgroundService>();

var host = builder.Build();

host.Run();
</file>

<file path="Services/Catalog/Worker/Catalog.Worker.Consumer/BackgroundServices/CatalogBackgroudService.cs">
namespace Catalog.Worker.Consumer.BackgroundServices;

public class CatalogBackgroudService(ILogger<CatalogBackgroudService> logger) : BackgroundService
{
    #region Methods

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        logger.LogInformation("Worker starting at: {time}", DateTimeOffset.Now);

        while (!stoppingToken.IsCancellationRequested)
        {
            await Task.Delay(1000, stoppingToken);
        }

        logger.LogInformation("Worker stoping at: {time}", DateTimeOffset.Now);
    }

    #endregion
}
</file>

<file path="Services/Catalog/Worker/Catalog.Worker.Consumer/EventHandlers/Integrations/StockChangedEventHandler.cs">
#region using

using Common.ValueObjects;
using Catalog.Application.Features.Product.Commands;
using Catalog.Domain.Enums;
using Common.Constants;
using EventSourcing.Events.Inventories;
using MassTransit;
using MediatR;

#endregion

namespace Catalog.Worker.Consumer.EventHandlers.Integrations;

public sealed class StockChangedEventHandler(IMediator sender, ILogger<StockChangedEventHandler> logger)
    : IConsumer<StockChangedIntegrationEvent>
{
    #region Methods

    public async Task Consume(ConsumeContext<StockChangedIntegrationEvent> context)
    {
        logger.LogInformation("Integration Event handled: {IntegrationEvent}", context.Message.GetType().Name);

        var message = context.Message;

        if (message.Amount > 0)
        {
            await sender.Send(new ChangeProductStatusCommand(message.ProductId, ProductStatus.InStock, Actor.Worker(AppConstants.Service.Catalog)));
        }
        else
        {
            await sender.Send(new ChangeProductStatusCommand(message.ProductId, ProductStatus.OutOfStock, Actor.Worker(AppConstants.Service.Catalog)));
        }
    }

    #endregion
}
</file>

<file path="Services/Catalog/Worker/Catalog.Worker.Consumer/Catalog.Worker.Consumer.csproj">
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <PropertyGroup>
    <UserSecretsId>dotnet-Worker-90f825b9-6755-4208-b522-3eec123e375c</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Catalog.Application\Catalog.Application.csproj" />
    <ProjectReference Include="..\..\Core\Catalog.Infrastructure\Catalog.Infrastructure.csproj" />
  </ItemGroup>
</Project>
</file>

<file path="Services/Catalog/Worker/Catalog.Worker.Consumer/DependencyInjection.cs">
#region using

using BuildingBlocks.Logging;
using EventSourcing.MassTransit;
using System.Reflection;

#endregion

namespace Catalog.Worker.Consumer;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddWorkerServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddSerilogLogging(cfg);
        services.AddMessageBroker(cfg, Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Catalog/Worker/Catalog.Worker.Consumer/Program.cs">
#region using

using Catalog.Application;
using Catalog.Infrastructure;
using Catalog.Worker.Consumer;
using Catalog.Worker.Consumer.BackgroundServices;

#endregion

var builder = Host.CreateApplicationBuilder(args);

builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddWorkerServices(builder.Configuration)
    .AddHostedService<CatalogBackgroudService>();

var host = builder.Build();
host.Run();
</file>

<file path="Services/Communication/Api/Communication.Api/Constants/ApiRoutes.cs">
namespace Communication.Api.Constants;

public sealed class ApiRoutes
{
    public static class Hub
    {
        #region Constants

        public const string NotificationHub = "/hubs/notifications";

        #endregion
    }
}
</file>

<file path="Services/Communication/Api/Communication.Api/EventHandlers/Integrations/OrderCreatedIntegrationEventHandler.cs">
#region using

using Communication.Api.Models;
using Communication.Api.Services;
using EventSourcing.Events.Orders;
using MassTransit;

#endregion

namespace Communication.Api.EventHandlers.Integrations;

public sealed class OrderCreatedIntegrationEventHandler(
    INotificationHubService notificationHubService,
    ILogger<OrderCreatedIntegrationEventHandler> logger)
    : IConsumer<OrderCreatedIntegrationEvent>
{
    #region Methods

    public async Task Consume(ConsumeContext<OrderCreatedIntegrationEvent> context)
    {
        logger.LogInformation("Integration Event handled: {IntegrationEvent}", context.Message.GetType().Name);

        var message = context.Message;

        try
        {
            var notification = new NotificationDto
            {
                Type = NotificationType.OrderCreated,
                Title = "New Order Created",
                Message = $"You have new order #{message.OrderNo}. Total: {message.FinalPrice:C}",
                Data = message
            };

            await notificationHubService.BroadcastNotificationAsync(notification, context.CancellationToken);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error handling OrderCreatedIntegrationEvent for OrderNo: {OrderNo}", message.OrderNo);
        }
    }

    #endregion
}
</file>

<file path="Services/Communication/Api/Communication.Api/Hubs/NotificationHub.cs">
#region using

using Microsoft.AspNetCore.SignalR;
using System.Security.Claims;

#endregion

namespace Communication.Api.Hubs;

public sealed class NotificationHub : Hub
{
    #region Fields, Properties and Indexers

    private const string UserGroupPrefix = "user_";

    #endregion

    #region Methods

    public override async Task OnConnectedAsync()
    {
        var userId = GetUserId();
        if (!string.IsNullOrEmpty(userId))
        {
            var groupName = GetUserGroupName(userId);
            await Groups.AddToGroupAsync(Context.ConnectionId, groupName);
        }

        await base.OnConnectedAsync();
    }

    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        var userId = GetUserId();
        if (!string.IsNullOrEmpty(userId))
        {
            var groupName = GetUserGroupName(userId);
            await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName);
        }

        await base.OnDisconnectedAsync(exception);
    }

    public async Task JoinGroup(string userId)
    {
        if (string.IsNullOrEmpty(userId))
            return;

        var groupName = GetUserGroupName(userId);
        await Groups.AddToGroupAsync(Context.ConnectionId, groupName);
    }

    public async Task LeaveGroup(string userId)
    {
        if (string.IsNullOrEmpty(userId))
            return;

        var groupName = GetUserGroupName(userId);
        await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName);
    }

    #endregion

    #region Private Methods

    private string? GetUserId()
    {
        return Context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    }

    private static string GetUserGroupName(string userId)
    {
        return $"{UserGroupPrefix}{userId}";
    }

    #endregion
}
</file>

<file path="Services/Communication/Api/Communication.Api/Models/NotificationDto.cs">
#region using

#endregion

namespace Communication.Api.Models;

public sealed class NotificationDto
{
    #region Fields, Properties and Indexers

    public NotificationType Type { get; set; }

    public string Title { get; set; } = default!;

    public string Message { get; set; } = default!;

    public object? Data { get; set; }

    public DateTimeOffset Timestamp { get; set; }

    public string? UserId { get; set; }

    #endregion
}
</file>

<file path="Services/Communication/Api/Communication.Api/Models/NotificationType.cs">
#region using

#endregion

namespace Communication.Api.Models;

public enum NotificationType
{
    General = 0,
    OrderCreated = 1
}
</file>

<file path="Services/Communication/Api/Communication.Api/Services/INotificationHubService.cs">
#region using

using Communication.Api.Models;

#endregion

namespace Communication.Api.Services;

public interface INotificationHubService
{
    #region Methods

    Task BroadcastNotificationAsync(NotificationDto notification, CancellationToken cancellationToken = default);

    Task SendToUserAsync(string userId, NotificationDto notification, CancellationToken cancellationToken = default);

    Task SendToUsersAsync(List<string> userIds, NotificationDto notification, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Communication/Api/Communication.Api/Services/NotificationHubService.cs">
#region using

using Communication.Api.Hubs;
using Communication.Api.Models;
using Microsoft.AspNetCore.SignalR;

#endregion

namespace Communication.Api.Services;

public sealed class NotificationHubService : INotificationHubService
{
    #region Fields, Properties and Indexers

    private readonly IHubContext<NotificationHub> _hubContext;

    private readonly ILogger<NotificationHubService> _logger;

    private const string UserGroupPrefix = "user_";

    private const string ReceiveNotificationMethod = "ReceiveNotification";

    #endregion

    #region Ctors

    public NotificationHubService(
        IHubContext<NotificationHub> hubContext,
        ILogger<NotificationHubService> logger)
    {
        _hubContext = hubContext;
        _logger = logger;
    }

    #endregion

    #region Implementations

    public async Task BroadcastNotificationAsync(NotificationDto notification, CancellationToken cancellationToken = default)
    {
        try
        {
            notification.Timestamp = DateTimeOffset.UtcNow;
            await _hubContext.Clients.All.SendAsync(ReceiveNotificationMethod, notification, cancellationToken);
            _logger.LogInformation("Broadcast notification sent: {Type} - {Title}", notification.Type, notification.Title);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error broadcasting notification: {Type} - {Title}", notification.Type, notification.Title);
        }
    }

    public async Task SendToUserAsync(string userId, NotificationDto notification, CancellationToken cancellationToken = default)
    {
        try
        {
            if (string.IsNullOrEmpty(userId))
            {
                _logger.LogWarning("Cannot send notification to user: userId is null or empty");
                return;
            }

            notification.Timestamp = DateTimeOffset.UtcNow;
            notification.UserId = userId;
            var groupName = $"{UserGroupPrefix}{userId}";
            await _hubContext.Clients.Group(groupName).SendAsync(ReceiveNotificationMethod, notification, cancellationToken);
            _logger.LogInformation("Notification sent to user {UserId}: {Type} - {Title}", userId, notification.Type, notification.Title);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending notification to user {UserId}: {Type} - {Title}", userId, notification.Type, notification.Title);
        }
    }

    public async Task SendToUsersAsync(List<string> userIds, NotificationDto notification, CancellationToken cancellationToken = default)
    {
        try
        {
            if (userIds == null || userIds.Count == 0)
            {
                _logger.LogWarning("Cannot send notification to users: userIds list is null or empty");
                return;
            }

            notification.Timestamp = DateTimeOffset.UtcNow;
            var tasks = userIds.Select(userId =>
            {
                var groupName = $"{UserGroupPrefix}{userId}";
                return _hubContext.Clients.Group(groupName).SendAsync(ReceiveNotificationMethod, notification, cancellationToken);
            });

            await Task.WhenAll(tasks);
            _logger.LogInformation("Notification sent to {Count} users: {Type} - {Title}", userIds.Count, notification.Type, notification.Title);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending notification to multiple users: {Type} - {Title}", notification.Type, notification.Title);
        }
    }

    #endregion
}
</file>

<file path="Services/Communication/Api/Communication.Api/Communication.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <UserSecretsId>68beccec-977d-4711-a7f7-5d8d06e5c2e0</UserSecretsId>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" />
    <PackageReference Include="Microsoft.AspNetCore.SignalR" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
  </ItemGroup>
  
  <ItemGroup>
    <Folder Include="Models\" />
  </ItemGroup>
  
</Project>
</file>

<file path="Services/Communication/Api/Communication.Api/DependencyInjection.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using Communication.Api.Constants;
using Communication.Api.Hubs;
using Communication.Api.Services;
using EventSourcing.MassTransit;
using HealthChecks.UI.Client;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using System.Reflection;

#endregion

namespace Communication.Api;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddApiServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddMessageBroker(cfg, Assembly.GetExecutingAssembly());
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services.AddHttpContextAccessor();
        services.AddAuthenticationAndAuthorization(cfg);
        services.AddSignalR();
        services.AddScoped<INotificationHubService, NotificationHubService>();

        return services;
    }

    public static WebApplication UseApi(this WebApplication app)
    {
        app.UseSerilogReqLogging();
        app.UsePrometheusEndpoint();
        app.UseExceptionHandler(options => { });
        app.UseHealthChecks("/health",
            new HealthCheckOptions
            {
                ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
            });

        app.UseAuthentication();
        app.UseAuthorization();
        app.MapHub<NotificationHub>(ApiRoutes.Hub.NotificationHub);

        return app;
    }

    #endregion

}
</file>

<file path="Services/Communication/Api/Communication.Api/GlobalUsing.cs">
global using Common.Models.Reponses;
</file>

<file path="Services/Communication/Api/Communication.Api/Program.cs">
#region using

using Communication.Api;

#endregion

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApiServices(builder.Configuration);

var app = builder.Build();

// Configure the HTTP request pipeline.
app.UseApi();

app.MapGet("/", (IWebHostEnvironment env) => new ApiDefaultPathResponse
{
    Service = "Communication.Api",
    Status = "Running",
    Timestamp = DateTimeOffset.UtcNow,
    Environment = env.EnvironmentName,
    Endpoints = new Dictionary<string, string>
    {
        { "health", "/health" }
    },
    Message = "API is running..."
});

app.Run();
</file>

<file path="Services/Discount/Api/Discount.Api/Constants/ApiRoutes.cs">
namespace Discount.Api.Constants;

public sealed class ApiRoutes
{
    public static class Basket
    {
        #region Constants

        public const string Tags = "Baskets";

        private const string Base = "/basket";

        public const string GetBasket = $"{Base}";

        public const string StoreBasket = $"{Base}";

        public const string DeleteBasket = $"{Base}";

        public const string CheckoutBasket = $"{Base}/checkout";

        #endregion
    }

    public static class Coupon
    {
        #region Constants

        public const string Tags = "Coupons";

        private const string BaseAdmin = "/admin/coupons";

        private const string Base = "/coupons";

        public const string CreateCoupon = $"{BaseAdmin}";

        public const string UpdateCoupon = $"{BaseAdmin}/{{id}}";

        public const string DeleteCoupon = $"{BaseAdmin}/{{id}}";

        public const string ApproveCoupon = $"{BaseAdmin}/{{id}}/approve";

        public const string RejectCoupon = $"{BaseAdmin}/{{id}}/reject";

        public const string GetCoupon = $"{BaseAdmin}/{{id}}";

        public const string GetCoupons = $"{BaseAdmin}";

        public const string GetAlloupons = $"{BaseAdmin}/all";

        public const string GetCouponsApproved = $"{BaseAdmin}/approved";

        public const string UpdateValidityPeriod = $"{BaseAdmin}/{{id}}/validity-period";

        public const string GetCouponByCode = $"{Base}/code/{{code}}";

        public const string EvaluateCoupon = $"{Base}/evaluate";

        #endregion
    }
}
</file>

<file path="Services/Discount/Api/Discount.Api/Endpoints/ApproveCoupon.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Discount.Api.Constants;
using Discount.Application.Features.Coupon.Commands;

#endregion

namespace Discount.Api.Endpoints;

public sealed class ApproveCoupon : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Coupon.ApproveCoupon, HandleApproveCouponAsync)
            .WithTags(ApiRoutes.Coupon.Tags)
            .WithName(nameof(ApproveCoupon))
            .Produces<ApiUpdatedResponse<bool>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<bool>> HandleApproveCouponAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        Guid id)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new ApproveCouponCommand(id, Actor.User(currentUser.Email));

        var result = await sender.Send(command);

        return new ApiUpdatedResponse<bool>(result);
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Api/Endpoints/CreateCoupon.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Discount.Api.Constants;
using Discount.Application.Features.Coupon.Commands;
using Discount.Application.Dtos.Coupons;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Discount.Api.Endpoints;

public sealed class CreateCoupon : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Coupon.CreateCoupon, HandleCreateCouponAsync)
            .WithTags(ApiRoutes.Coupon.Tags)
            .WithName(nameof(CreateCoupon))
            .Produces<ApiCreatedResponse<Guid>>(StatusCodes.Status201Created)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .DisableAntiforgery()
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiCreatedResponse<Guid>> HandleCreateCouponAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromBody] CreateCouponDto dto)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new CreateCouponCommand(dto, Actor.User(currentUser.Email));
        var id = await sender.Send(command);

        return new ApiCreatedResponse<Guid>(id);
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Api/Endpoints/DeleteCoupon.cs">
#region using

using Discount.Api.Constants;
using Discount.Application.Features.Coupon.Commands;

#endregion

namespace Discount.Api.Endpoints;

public sealed class DeleteCoupon : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapDelete(ApiRoutes.Coupon.DeleteCoupon, HandleDeleteCouponAsync)
            .WithTags(ApiRoutes.Coupon.Tags)
            .WithName(nameof(DeleteCoupon))
            .Produces<ApiDeletedResponse<Guid>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiDeletedResponse<Guid>> HandleDeleteCouponAsync(
        ISender sender,
        Guid id)
    {
        var command = new DeleteCouponCommand(id);

        await sender.Send(command);

        return new ApiDeletedResponse<Guid>(id);
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Api/Endpoints/EvaluateCoupon.cs">
#region using

using Discount.Api.Constants;
using Discount.Application.Features.Coupon.Commands;
using Discount.Application.Dtos.Coupons;
using Discount.Application.Models.Results;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Discount.Api.Endpoints;

public sealed class EvaluateCoupon : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Coupon.EvaluateCoupon, HandleEvaluateCouponAsync)
            .WithTags(ApiRoutes.Coupon.Tags)
            .WithName(nameof(EvaluateCoupon))
            .Produces<ApiPerformedResponse<EvaluateCouponResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .DisableAntiforgery();
    }

    #endregion

    #region Methods

    private async Task<ApiPerformedResponse<EvaluateCouponResult>> HandleEvaluateCouponAsync(
        ISender sender,
        [FromBody] EvaluateCouponDto dto)
    {
        var command = new EvaluateCouponCommand(dto);

        var result = await sender.Send(command);

        return new ApiPerformedResponse<EvaluateCouponResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Api/Endpoints/GetAllCoupons.cs">
#region using

using Discount.Api.Constants;
using Discount.Application.Features.Coupon.Queries;
using Discount.Application.Models.Results;

#endregion

namespace Discount.Api.Endpoints;

public sealed class GetAllCoupons : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Coupon.GetAlloupons, HandleGetAllCouponsAsync)
            .WithTags(ApiRoutes.Coupon.Tags)
            .WithName(nameof(GetAllCoupons))
            .Produces<ApiGetResponse<GetCouponsResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetCouponsResult>> HandleGetAllCouponsAsync(
        ISender sender)
    {
        var query = new GetAllCouponsQuery();
        var result = await sender.Send(query);

        return new ApiGetResponse<GetCouponsResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Api/Endpoints/GetCoupon.cs">
#region using

using Discount.Api.Constants;
using Discount.Application.Features.Coupon.Queries;
using Discount.Application.Models.Results;

#endregion

namespace Discount.Api.Endpoints;

public sealed class GetCoupon : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Coupon.GetCoupon, HandleGetCouponAsync)
            .WithTags(ApiRoutes.Coupon.Tags)
            .WithName(nameof(GetCoupon))
            .Produces<ApiGetResponse<GetCouponByIdResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetCouponByIdResult>> HandleGetCouponAsync(
        ISender sender,
        Guid id)
    {
        var query = new GetCouponByIdQuery(id);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetCouponByIdResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Api/Endpoints/GetCouponByCode.cs">
#region using

using Discount.Api.Constants;
using Discount.Application.Features.Coupon.Queries;
using Discount.Application.Models.Results;

#endregion

namespace Discount.Api.Endpoints;

public sealed class GetCouponByCode : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Coupon.GetCouponByCode, HandleGetCouponByCodeAsync)
            .WithTags(ApiRoutes.Coupon.Tags)
            .WithName(nameof(GetCouponByCode))
            .Produces<ApiGetResponse<GetCouponByIdResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status404NotFound);
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetCouponByIdResult>> HandleGetCouponByCodeAsync(
        ISender sender,
        string code)
    {
        var query = new GetCouponByCodeQuery(code);

        var result = await sender.Send(query);

        return new ApiGetResponse<GetCouponByIdResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Api/Endpoints/GetCoupons.cs">
#region using

using Discount.Api.Constants;
using Discount.Application.Features.Coupon.Queries;
using Discount.Application.Models.Results;
using Discount.Domain.Enums;

#endregion

namespace Discount.Api.Endpoints;

public sealed class GetCoupons : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Coupon.GetCoupons, HandleGetCouponsAsync)
            .WithTags(ApiRoutes.Coupon.Tags)
            .WithName(nameof(GetCoupons))
            .Produces<ApiGetResponse<GetCouponsResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetCouponsResult>> HandleGetCouponsAsync(
        ISender sender,
        CouponStatus? status = null,
        CouponType? type = null,
        bool? validOnly = null)
    {
        var query = new GetCouponsQuery(status, type, validOnly);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetCouponsResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Api/Endpoints/GetCouponsApproved.cs">
#region using

using Discount.Api.Constants;
using Discount.Application.Features.Coupon.Queries;
using Discount.Application.Models.Results;

#endregion

namespace Discount.Api.Endpoints;

public sealed class GetCouponsApproved : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Coupon.GetCouponsApproved, HandleGetCouponsApprovedAsync)
            .WithTags(ApiRoutes.Coupon.Tags)
            .WithName(nameof(GetCouponsApproved))
            .Produces<ApiGetResponse<GetCouponsResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetCouponsResult>> HandleGetCouponsApprovedAsync(
        ISender sender)
    {
        var query = new GetCouponsApprovedQuery();
        var result = await sender.Send(query);

        return new ApiGetResponse<GetCouponsResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Api/Endpoints/RejectCoupon.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Discount.Api.Constants;
using Discount.Application.Features.Coupon.Commands;

#endregion

namespace Discount.Api.Endpoints;

public sealed class RejectCoupon : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Coupon.RejectCoupon, HandleRejectCouponAsync)
            .WithTags(ApiRoutes.Coupon.Tags)
            .WithName(nameof(RejectCoupon))
            .Produces<ApiUpdatedResponse<bool>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<bool>> HandleRejectCouponAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        Guid id)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new RejectCouponCommand(id, Actor.User(currentUser.Email));
        var result = await sender.Send(command);

        return new ApiUpdatedResponse<bool>(result);
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Api/Endpoints/UpdateCoupon.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Discount.Api.Constants;
using Discount.Application.Features.Coupon.Commands;
using Discount.Application.Dtos.Coupons;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Discount.Api.Endpoints;

public sealed class UpdateCoupon : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPut(ApiRoutes.Coupon.UpdateCoupon, HandleUpdateCouponAsync)
            .WithTags(ApiRoutes.Coupon.Tags)
            .WithName(nameof(UpdateCoupon))
            .Produces<ApiUpdatedResponse<bool>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .DisableAntiforgery()
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<bool>> HandleUpdateCouponAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        Guid id,
        [FromBody] UpdateCouponDto dto)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new UpdateCouponCommand(id, dto, Actor.User(currentUser.Email));
        var result = await sender.Send(command);

        return new ApiUpdatedResponse<bool>(result);
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Api/Endpoints/UpdateValidityPeriod.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Discount.Api.Constants;
using Discount.Application.Features.Coupon.Commands;
using Discount.Application.Dtos.Coupons;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Discount.Api.Endpoints;

public sealed class UpdateValidityPeriod : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPut(ApiRoutes.Coupon.UpdateValidityPeriod, HandleUpdateValidityPeriodAsync)
            .WithTags(ApiRoutes.Coupon.Tags)
            .WithName(nameof(UpdateValidityPeriod))
            .Produces<ApiUpdatedResponse<bool>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .DisableAntiforgery()
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<bool>> HandleUpdateValidityPeriodAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        Guid id,
        [FromBody] UpdateValidityPeriodDto dto)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new UpdateValidityPeriodCommand(id, dto, Actor.User(currentUser.Email));
        var result = await sender.Send(command);

        return new ApiUpdatedResponse<bool>(result);
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Api/DependencyInjection.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using BuildingBlocks.Swagger.Extensions;
using Common.Configurations;
using Common.Constants;
using HealthChecks.UI.Client;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;

#endregion

namespace Discount.Api;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddApiServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services.AddCarter();

        // HealthChecks
        {
            var dbype = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DbType}"];
            var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];
            var dbName = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DatabaseName}"];

            switch (dbype)
            {
                case DatabaseType.SqlServer:
                    services.AddHealthChecks()
                        .AddSqlServer(connectionString: conn!);
                    break;
                case DatabaseType.MySql:
                    services.AddHealthChecks()
                        .AddMySql(connectionString: conn!);
                    break;
                case DatabaseType.PostgreSql:
                    services.AddHealthChecks()
                        .AddNpgSql(connectionString: conn!);
                    break;
                case DatabaseType.MongoDb:
                    services.AddHealthChecks()
                        .AddMongoDb(
                            clientFactory: sp => new MongoDB.Driver.MongoClient(conn!),
                            databaseNameFactory: sp => dbName!);
                    break;
                default:
                    throw new Exception("Unsupported database type");
            }
        }

        services.AddHttpContextAccessor();
        services.AddAuthenticationAndAuthorization(cfg);
        services.AddSwaggerServices(cfg);

        return services;
    }

    public static WebApplication UseApi(this WebApplication app)
    {
        app.UseSerilogReqLogging();
        app.UsePrometheusEndpoint();
        app.MapCarter();
        app.UseExceptionHandler(options => { });
        app.UseHealthChecks("/health",
            new HealthCheckOptions
            {
                ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
            });

        app.UseAuthentication();
        app.UseAuthorization();
        app.UseSwaggerApi();

        app.MapGet("/", (IWebHostEnvironment env) => new ApiDefaultPathResponse
        {
            Service = "Discount.Api",
            Status = "Running",
            Timestamp = DateTimeOffset.UtcNow,
            Environment = env.EnvironmentName,
            Endpoints = new Dictionary<string, string>
            {
                { "health", "/health" }
            },
            Message = "API is running..."
        });

        return app;
    }

    #endregion

}
</file>

<file path="Services/Discount/Api/Discount.Api/Discount.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <UserSecretsId>68beccec-977d-4711-a7f7-5d8d06e5c2e0</UserSecretsId>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="AspNetCore.HealthChecks.MongoDb" />
    <PackageReference Include="AspNetCore.HealthChecks.MySql" />
    <PackageReference Include="AspNetCore.HealthChecks.NpgSql" />
    <PackageReference Include="AspNetCore.HealthChecks.Redis" />
    <PackageReference Include="AspNetCore.HealthChecks.SqlServer" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" />
    <PackageReference Include="Carter" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Discount.Application\Discount.Application.csproj" />
    <ProjectReference Include="..\..\Core\Discount.Infrastructure\Discount.Infrastructure.csproj" />
  </ItemGroup>
  
  <ItemGroup>
    <Folder Include="Models\" />
  </ItemGroup>
  
</Project>
</file>

<file path="Services/Discount/Api/Discount.Api/GlobalUsing.cs">
global using Carter;
global using MediatR;
global using Common.ValueObjects;
global using Common.Models.Reponses;
</file>

<file path="Services/Discount/Api/Discount.Api/Program.cs">
#region using

using Discount.Api;
using Discount.Application;
using Discount.Infrastructure;

#endregion

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddApiServices(builder.Configuration);

var app = builder.Build();

// Configure the HTTP request pipeline.
app.UseApi();
app.UseInfrastructure();

app.Run();
</file>

<file path="Services/Discount/Api/Discount.Grpc/Interceptors/ApiKeyValidationInterceptor.cs">
#region using

using Common.Configurations;
using Common.Constants;
using Grpc.Core;
using Grpc.Core.Interceptors;

#endregion

namespace Discount.Grpc.Interceptors;

public class ApiKeyValidationInterceptor(IConfiguration cfg) : Interceptor
{
    #region Methods

    public override async Task<TResponse> UnaryServerHandler<TRequest, TResponse>(
        TRequest request,
        ServerCallContext context,
        UnaryServerMethod<TRequest, TResponse> continuation)
    {
        var provided = context.RequestHeaders.FirstOrDefault(h => h.Key == ReqHeaderName.GrpcKey)?.Value;
        var grpcKey = cfg.GetValue<string>($"{AppConfigCfg.Section}:{AppConfigCfg.GrpcApiKey}");

        if (string.IsNullOrEmpty(provided) || !TimeConstantEquals(provided, grpcKey!))
        {
            throw new RpcException(new Status(StatusCode.Unauthenticated, MessageCode.Unauthorized));
        }

        return await continuation(request, context);
    }

    // Constant-time comparison to mitigate timing attacks (micro-optimization).
    private static bool TimeConstantEquals(string a, string b)
    {
        if (a.Length != b.Length) return false;
        var diff = 0;
        for (int i = 0; i < a.Length; i++)
            diff |= a[i] ^ b[i];
        return diff == 0;
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Grpc/Services/DiscountGrpcService.cs">
#region using

using Discount.Application.Features.Coupon.Commands;
using Discount.Application.Dtos.Coupons;
using Grpc.Core;
using MediatR;

#endregion

namespace Discount.Grpc.Services;

public sealed class DiscountGrpcService(ISender sender) : DiscountGrpc.DiscountGrpcBase
{
    #region Methods

    public override async Task<ApplyCouponResponse> ApplyCoupon(ApplyCouponRequest request, ServerCallContext context)
    {
        var dto = new ApplyCouponDto()
        {
            Code = request.Code
        };

        var result = await sender.Send(new ApplyCouponCommand(dto));

        var response = new ApplyCouponResponse
        {
            CouponCode = result.CouponCode
        };

        return response;
    }

    public override async Task<EvaluateCouponResponse> EvaluateCoupon(EvaluateCouponRequest request, ServerCallContext context)
    {
        var dto = new EvaluateCouponDto()
        {
            Code = request.Code,
            Amount = (decimal)request.Amount
        };

        var result = await sender.Send(new EvaluateCouponCommand(dto));

        var response = new EvaluateCouponResponse
        {
            CouponCode = result.CouponCode,
            DiscountAmount = (double)result.DiscountAmount,
            FinalAmount = (double)result.FinalAmount,
            OriginalAmount = (double)result.OriginalAmount
        };

        return response;
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Grpc/DependencyInjection.cs">
#region using

using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using Discount.Grpc.Interceptors;

#endregion

namespace Discount.Grpc;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddGrpcServices(
       this IServiceCollection services,
       IConfiguration cfg)
    {
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services
            .AddGrpc(o =>
            {
                o.Interceptors.Add<ApiKeyValidationInterceptor>();
            })
            .AddJsonTranscoding();

        return services;
    }

    #endregion
}
</file>

<file path="Services/Discount/Api/Discount.Grpc/Discount.Grpc.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <ItemGroup>
    <Protobuf Include="..\..\..\..\Shared\Contracts\Discount.Contract\Protos\discount.proto" GrpcServices="Server" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="grpc.tools">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="microsoft.aspnetcore.grpc.jsontranscoding" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Contracts\Discount.Contract\Discount.Contract.csproj" />
    <ProjectReference Include="..\..\Core\Discount.Application\Discount.Application.csproj" />
    <ProjectReference Include="..\..\Core\Discount.Infrastructure\Discount.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Discount/Api/Discount.Grpc/Program.cs">
#region using

using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using Discount.Application;
using Discount.Grpc;
using Discount.Grpc.Services;
using Discount.Infrastructure;

#endregion

var builder = WebApplication.CreateBuilder(args);
var cfg = builder.Configuration;

// Add services to the container.
builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(cfg)
    .AddGrpcServices(cfg);

var app = builder.Build();

app.UseSerilogReqLogging();
app.UsePrometheusEndpoint();

app.MapGrpcService<DiscountGrpcService>();
app.MapGet("/", () => "Discount gRPC is running...");

app.Run();
</file>

<file path="Services/Discount/Core/Discount.Application/Dtos/Abstractions/AuditableDto.cs">
namespace Discount.Application.Dtos.Abstractions;

public abstract class AuditableDto : IAuditableDto
{
    #region Fields, Properties and Indexers

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}

public interface IAuditableDto : ICreationAuditDto, IModificationAuditDto { }
</file>

<file path="Services/Discount/Core/Discount.Application/Dtos/Abstractions/DtoId.cs">
namespace Discount.Application.Dtos.Abstractions;

public class DtoId<T> : IDtoId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    #endregion
}

public interface IDtoId<T>
{
    T Id { get; init; }
}
</file>

<file path="Services/Discount/Core/Discount.Application/Dtos/Abstractions/EntityDto.cs">
namespace Discount.Application.Dtos.Abstractions;

public abstract class EntityDto<T> : IDtoId<T>, IAuditableDto
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Dtos/Abstractions/ICreationAuditDto.cs">
namespace Discount.Application.Dtos.Abstractions;

public interface ICreationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Dtos/Abstractions/IModificationAuditDto.cs">
namespace Discount.Application.Dtos.Abstractions;

public interface IModificationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Discount/Core/Discount.Application/Dtos/Coupons/ApplyCouponDto.cs">
namespace Discount.Application.Dtos.Coupons;

public sealed class ApplyCouponDto
{
    #region Fields, Properties and Indexers

    public string Code { get; init; } = string.Empty;

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Dtos/Coupons/CouponDto.cs">
#region using

using Discount.Application.Dtos.Abstractions;
using Discount.Domain.Enums;

#endregion

namespace Discount.Application.Dtos.Coupons;

public sealed class CouponDto : EntityDto<Guid>
{
    #region Fields, Properties and Indexers

    public string Code { get; set; } = default!;

    public string Name { get; set; } = default!;

    public string? Description { get; set; }

    public CouponType Type { get; set; }

    public string DisplayType { get; set; } = default!;

    public double Value { get; set; }

    public int MaxUsage { get; set; }

    public int UsageCount { get; set; }

    public decimal? MaxDiscountAmount { get; set; }

    public decimal? MinPurchaseAmount { get; set; }

    public CouponStatus Status { get; set; }

    public string DisplayStatus { get; set; } = default!;

    public DateTime ValidFrom { get; set; }

    public DateTime ValidTo { get; set; }

    public bool IsValid { get; set; }

    public bool IsExpired { get; set; }

    public bool IsOutOfUses { get; set; }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Dtos/Coupons/CreateCouponDto.cs">
#region using

using Discount.Domain.Enums;

#endregion

namespace Discount.Application.Dtos.Coupons;

public sealed class CreateCouponDto
{
    #region Fields, Properties and Indexers

    public string Code { get; init; } = string.Empty;

    public string Name { get; set; } = default!;

    public string Description { get; init; } = string.Empty;

    public CouponType Type { get; init; }

    public double Value { get; init; }

    public int MaxUsage { get; init; }

    public decimal? MaxDiscountAmount { get; init; }

    public decimal? MinPurchaseAmount { get; init; }

    public DateTime ValidFrom { get; init; }

    public DateTime ValidTo { get; init; }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Dtos/Coupons/EvaluateCouponDto.cs">
namespace Discount.Application.Dtos.Coupons;

public class EvaluateCouponDto
{
    #region Fields, Properties and Indexers

    public string Code { get; init; } = string.Empty;

    public decimal Amount { get; init; }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Dtos/Coupons/UpdateCouponDto.cs">
#region using

using Discount.Domain.Enums;

#endregion

namespace Discount.Application.Dtos.Coupons;

public sealed class UpdateCouponDto
{
    #region Fields, Properties and Indexers

    public string Name { get; set; } = default!;

    public string? Description { get; set; }

    public double Value { get; set; }

    public int MaxUsage { get; set; }

    public decimal? MaxDiscountAmount { get; set; }

    public decimal? MinPurchaseAmount { get; set; }

    public CouponType Type { get; set; }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Dtos/Coupons/UpdateValidityPeriodDto.cs">
#region using

#endregion

namespace Discount.Application.Dtos.Coupons;

public sealed class UpdateValidityPeriodDto
{
    #region Fields, Properties and Indexers

    public DateTime ValidFrom { get; init; }

    public DateTime ValidTo { get; init; }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Exceptions/ApplicationException.cs">
namespace Discount.Application.Exceptions;

public sealed class ApplicationException : Exception
{
    #region Ctors

    public ApplicationException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Features/Coupon/Commands/ApplyCouponCommand.cs">
#region using

using Discount.Application.Dtos.Coupons;
using Discount.Application.Models.Results;
using Discount.Application.Repositories;

#endregion

namespace Discount.Application.Features.Coupon.Commands;

public sealed record ApplyCouponCommand(ApplyCouponDto Dto) : ICommand<ApplyCouponResult>;

public sealed class ApplyCouponCommandValidator : AbstractValidator<ApplyCouponCommand>
{
    #region Ctors

    public ApplyCouponCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Code)
                    .NotEmpty()
                    .WithMessage(MessageCode.BadRequest);
            });
    }

    #endregion
}

public sealed class ApplyCouponCommandHandler(ICouponRepository repository) : ICommandHandler<ApplyCouponCommand, ApplyCouponResult>
{
    #region Implementations

    public async Task<ApplyCouponResult> Handle(ApplyCouponCommand command, CancellationToken cancellationToken)
    {
        var dto = command.Dto;

        var coupon = await repository.GetByCodeAsync(dto.Code, cancellationToken)
            ?? throw new ClientValidationException(MessageCode.CouponCodeIsNotExistsOrExpired, dto.Code);

        if (!coupon.CanBeUsed())
            throw new ClientValidationException(MessageCode.CouponCodeIsNotExistsOrExpired, dto.Code);

        coupon.Apply();

        return new ApplyCouponResult(dto.Code);
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Features/Coupon/Commands/ApproveCouponCommand.cs">
#region using

using Discount.Application.Repositories;

#endregion

namespace Discount.Application.Features.Coupon.Commands;

public sealed record ApproveCouponCommand(Guid Id, Actor Actor) : ICommand<bool>;

public sealed class ApproveCouponCommandValidator : AbstractValidator<ApproveCouponCommand>
{
    #region Ctors

    public ApproveCouponCommandValidator()
    {
        RuleFor(x => x.Id)
            .NotEmpty()
            .WithMessage(MessageCode.IdIsRequired);
    }

    #endregion
}

public sealed class ApproveCouponCommandHandler(ICouponRepository repository) : ICommandHandler<ApproveCouponCommand, bool>
{
    #region Implementations

    public async Task<bool> Handle(ApproveCouponCommand command, CancellationToken cancellationToken)
    {
        var coupon = await repository.GetByIdAsync(command.Id, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound, command.Id);

        coupon.Approve(command.Actor.ToString());

        return await repository.UpdateAsync(coupon, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Features/Coupon/Commands/CreateCouponCommand.cs">
#region using

using Discount.Application.Dtos.Coupons;
using Discount.Application.Repositories;
using Discount.Domain.Entities;

#endregion

namespace Discount.Application.Features.Coupon.Commands;

public sealed record CreateCouponCommand(CreateCouponDto Dto, Actor Actor) : ICommand<Guid>;

public sealed class CreateCouponCommandValidator : AbstractValidator<CreateCouponCommand>
{
    #region Ctors

    public CreateCouponCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Code)
                    .NotEmpty()
                    .WithMessage(MessageCode.CouponCodeIsRequired)
                    .MaximumLength(50)
                    .WithMessage(MessageCode.Max50Characters);

                RuleFor(x => x.Dto.Name)
                    .NotEmpty()
                    .WithMessage(MessageCode.ProgramNameIsRequired)
                    .MaximumLength(255)
                    .WithMessage(MessageCode.Max255Characters);

                RuleFor(x => x.Dto.Description)
                    .NotEmpty()
                    .WithMessage(MessageCode.DescriptionIsRequired)
                    .MaximumLength(500)
                    .WithMessage(MessageCode.Max500Characters);

                RuleFor(x => x.Dto.Value)
                    .GreaterThan(0)
                    .WithMessage(MessageCode.PriceIsRequired);

                RuleFor(x => x.Dto.MaxUsage)
                    .GreaterThan(0)
                    .WithMessage(MessageCode.MaxUsageIsRequired);

                When(x => x.Dto.MaxDiscountAmount.HasValue, () =>
                {
                    RuleFor(x => x.Dto.MaxDiscountAmount!.Value)
                        .GreaterThanOrEqualTo(0)
                        .WithMessage(MessageCode.MaxDiscountAmountCannotBeNegative);
                });

                RuleFor(x => x.Dto.ValidFrom)
                    .NotEmpty()
                    .WithMessage(MessageCode.ValidFromIsRequired);

                RuleFor(x => x.Dto.ValidTo)
                    .NotEmpty()
                    .WithMessage(MessageCode.ValidToIsRequired)
                    .GreaterThan(x => x.Dto.ValidFrom)
                    .WithMessage(MessageCode.ValidToInvalid);

                When(x => x.Dto.Type == Discount.Domain.Enums.CouponType.Percentage, () =>
                {
                    RuleFor(x => x.Dto.Value)
                        .LessThanOrEqualTo(100)
                        .WithMessage(MessageCode.OutOfRange);
                });
            });
    }

    #endregion
}

public sealed class CreateCouponCommandHandler(ICouponRepository repository) : ICommandHandler<CreateCouponCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(CreateCouponCommand command, CancellationToken cancellationToken)
    {
        var dto = command.Dto;

        var exists = await repository.ExistsByCodeAsync(dto.Code, cancellationToken);
        if (exists)
            throw new ClientValidationException(MessageCode.CouponCodeIsExists, dto.Code);

        var coupon = CouponEntity.Create(name: dto.Name,
            id: Guid.NewGuid(),
            code: dto.Code,
            description: dto.Description,
            type: dto.Type,
            value: dto.Value,
            maxUsage: dto.MaxUsage,
            maxDiscountAmount: dto.MaxDiscountAmount,
            minPurchaseAmount: dto.MinPurchaseAmount,
            validFrom: dto.ValidFrom,
            validTo: dto.ValidTo,
            performBy: command.Actor.ToString());

        await repository.CreateAsync(coupon, cancellationToken);

        return coupon.Id;
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Features/Coupon/Commands/DeleteCouponCommand.cs">
#region using

using Discount.Application.Repositories;

#endregion

namespace Discount.Application.Features.Coupon.Commands;

public sealed record DeleteCouponCommand(Guid Id) : ICommand<bool>;

public sealed class DeleteCouponCommandValidator : AbstractValidator<DeleteCouponCommand>
{
    #region Ctors

    public DeleteCouponCommandValidator()
    {
        RuleFor(x => x.Id)
            .NotEmpty()
            .WithMessage(MessageCode.IdIsRequired);
    }

    #endregion
}

public sealed class DeleteCouponCommandHandler(ICouponRepository repository) : ICommandHandler<DeleteCouponCommand, bool>
{
    #region Implementations

    public async Task<bool> Handle(DeleteCouponCommand command, CancellationToken cancellationToken)
    {
        var exists = await repository.GetByIdAsync(command.Id, cancellationToken);
        if (exists is null)
            throw new NotFoundException(MessageCode.ResourceNotFound, command.Id);

        return await repository.DeleteAsync(command.Id, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Features/Coupon/Commands/EvaluateCouponCommand.cs">
#region using

using Discount.Application.Dtos.Coupons;
using Discount.Application.Models.Results;
using Discount.Application.Repositories;

#endregion

namespace Discount.Application.Features.Coupon.Commands;

public sealed record EvaluateCouponCommand(EvaluateCouponDto Dto) : ICommand<EvaluateCouponResult>;

public sealed class EvaluateCouponCommandValidator : AbstractValidator<EvaluateCouponCommand>
{
    #region Ctors

    public EvaluateCouponCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Code)
                    .NotEmpty()
                    .WithMessage(MessageCode.CouponCodeIsRequired);

                RuleFor(x => x.Dto.Amount)
                    .NotEmpty()
                    .WithMessage(MessageCode.PriceIsRequired);
            });
    }

    #endregion
}

public sealed class GetApplyCouponQueryHandler(ICouponRepository repository) : ICommandHandler<EvaluateCouponCommand, EvaluateCouponResult>
{
    #region Implementations

    public async Task<EvaluateCouponResult> Handle(EvaluateCouponCommand command, CancellationToken cancellationToken)
    {
        var dto = command.Dto;

        var coupon = await repository.GetByCodeAsync(dto.Code, cancellationToken)
            ?? throw new ClientValidationException(MessageCode.CouponCodeIsNotExistsOrExpired, dto.Code);

        if (!coupon.CanBeUsed())
            throw new ClientValidationException(MessageCode.CouponCodeIsNotExistsOrExpired, dto.Code);

        var discountAmount = coupon.CalculateDiscount(dto.Amount);

        return new EvaluateCouponResult(dto.Amount, discountAmount, dto.Code);
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Features/Coupon/Commands/RejectCouponCommand.cs">
#region using

using Discount.Application.Repositories;

#endregion

namespace Discount.Application.Features.Coupon.Commands;

public sealed record RejectCouponCommand(Guid Id, Actor Actor) : ICommand<bool>;

public sealed class RejectCouponCommandValidator : AbstractValidator<RejectCouponCommand>
{
    #region Ctors

    public RejectCouponCommandValidator()
    {
        RuleFor(x => x.Id)
            .NotEmpty()
            .WithMessage(MessageCode.IdIsRequired);
    }

    #endregion
}

public sealed class RejectCouponCommandHandler(ICouponRepository repository) : ICommandHandler<RejectCouponCommand, bool>
{
    #region Implementations

    public async Task<bool> Handle(RejectCouponCommand command, CancellationToken cancellationToken)
    {
        var coupon = await repository.GetByIdAsync(command.Id, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound, command.Id);

        coupon.Reject(command.Actor.ToString());

        return await repository.UpdateAsync(coupon, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Features/Coupon/Commands/UpdateCouponCommand.cs">
#region using

using Discount.Application.Dtos.Coupons;
using Discount.Application.Repositories;

#endregion

namespace Discount.Application.Features.Coupon.Commands;

public sealed record UpdateCouponCommand(Guid Id, UpdateCouponDto Dto, Actor Actor) : ICommand<bool>;

public sealed class UpdateCouponCommandValidator : AbstractValidator<UpdateCouponCommand>
{
    #region Ctors

    public UpdateCouponCommandValidator()
    {
        RuleFor(x => x.Id)
            .NotEmpty()
            .WithMessage(MessageCode.IdIsRequired);

        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Description)
                    .NotEmpty()
                    .WithMessage(MessageCode.DescriptionIsRequired)
                    .MaximumLength(500)
                    .WithMessage(MessageCode.Max500Characters);

                RuleFor(x => x.Dto.Name)
                    .NotEmpty()
                    .WithMessage(MessageCode.ProgramNameIsRequired)
                    .MaximumLength(255)
                    .WithMessage(MessageCode.Max255Characters);

                RuleFor(x => x.Dto.Value)
                    .GreaterThan(0)
                    .WithMessage(MessageCode.ValueIsRequired);

                RuleFor(x => x.Dto.MaxUsage)
                    .GreaterThan(0)
                    .WithMessage(MessageCode.MaxUsageIsRequired);

                When(x => x.Dto.MaxDiscountAmount.HasValue, () =>
                {
                    RuleFor(x => x.Dto.MaxDiscountAmount!.Value)
                        .GreaterThanOrEqualTo(0)
                        .WithMessage(MessageCode.MaxDiscountAmountCannotBeNegative);
                });
            });
    }

    #endregion
}

public sealed class UpdateCouponCommandHandler(ICouponRepository repository) : ICommandHandler<UpdateCouponCommand, bool>
{
    #region Implementations

    public async Task<bool> Handle(UpdateCouponCommand command, CancellationToken cancellationToken)
    {
        var coupon = await repository.GetByIdAsync(command.Id, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound, command.Id);

        var dto = command.Dto;

        coupon.Update(description: dto.Description,
            name: dto.Name,
            type: dto.Type,
            value: dto.Value,
            maxUsage: dto.MaxUsage,
            maxDiscountAmount: dto.MaxDiscountAmount,
            minPurchaseAmount: dto.MinPurchaseAmount,
            performBy: command.Actor.ToString());

        return await repository.UpdateAsync(coupon, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Features/Coupon/Commands/UpdateValidityPeriodCommand.cs">
#region using

using Discount.Application.Dtos.Coupons;
using Discount.Application.Repositories;

#endregion

namespace Discount.Application.Features.Coupon.Commands;

public sealed record UpdateValidityPeriodCommand(
    Guid Id,
    UpdateValidityPeriodDto Dto,
    Actor Actor) : ICommand<bool>;

public sealed class UpdateValidityPeriodCommandValidator : AbstractValidator<UpdateValidityPeriodCommand>
{
    #region Ctors

    public UpdateValidityPeriodCommandValidator()
    {
        RuleFor(x => x.Id)
            .NotEmpty()
            .WithMessage(MessageCode.IdIsRequired);

        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.ValidFrom)
                    .NotEmpty()
                    .WithMessage(MessageCode.ValidFromIsRequired);

                RuleFor(x => x.Dto.ValidTo)
                    .NotEmpty()
                    .WithMessage(MessageCode.ValidToIsRequired)
                    .GreaterThan(x => x.Dto.ValidFrom)
                    .WithMessage(MessageCode.ValidToInvalid);
            });
    }

    #endregion
}

public sealed class UpdateValidityPeriodCommandHandler(ICouponRepository repository) : ICommandHandler<UpdateValidityPeriodCommand, bool>
{
    #region Implementations

    public async Task<bool> Handle(UpdateValidityPeriodCommand command, CancellationToken cancellationToken)
    {
        var coupon = await repository.GetByIdAsync(command.Id, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound, command.Id);

        coupon.UpdateValidityPeriod(command.Dto.ValidFrom, command.Dto.ValidTo, command.Actor.ToString());

        return await repository.UpdateAsync(coupon, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Features/Coupon/Queries/GetAllCouponsQuery.cs">
#region using

using AutoMapper;
using Discount.Application.Dtos.Coupons;
using Discount.Application.Models.Results;
using Discount.Application.Repositories;

#endregion

namespace Discount.Application.Features.Coupon.Queries;

public sealed record GetAllCouponsQuery() : IQuery<GetCouponsResult>;

public sealed class GetAllCouponsQueryHandler(ICouponRepository repository, IMapper mapper) : IQueryHandler<GetAllCouponsQuery, GetCouponsResult>
{
    #region Implementations

    public async Task<GetCouponsResult> Handle(GetAllCouponsQuery query, CancellationToken cancellationToken)
    {
        var coupons = await repository.GetAllAsync(cancellationToken);
        var couponList = coupons.ToList();
        var dtos = mapper.Map<List<CouponDto>>(couponList);

        return new GetCouponsResult(dtos, couponList.Count);
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Features/Coupon/Queries/GetCouponByCodeQuery.cs">
#region using

using AutoMapper;
using Discount.Application.Dtos.Coupons;
using Discount.Application.Models.Results;
using Discount.Application.Repositories;

#endregion

namespace Discount.Application.Features.Coupon.Queries;

public sealed record GetCouponByCodeQuery(string Code) : IQuery<GetCouponByIdResult>;

public sealed class GetCouponByCodeQueryValidator : AbstractValidator<GetCouponByCodeQuery>
{
    #region Ctors

    public GetCouponByCodeQueryValidator()
    {
        RuleFor(x => x.Code)
            .NotEmpty()
            .WithMessage(MessageCode.CouponCodeIsRequired);
    }

    #endregion
}

public sealed class GetCouponByCodeQueryHandler(ICouponRepository repository, IMapper mapper) : IQueryHandler<GetCouponByCodeQuery, GetCouponByIdResult>
{
    #region Implementations

    public async Task<GetCouponByIdResult> Handle(GetCouponByCodeQuery query, CancellationToken cancellationToken)
    {
        var coupon = await repository.GetByCodeAsync(query.Code, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound, query.Code);

        var dto = mapper.Map<CouponDto>(coupon);

        return new GetCouponByIdResult(dto);
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Features/Coupon/Queries/GetCouponByIdQuery.cs">
#region using

using AutoMapper;
using Discount.Application.Dtos.Coupons;
using Discount.Application.Models.Results;
using Discount.Application.Repositories;

#endregion

namespace Discount.Application.Features.Coupon.Queries;

public sealed record GetCouponByIdQuery(Guid Id) : IQuery<GetCouponByIdResult>;

public sealed class GetCouponQueryHandler(ICouponRepository repository, IMapper mapper) : IQueryHandler<GetCouponByIdQuery, GetCouponByIdResult>
{
    #region Implementations

    public async Task<GetCouponByIdResult> Handle(GetCouponByIdQuery query, CancellationToken cancellationToken)
    {
        var coupon = await repository.GetByIdAsync(query.Id, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound, query.Id);

        var dto = mapper.Map<CouponDto>(coupon);

        return new GetCouponByIdResult(dto);
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Features/Coupon/Queries/GetCouponsApprovedQuery.cs">
#region using

using AutoMapper;
using Discount.Application.Dtos.Coupons;
using Discount.Application.Models.Results;
using Discount.Application.Repositories;
using Discount.Domain.Enums;

#endregion

namespace Discount.Application.Features.Coupon.Queries;

public sealed record GetCouponsApprovedQuery() : IQuery<GetCouponsResult>;

public sealed class GetCouponsApprovedQueryHandler(ICouponRepository repository, IMapper mapper) : IQueryHandler<GetCouponsApprovedQuery, GetCouponsResult>
{
    #region Implementations

    public async Task<GetCouponsResult> Handle(GetCouponsApprovedQuery query, CancellationToken cancellationToken)
    {
        var coupons = await repository.GetByStatusAsync(CouponStatus.Approved, cancellationToken);
        var couponList = coupons.ToList();
        var dtos = mapper.Map<List<CouponDto>>(couponList);

        return new GetCouponsResult(dtos, couponList.Count);
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Features/Coupon/Queries/GetCouponsQuery.cs">
#region using

using AutoMapper;
using Discount.Application.Dtos.Coupons;
using Discount.Application.Models.Results;
using Discount.Application.Repositories;
using Discount.Domain.Entities;
using Discount.Domain.Enums;

#endregion

namespace Discount.Application.Features.Coupon.Queries;

public sealed record GetCouponsQuery(
    CouponStatus? Status = null,
    CouponType? Type = null,
    bool? ValidOnly = null) : IQuery<GetCouponsResult>;

public sealed class GetCouponsQueryHandler(ICouponRepository repository, IMapper mapper) : IQueryHandler<GetCouponsQuery, GetCouponsResult>
{
    #region Implementations

    public async Task<GetCouponsResult> Handle(GetCouponsQuery query, CancellationToken cancellationToken)
    {
        IEnumerable<CouponEntity> coupons;

        if (query.ValidOnly == true)
        {
            coupons = await repository.GetValidCouponsAsync(cancellationToken);
        }
        else if (query.Status.HasValue)
        {
            coupons = await repository.GetByStatusAsync(query.Status.Value, cancellationToken);
        }
        else if (query.Type.HasValue)
        {
            coupons = await repository.GetByTypeAsync(query.Type.Value, cancellationToken);
        }
        else
        {
            coupons = await repository.GetAllAsync(cancellationToken);
        }

        var couponList = coupons.ToList();
        var dtos = mapper.Map<List<CouponDto>>(couponList);

        return new GetCouponsResult(dtos, couponList.Count);
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Mappings/DiscountMappingProfile.cs">
#region using

using AutoMapper;
using Discount.Application.Dtos.Coupons;
using Discount.Domain.Entities;

#endregion

namespace Discount.Application.Mappings;

public sealed class DiscountMappingProfile : Profile
{
    #region Ctors

    public DiscountMappingProfile()
    {
        CreateCouponMappings();
    }

    #endregion

    #region Methods

    private void CreateCouponMappings()
    {
        // CouponEntity -> CouponDto
        CreateMap<CouponEntity, CouponDto>()
            .ForMember(dest => dest.DisplayStatus, opt => opt.MapFrom(src => src.Status.GetDescription()))
            .ForMember(dest => dest.DisplayType, opt => opt.MapFrom(src => src.Type.GetDescription()))
            .ForMember(dest => dest.IsValid, opt => opt.MapFrom(src => src.IsValid()))
            .ForMember(dest => dest.IsExpired, opt => opt.MapFrom(src => src.IsExpired()))
            .ForMember(dest => dest.IsOutOfUses, opt => opt.MapFrom(src => src.IsOutOfUses()));
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Models/Results/ApplyCouponResult.cs">
namespace Discount.Application.Models.Results;

public sealed class ApplyCouponResult
{
    #region Fields, Properties and Indexers

    public string CouponCode { get; init; } = string.Empty;

    #endregion

    #region Ctors

    public ApplyCouponResult(string couponCode)
    {
        CouponCode = couponCode;
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Models/Results/EvaluateCouponResult.cs">
namespace Discount.Application.Models.Results;

public sealed class EvaluateCouponResult
{
    #region Fields, Properties and Indexers

    public decimal OriginalAmount { get; init; }

    public decimal DiscountAmount { get; init; }

    public decimal FinalAmount { get; init; }

    public string CouponCode { get; init; } = string.Empty;

    #endregion

    #region Ctors

    public EvaluateCouponResult(decimal originalAmount, decimal discountAmount, string couponCode)
    {
        OriginalAmount = originalAmount;
        DiscountAmount = discountAmount;
        FinalAmount = originalAmount - discountAmount;
        CouponCode = couponCode;
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Models/Results/GetCouponByIdResult.cs">
#region using

using Discount.Application.Dtos.Coupons;

#endregion

namespace Discount.Application.Models.Results;

public sealed class GetCouponByIdResult
{
    #region Fields, Properties and Indexers

    public CouponDto Coupon { get; init; }

    #endregion

    #region Ctors

    public GetCouponByIdResult(CouponDto coupon)
    {
        Coupon = coupon;
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Models/Results/GetCouponsResult.cs">
#region using

using Discount.Application.Dtos.Coupons;

#endregion

namespace Discount.Application.Models.Results;

public sealed class GetCouponsResult
{
    #region Fields, Properties and Indexers

    public IEnumerable<CouponDto> Coupons { get; init; } = Enumerable.Empty<CouponDto>();

    public int TotalCount { get; init; }

    #endregion

    #region Ctors

    public GetCouponsResult(IEnumerable<CouponDto> coupons, int totalCount)
    {
        Coupons = coupons;
        TotalCount = totalCount;
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Repositories/ICouponRepository.cs">
#region using

using Discount.Domain.Entities;
using Discount.Domain.Enums;
using Discount.Domain.ValueObjects;

#endregion

namespace Discount.Application.Repositories;

public interface ICouponRepository
{
    #region Methods

    Task<CouponEntity?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    Task<CouponEntity?> GetByCodeAsync(CouponCode code, CancellationToken cancellationToken = default);

    Task<CouponEntity?> GetByCodeAsync(string code, CancellationToken cancellationToken = default);

    Task<bool> ExistsByCodeAsync(CouponCode code, CancellationToken cancellationToken = default);

    Task<bool> ExistsByCodeAsync(string code, CancellationToken cancellationToken = default);

    Task<IEnumerable<CouponEntity>> GetByStatusAsync(CouponStatus status, CancellationToken cancellationToken = default);

    Task<IEnumerable<CouponEntity>> GetByTypeAsync(CouponType type, CancellationToken cancellationToken = default);

    Task<IEnumerable<CouponEntity>> GetValidCouponsAsync(CancellationToken cancellationToken = default);

    Task<IEnumerable<CouponEntity>> GetAllAsync(CancellationToken cancellationToken = default);

    Task<CouponEntity> CreateAsync(CouponEntity coupon, CancellationToken cancellationToken = default);

    Task<bool> UpdateAsync(CouponEntity coupon, CancellationToken cancellationToken = default);

    Task<bool> DeleteAsync(Guid id, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Repositories/IUnitOfWork.cs">
#region using

#endregion

namespace Discount.Application.Repositories;

/// <summary>
/// Unit of Work pattern interface for managing transactions and ensuring data consistency.
/// </summary>
public interface IUnitOfWork : IDisposable, IAsyncDisposable
{
    #region Properties

    /// <summary>
    /// Gets the coupon repository.
    /// </summary>
    ICouponRepository Coupons { get; }

    #endregion

    #region Methods

    /// <summary>
    /// Begins a new transaction.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Task representing the async operation.</returns>
    Task BeginTransactionAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Commits the current transaction.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Task representing the async operation.</returns>
    Task CommitTransactionAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Rolls back the current transaction.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Task representing the async operation.</returns>
    Task RollbackTransactionAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Saves all changes made in the unit of work.
    /// This will commit the transaction if one is active.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Task representing the async operation.</returns>
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Repositories/UnitOfWorkUsageExample.cs">
//#region using

//// This file contains examples of how to use Unit of Work with MongoDB transactions.
//// It is not meant to be compiled - remove this file or move examples to actual command handlers.

//#endregion

//namespace Discount.Application.Repositories;

///// <summary>
///// Example usage of Unit of Work pattern with MongoDB transactions.
///// </summary>
//public static class UnitOfWorkUsageExample
//{
//    /*
//     * EXAMPLE 1: Using Unit of Work without explicit transaction
//     * (MongoDB auto-commits each operation)
//     */
//    /*
//    public sealed class ExampleCommandHandler : ICommandHandler<ExampleCommand, bool>
//    {
//        private readonly IUnitOfWork _unitOfWork;

//        public ExampleCommandHandler(IUnitOfWork unitOfWork)
//        {
//            _unitOfWork = unitOfWork;
//        }

//        public async Task<bool> Handle(ExampleCommand command, CancellationToken cancellationToken)
//        {
//            // Operations are auto-committed by MongoDB
//            var coupon = await _unitOfWork.Coupons.GetByIdAsync(command.Id, cancellationToken);
//            if (coupon != null)
//            {
//                coupon.Approve();
//                await _unitOfWork.Coupons.UpdateAsync(coupon, cancellationToken);
//            }

//            // Optional: explicitly save (no-op if no transaction)
//            await _unitOfWork.SaveChangesAsync(cancellationToken);
//            return true;
//        }
//    }
//    */

//    /*
//     * EXAMPLE 2: Using Unit of Work with explicit transaction
//     * (Useful when you need atomicity across multiple operations)
//     */
//    /*
//    public sealed class AtomicOperationCommandHandler : ICommandHandler<AtomicOperationCommand, bool>
//    {
//        private readonly IUnitOfWork _unitOfWork;

//        public AtomicOperationCommandHandler(IUnitOfWork unitOfWork)
//        {
//            _unitOfWork = unitOfWork;
//        }

//        public async Task<bool> Handle(AtomicOperationCommand command, CancellationToken cancellationToken)
//        {
//            try
//            {
//                // Begin transaction
//                await _unitOfWork.BeginTransactionAsync(cancellationToken);

//                // Multiple operations that must be atomic
//                var coupon1 = await _unitOfWork.Coupons.GetByCodeAsync("CODE1", cancellationToken);
//                var coupon2 = await _unitOfWork.Coupons.GetByCodeAsync("CODE2", cancellationToken);

//                if (coupon1 != null && coupon2 != null)
//                {
//                    coupon1.Apply();
//                    coupon2.Apply();

//                    await _unitOfWork.Coupons.UpdateAsync(coupon1, cancellationToken);
//                    await _unitOfWork.Coupons.UpdateAsync(coupon2, cancellationToken);
//                }

//                // Commit transaction (all operations succeed or all fail)
//                await _unitOfWork.CommitTransactionAsync(cancellationToken);
//                return true;
//            }
//            catch
//            {
//                // Rollback on error
//                await _unitOfWork.RollbackTransactionAsync(cancellationToken);
//                throw;
//            }
//        }
//    }
//    */

//    /*
//     * EXAMPLE 3: Using SaveChangesAsync (automatically commits transaction if active)
//     */
//    /*
//    public sealed class SimpleCommandHandler : ICommandHandler<SimpleCommand, bool>
//    {
//        private readonly IUnitOfWork _unitOfWork;

//        public SimpleCommandHandler(IUnitOfWork unitOfWork)
//        {
//            _unitOfWork = unitOfWork;
//        }

//        public async Task<bool> Handle(SimpleCommand command, CancellationToken cancellationToken)
//        {
//            await _unitOfWork.BeginTransactionAsync(cancellationToken);

//            // Perform operations...
//            var coupon = CouponEntity.Create(/* ... */);
//            await _unitOfWork.Coupons.CreateAsync(coupon, cancellationToken);

//            // SaveChangesAsync will commit the transaction if one is active
//            await _unitOfWork.SaveChangesAsync(cancellationToken);
//            return true;
//        }
//    }
//    */

//    /*
//     * IMPORTANT NOTES:
//     * 
//     * 1. MongoDB transactions require a replica set or sharded cluster.
//     *    - Standalone MongoDB instances do NOT support transactions
//     *    - For development, you can create a single-node replica set
//     * 
//     * 2. To create a single-node replica set for development:
//     *    - Start MongoDB with: mongod --replSet rs0 --port 27017
//     *    - Connect and run: rs.initiate()
//     * 
//     * 3. If transactions are not available, operations will still work
//     *    but won't be atomic across multiple operations
//     * 
//     * 4. UnitOfWork is registered as Scoped, so it's created per HTTP request
//     *    and disposed at the end of the request
//     * 
//     * 5. Always use try-catch when using transactions to ensure proper rollback
//     */
//}
</file>

<file path="Services/Discount/Core/Discount.Application/ApplicationMarker.cs">
namespace Discount.Application;

public sealed class ApplicationMarker { }
</file>

<file path="Services/Discount/Core/Discount.Application/DependencyInjection.cs">
#region using

using BuildingBlocks.Behaviors;
using BuildingBlocks.Exceptions.Handler;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.FeatureManagement;
using System.Reflection;

#endregion

namespace Discount.Application;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddApplicationServices(this IServiceCollection services)
    {
        services.AddExceptionHandler<CustomExceptionHandler>();
        services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
        services.AddMediatR(config =>
        {
            config.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
            config.AddOpenBehavior(typeof(ValidationBehavior<,>));
            config.AddOpenBehavior(typeof(LoggingBehavior<,>));
        });
        services.AddFeatureManagement();

        // Register all AutoMapper profiles from the current assembly
        services.AddAutoMapper(Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Application/Discount.Application.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="AutoMapper" />
    <PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" />
    <PackageReference Include="Scrutor" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\Discount.Domain\Discount.Domain.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Models\Filters\" />
    <Folder Include="Models\Responses\Externals\" />
    <Folder Include="Services\" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Discount/Core/Discount.Application/GlobalUsing.cs">
global using BuildingBlocks.CQRS;
global using FluentValidation;
global using Common.Constants;
global using Common.Extensions;
global using BuildingBlocks.Exceptions;
global using Common.ValueObjects;
</file>

<file path="Services/Discount/Core/Discount.Domain/Abstractions/Aggregate.cs">
namespace Discount.Domain.Abstractions;

public abstract class Aggregate<TId> : Entity<TId>, IAggregate<TId>
{
    #region Fields, Properties and Indexers

    private readonly List<IDomainEvent> _domainEvents = new();

    #endregion

    #region Implementations

    public IReadOnlyList<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    public void AddDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }

    public IDomainEvent[] ClearDomainEvents()
    {
        IDomainEvent[] dequeuedEvents = _domainEvents.ToArray();

        _domainEvents.Clear();

        return dequeuedEvents;
    }

    #endregion

}
</file>

<file path="Services/Discount/Core/Discount.Domain/Abstractions/Entity.cs">
#region using

using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;

#endregion

namespace Discount.Domain.Abstractions;

public abstract class Entity<T> : IEntityId<T>, IAuditable
{
    #region Fields, Properties and Indexers

    [BsonId]
    [BsonRepresentation(BsonType.String)]
    public T Id { get; set; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Discount/Core/Discount.Domain/Abstractions/EntityId.cs">
#region using

using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;

#endregion

namespace Discount.Domain.Abstractions;

public abstract class EntityId<T> : IEntityId<T>
{
    #region Fields, Properties and Indexers

    [BsonId]
    [BsonRepresentation(BsonType.String)]
    public T Id { get; set; } = default!;

    #endregion

}
</file>

<file path="Services/Discount/Core/Discount.Domain/Abstractions/IAggregate.cs">
namespace Discount.Domain.Abstractions;

public interface IAggregate<T> : IAggregate, IEntityId<T>
{
}

public interface IAggregate : ICreationAuditable, IModificationAuditable
{
    #region Fields, Properties and Indexers

    IReadOnlyList<IDomainEvent> DomainEvents { get; }

    IDomainEvent[] ClearDomainEvents();

    #endregion

}
</file>

<file path="Services/Discount/Core/Discount.Domain/Abstractions/IAuditable.cs">
namespace Discount.Domain.Abstractions;

public interface IAuditable : ICreationAuditable, IModificationAuditable { }
</file>

<file path="Services/Discount/Core/Discount.Domain/Abstractions/ICreationAuditable.cs">
namespace Discount.Domain.Abstractions;

public interface ICreationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Discount/Core/Discount.Domain/Abstractions/IDomainEvent.cs">
#region using

using MediatR;

#endregion

namespace Discount.Domain.Abstractions;

public interface IDomainEvent : INotification
{
    #region Fields, Properties and Indexers

    Guid EventId => Guid.NewGuid();

    public DateTimeOffset OccurredOn => DateTime.Now;

    public string EventType => GetType()?.AssemblyQualifiedName ?? string.Empty;

    #endregion

}
</file>

<file path="Services/Discount/Core/Discount.Domain/Abstractions/IEntityId.cs">
namespace Discount.Domain.Abstractions;

public interface IEntityId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; set; }

    #endregion

}
</file>

<file path="Services/Discount/Core/Discount.Domain/Abstractions/IModificationAuditable.cs">
namespace Discount.Domain.Abstractions;

public interface IModificationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Discount/Core/Discount.Domain/Entities/CouponEntity.cs">
#region using

using Discount.Domain.Abstractions;
using Discount.Domain.Enums;

#endregion

namespace Discount.Domain.Entities;

public sealed class CouponEntity : Aggregate<Guid>
{
    #region Fields, Properties and Indexers

    public string Code { get; set; } = default!;

    public string Name { get; set; } = default!;

    public string? Description { get; set; }

    public CouponType Type { get; set; }

    public double Value { get; set; }

    public int MaxUsage { get; set; }

    public int UsageCount { get; set; }

    public decimal? MaxDiscountAmount { get; set; }

    public decimal? MinPurchaseAmount { get; set; }

    public CouponStatus Status { get; set; }

    public DateTime ValidFrom { get; set; }

    public DateTime ValidTo { get; set; }

    #endregion

    #region Factories

    public static CouponEntity Create(Guid id,
        string code,
        string name,
        string description,
        CouponType type,
        double value,
        int maxUsage,
        decimal? maxDiscountAmount,
        decimal? minPurchaseAmount,
        DateTime validFrom,
        DateTime validTo,
        string performBy)
    {
        ArgumentNullException.ThrowIfNull(code);
        ArgumentException.ThrowIfNullOrWhiteSpace(description);
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(value);
        ArgumentOutOfRangeException.ThrowIfNegative(maxUsage);

        if (maxDiscountAmount.HasValue && maxDiscountAmount.Value < 0)
            throw new ArgumentException("MaxDiscountAmount cannot be negative", nameof(maxDiscountAmount));

        if (validFrom >= validTo)
            throw new ArgumentException("ValidFrom must be before ValidTo", nameof(validTo));

        if (type == CouponType.Percentage && value > 100)
            throw new ArgumentException("Percentage value cannot exceed 100", nameof(value));

        return new CouponEntity()
        {
            Id = id,
            Code = code,
            Name = name,
            Description = description,
            Type = type,
            Value = value,
            MaxUsage = maxUsage,
            MaxDiscountAmount = maxDiscountAmount,
            MinPurchaseAmount = minPurchaseAmount,
            Status = CouponStatus.Pending,
            ValidFrom = validFrom,
            ValidTo = validTo,
            CreatedOnUtc = DateTimeOffset.UtcNow,
            CreatedBy = performBy,
            LastModifiedOnUtc = DateTimeOffset.UtcNow,
            LastModifiedBy = performBy
        };
    }

    #endregion

    #region Methods

    public void Update(string name,
        string? description,
        CouponType type,
        double value,
        int maxUsage,
        decimal? maxDiscountAmount,
        decimal? minPurchaseAmount,
        string performBy)
    {
        Name = name;
        Description = description;
        Type = type;
        Value = value;
        MaxUsage = maxUsage;
        MaxDiscountAmount = maxDiscountAmount;
        MinPurchaseAmount = minPurchaseAmount;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
        LastModifiedBy = performBy;
    }

    public void Approve(string performBy)
    {
        if (Status != CouponStatus.Pending)
            throw new InvalidOperationException("Only pending coupons can be approved");

        Status = CouponStatus.Approved;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
        LastModifiedBy = performBy;
    }

    public void Reject(string performBy)
    {
        if (Status != CouponStatus.Pending)
            throw new InvalidOperationException("Only pending coupons can be rejected");

        Status = CouponStatus.Rejected;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
        LastModifiedBy = performBy;
    }

    public void Apply()
    {
        if (!CanBeUsed())
            throw new InvalidOperationException("Coupon cannot be used");

        UsageCount++;

        if (UsageCount >= MaxUsage)
            Status = CouponStatus.OutOfStock;
    }

    public decimal CalculateDiscount(decimal originalAmount)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(originalAmount);

        decimal discount;

        if (Type == CouponType.Fixed)
        {
            discount = (decimal)Value > originalAmount ? originalAmount : (decimal)Value;
        }
        else // Percentage
        {
            discount = originalAmount * (decimal)(Value / 100.0);
            discount = discount > originalAmount ? originalAmount : discount;
        }

        // Apply MaxDiscountAmount limit if specified
        if (MaxDiscountAmount.HasValue && discount > MaxDiscountAmount.Value)
        {
            discount = MaxDiscountAmount.Value;
        }

        // Ensure discount doesn't exceed original amount
        return discount > originalAmount ? originalAmount : discount;
    }

    public void UpdateValidityPeriod(DateTime validFrom, DateTime validTo, string performBy)
    {
        if (validFrom >= validTo)
            throw new ArgumentException("ValidFrom must be before ValidTo", nameof(validTo));

        ValidFrom = validFrom;
        ValidTo = validTo;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
        LastModifiedBy = performBy;
    }

    public bool IsValid()
    {
        return Status == CouponStatus.Approved
            && DateTime.UtcNow >= ValidFrom
            && DateTime.UtcNow <= ValidTo
            && UsageCount < MaxUsage;
    }

    public bool CanBeUsed()
    {
        return IsValid();
    }

    public bool IsExpired()
    {
        return DateTime.UtcNow > ValidTo;
    }

    public bool IsOutOfUses()
    {
        return UsageCount >= MaxUsage;
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Domain/Enums/CouponStatus.cs">
#region using

using System.ComponentModel;

#endregion

namespace Discount.Domain.Enums;

public enum CouponStatus
{
    [Description("Pending")]
    Pending = 1,

    [Description("Approved")]
    Approved = 2,

    [Description("Expired")]
    Expired = 3,

    [Description("Out of Stock")]
    OutOfStock = 4,

    [Description("Rejected")]
    Rejected = 5
}
</file>

<file path="Services/Discount/Core/Discount.Domain/Enums/CouponType.cs">
#region using

using System.ComponentModel;

#endregion

namespace Discount.Domain.Enums;

public enum CouponType
{
    [Description("Fixed")]
    Fixed = 1,

    [Description("Percentage")]
    Percentage = 2
}
</file>

<file path="Services/Discount/Core/Discount.Domain/Exceptions/DomainException.cs">
namespace Discount.Domain.Exceptions;

public sealed class DomainException : Exception
{
    public DomainException(string message) : base(message)
    {
    }
}
</file>

<file path="Services/Discount/Core/Discount.Domain/ValueObjects/CouponCode.cs">
namespace Discount.Domain.ValueObjects;

public class CouponCode
{
    #region Fields, Properties and Indexers

    public string Value { get; }

    #endregion

    #region Ctors

    private CouponCode(string value) => Value = value;

    #endregion

    #region Methods

    public static CouponCode Create(string code)
    {
        return new CouponCode(code);
    }

    public override string ToString() => Value;

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Domain/Discount.Domain.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="MediatR" />
    <PackageReference Include="MongoDB.Bson" />
    <PackageReference Include="Newtonsoft.Json" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Events\" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Discount/Core/Discount.Domain/GlobalUsing.cs">

</file>

<file path="Services/Discount/Core/Discount.Infrastructure/Constants/MongoCollection.cs">
namespace Discount.Infrastructure.Constants;

public sealed class MongoCollection
{
    #region Constants

    public const string Coupon = "coupon";

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Infrastructure/Data/Extensions/DatabaseExtentions.cs">
#region using

using Common.ValueObjects;
using Discount.Domain.Entities;
using Discount.Domain.Enums;
using Discount.Infrastructure.Constants;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using MongoDB.Driver;

#endregion

namespace Discount.Infrastructure.Data.Extensions;

public static class DatabaseExtentions
{
    #region Methods

    public static async Task EnsureIndexesAsync(this WebApplication app)
    {
        var db = app.Services.GetRequiredService<IMongoDatabase>();
        var coupon = db.GetCollection<CouponEntity>(MongoCollection.Coupon);

        await coupon.Indexes.CreateOneAsync(new CreateIndexModel<CouponEntity>(
            Builders<CouponEntity>.IndexKeys
                .Ascending(x => x.Code),
            new CreateIndexOptions { Unique = true, Name = "IX_Coupon_Code_Unique" }));

        await coupon.Indexes.CreateOneAsync(new CreateIndexModel<CouponEntity>(
            Builders<CouponEntity>.IndexKeys
                .Ascending(x => x.Status),
            new CreateIndexOptions { Name = "IX_Coupon_Status" }));

        await coupon.Indexes.CreateOneAsync(new CreateIndexModel<CouponEntity>(
            Builders<CouponEntity>.IndexKeys
                .Ascending(x => x.Type),
            new CreateIndexOptions { Name = "IX_Coupon_Type" }));

        await coupon.Indexes.CreateOneAsync(new CreateIndexModel<CouponEntity>(
            Builders<CouponEntity>.IndexKeys
                .Ascending(x => x.ValidFrom),
            new CreateIndexOptions { Name = "IX_Coupon_ValidFrom" }));

        await coupon.Indexes.CreateOneAsync(new CreateIndexModel<CouponEntity>(
            Builders<CouponEntity>.IndexKeys
                .Ascending(x => x.ValidTo),
            new CreateIndexOptions { Name = "IX_Coupon_ValidTo" }));

        await coupon.Indexes.CreateOneAsync(new CreateIndexModel<CouponEntity>(
            Builders<CouponEntity>.IndexKeys
                .Ascending(x => x.Status)
                .Ascending(x => x.ValidFrom)
                .Ascending(x => x.ValidTo),
            new CreateIndexOptions { Name = "IX_Coupon_Status_ValidFrom_ValidTo" }));

        await coupon.Indexes.CreateOneAsync(new CreateIndexModel<CouponEntity>(
            Builders<CouponEntity>.IndexKeys
                .Ascending(x => x.Status)
                .Ascending(x => x.Type),
            new CreateIndexOptions { Name = "IX_Coupon_Status_Type" }));

        await coupon.Indexes.CreateOneAsync(new CreateIndexModel<CouponEntity>(
            Builders<CouponEntity>.IndexKeys
                .Ascending(x => x.UsageCount),
            new CreateIndexOptions { Name = "IX_Coupon_UsageCount" }));
    }

    public static async Task SeedDataAsync(this WebApplication app)
    {
        var db = app.Services.GetRequiredService<IMongoDatabase>();
        var couponCollection = db.GetCollection<CouponEntity>(MongoCollection.Coupon);
        var now = DateTime.UtcNow;
        var count = await couponCollection.CountDocumentsAsync(x => x.Status == CouponStatus.Approved
                && x.ValidFrom <= now
                && x.ValidTo >= now
                && x.UsageCount < x.MaxUsage);

        if (count == 0)
        {
            var fixedId = Guid.NewGuid();
            var randomFixedCoupon = CouponEntity.Create(id: fixedId,
                code: $"RND-{fixedId.ToString().Split("-").First().ToUpper()}",
                name: $"Random Fixed Coupon {fixedId.ToString().Split("-").First().ToUpper()}",
                description: "Random Fixed Coupon",
                type: Domain.Enums.CouponType.Fixed,
                value: 55000,
                maxUsage: 5,
                minPurchaseAmount: 100000,
                maxDiscountAmount: null,
                validFrom: now,
                validTo: now.AddDays(3),
                performBy: Actor.System(AppConstants.Service.Discount).ToString());
            randomFixedCoupon.Approve(Actor.System(AppConstants.Service.Discount).ToString());

            var percentageId = Guid.NewGuid();
            var randomPercentageCoupon = CouponEntity.Create(id: percentageId,
                code: $"RND-{percentageId.ToString().Split("-").First().ToUpper()}",
                name: $"Random Percentage Coupon {percentageId.ToString().Split("-").First().ToUpper()}",
                description: "Random Percentage Coupon",
                type: Domain.Enums.CouponType.Percentage,
                value: 30,
                maxUsage: 5,
                minPurchaseAmount: 100000,
                maxDiscountAmount: 25000,
                validFrom: now,
                validTo: now.AddDays(3),
                performBy: Actor.System(AppConstants.Service.Discount).ToString());
            randomPercentageCoupon.Approve(Actor.System(AppConstants.Service.Discount).ToString());

            await couponCollection.InsertManyAsync(new[] { randomFixedCoupon, randomPercentageCoupon });
        }
    }
    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Infrastructure/Exceptions/InfrastructureException.cs">
namespace Discount.Infrastructure.Exceptions;

public sealed class InfrastructureException : Exception
{
    #region Ctors

    public InfrastructureException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Infrastructure/Repositories/CouponRepository.cs">
#region using

using Discount.Application.Repositories;
using Discount.Domain.Entities;
using Discount.Domain.Enums;
using Discount.Domain.ValueObjects;
using Discount.Infrastructure.Constants;
using MongoDB.Driver;

#endregion

namespace Discount.Infrastructure.Repositories;

public sealed class CouponRepository : ICouponRepository
{
    #region Fields, Properties and Indexers

    private readonly IMongoCollection<CouponEntity> _collection;

    #endregion

    #region Ctors

    public CouponRepository(IMongoDatabase db)
    {
        _collection = db.GetCollection<CouponEntity>(MongoCollection.Coupon);
    }

    #endregion

    #region Implementations

    public async Task<CouponEntity?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _collection
            .Find(x => x.Id == id)
            .FirstOrDefaultAsync(cancellationToken);
    }

    public async Task<CouponEntity?> GetByCodeAsync(CouponCode code, CancellationToken cancellationToken = default)
    {
        return await GetByCodeAsync(code.Value, cancellationToken);
    }

    public async Task<CouponEntity?> GetByCodeAsync(string code, CancellationToken cancellationToken = default)
    {
        var now = DateTime.UtcNow;
        return await _collection
            .Find(x => x.Code == code)
            .FirstOrDefaultAsync(cancellationToken);
    }

    public async Task<bool> ExistsByCodeAsync(CouponCode code, CancellationToken cancellationToken = default)
    {
        return await ExistsByCodeAsync(code.Value, cancellationToken);
    }

    public async Task<bool> ExistsByCodeAsync(string code, CancellationToken cancellationToken = default)
    {
        var count = await _collection
            .CountDocumentsAsync(x => x.Code == code, cancellationToken: cancellationToken);
        return count > 0;
    }

    public async Task<IEnumerable<CouponEntity>> GetByStatusAsync(CouponStatus status, CancellationToken cancellationToken = default)
    {
        return await _collection
            .Find(x => x.Status == status)
            .ToListAsync(cancellationToken);
    }

    public async Task<IEnumerable<CouponEntity>> GetByTypeAsync(CouponType type, CancellationToken cancellationToken = default)
    {
        return await _collection
            .Find(x => x.Type == type)
            .ToListAsync(cancellationToken);
    }

    public async Task<IEnumerable<CouponEntity>> GetValidCouponsAsync(CancellationToken cancellationToken = default)
    {
        var now = DateTime.UtcNow;
        return await _collection
            .Find(x => x.Status == CouponStatus.Approved
                && x.ValidFrom <= now
                && x.ValidTo >= now
                && x.UsageCount < x.MaxUsage)
            .ToListAsync(cancellationToken);
    }

    public async Task<IEnumerable<CouponEntity>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await _collection
            .Find(_ => true)
            .ToListAsync(cancellationToken);
    }

    public async Task<CouponEntity> CreateAsync(CouponEntity coupon, CancellationToken cancellationToken = default)
    {
        await _collection.InsertOneAsync(coupon, cancellationToken: cancellationToken);
        return coupon;
    }

    public async Task<bool> UpdateAsync(CouponEntity coupon, CancellationToken cancellationToken = default)
    {
        var result = await _collection.ReplaceOneAsync(
            x => x.Id == coupon.Id,
            coupon,
            cancellationToken: cancellationToken);
        return result.IsAcknowledged && result.ModifiedCount > 0;
    }

    public async Task<bool> DeleteAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var result = await _collection.DeleteOneAsync(x => x.Id == id, cancellationToken);
        return result.IsAcknowledged && result.DeletedCount > 0;
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Infrastructure/Repositories/IMongoSessionProvider.cs">
#region using

using MongoDB.Driver;

#endregion

namespace Discount.Infrastructure.Repositories;

/// <summary>
/// Provides MongoDB session for transaction support.
/// </summary>
internal interface IMongoSessionProvider
{
    /// <summary>
    /// Gets the current MongoDB session if a transaction is active, otherwise returns null.
    /// </summary>
    IClientSessionHandle? GetSession();
}
</file>

<file path="Services/Discount/Core/Discount.Infrastructure/Repositories/UnitOfWork.cs">
#region using

using Discount.Application.Repositories;
using MongoDB.Driver;

#endregion

namespace Discount.Infrastructure.Repositories;

/// <summary>
/// Unit of Work implementation for MongoDB with transaction support.
/// </summary>
public sealed class UnitOfWork : IUnitOfWork, IMongoSessionProvider
{
    #region Fields, Properties and Indexers

    private readonly IMongoClient _mongoClient;
    private readonly IMongoDatabase _database;
    private IClientSessionHandle? _session;
    private bool _disposed;

    /// <summary>
    /// Gets the coupon repository.
    /// </summary>
    public ICouponRepository Coupons { get; }

    #endregion

    #region Ctors

    public UnitOfWork(
        IMongoClient mongoClient,
        IMongoDatabase database,
        ICouponRepository couponRepository)
    {
        _mongoClient = mongoClient ?? throw new ArgumentNullException(nameof(mongoClient));
        _database = database ?? throw new ArgumentNullException(nameof(database));
        Coupons = couponRepository ?? throw new ArgumentNullException(nameof(couponRepository));
    }

    #endregion

    #region Methods

    /// <summary>
    /// Begins a new transaction.
    /// Note: MongoDB transactions require a replica set or sharded cluster.
    /// </summary>
    public async Task BeginTransactionAsync(CancellationToken cancellationToken = default)
    {
        if (_session != null)
            throw new InvalidOperationException("A transaction is already in progress.");

        _session = await _mongoClient.StartSessionAsync(cancellationToken: cancellationToken);
        _session.StartTransaction();
    }

    /// <summary>
    /// Commits the current transaction.
    /// </summary>
    public async Task CommitTransactionAsync(CancellationToken cancellationToken = default)
    {
        if (_session == null)
            throw new InvalidOperationException("No active transaction to commit.");

        if (!_session.IsInTransaction)
            throw new InvalidOperationException("Session is not in a transaction.");

        await _session.CommitTransactionAsync(cancellationToken);
        await DisposeSessionAsync();
    }

    /// <summary>
    /// Rolls back the current transaction.
    /// </summary>
    public async Task RollbackTransactionAsync(CancellationToken cancellationToken = default)
    {
        if (_session == null)
            throw new InvalidOperationException("No active transaction to rollback.");

        if (_session.IsInTransaction)
        {
            await _session.AbortTransactionAsync(cancellationToken);
        }

        await DisposeSessionAsync();
    }

    /// <summary>
    /// Saves all changes. If a transaction is active, it commits the transaction.
    /// </summary>
    public async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        if (_session != null && _session.IsInTransaction)
        {
            await CommitTransactionAsync(cancellationToken);
            return 1; // Return 1 to indicate changes were saved
        }

        // If no transaction, changes are already persisted (MongoDB auto-commits)
        return 0;
    }

    /// <summary>
    /// Gets the current MongoDB session if a transaction is active.
    /// </summary>
    IClientSessionHandle? IMongoSessionProvider.GetSession()
    {
        return _session;
    }

    private Task DisposeSessionAsync()
    {
        if (_session != null)
        {
            _session.Dispose();
            _session = null;
        }
        return Task.CompletedTask;
    }

    #endregion

    #region IDisposable

    public void Dispose()
    {
        if (_disposed)
            return;

        if (_session != null)
        {
            if (_session.IsInTransaction)
            {
                // Rollback if transaction is still active
                _session.AbortTransaction();
            }
            _session.Dispose();
            _session = null;
        }

        _disposed = true;
    }

    #endregion

    #region IAsyncDisposable

    public async ValueTask DisposeAsync()
    {
        if (_disposed)
            return;

        if (_session != null)
        {
            if (_session.IsInTransaction)
            {
                // Rollback if transaction is still active
                await _session.AbortTransactionAsync();
            }
            _session.Dispose();
            _session = null;
        }

        _disposed = true;
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Infrastructure/DependencyInjection.cs">
#region using

using Discount.Infrastructure.Data.Extensions;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using MongoDB.Driver;

#endregion

namespace Discount.Infrastructure;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddInfrastructureServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Service")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithScopedLifetime());

        var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];
        var dbName = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DatabaseName}"];

        services.AddSingleton<IMongoClient>(sp =>
        {
            var settings = MongoClientSettings.FromConnectionString(conn);
            return new MongoClient(settings);
        });
        services.AddSingleton<IMongoDatabase>(sp =>
        {
            return sp.GetRequiredService<IMongoClient>().GetDatabase(dbName);
        });

        // Register repositories as scoped (required for Unit of Work pattern)
        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Repository")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithScopedLifetime());

        // Register UnitOfWork as scoped (must be after repositories)
        services.AddScoped<Discount.Application.Repositories.IUnitOfWork, Repositories.UnitOfWork>();

        // Register session provider (UnitOfWork implements it)
        services.AddScoped<Repositories.IMongoSessionProvider>(sp =>
            (Repositories.IMongoSessionProvider)sp.GetRequiredService<Discount.Application.Repositories.IUnitOfWork>());

        return services;
    }

    public static WebApplication UseInfrastructure(this WebApplication app)
    {
        app.EnsureIndexesAsync().GetAwaiter();
        app.SeedDataAsync().GetAwaiter();

        return app;
    }

    #endregion
}
</file>

<file path="Services/Discount/Core/Discount.Infrastructure/Discount.Infrastructure.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <Protobuf Include="..\..\..\..\Shared\Contracts\Catalog.Contract\Protos\catalog.proto" GrpcServices="Client" />
  </ItemGroup>
  
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Caching.StackExchangeRedis" />
    <PackageReference Include="MongoDB.Driver" />
    <PackageReference Include="Scrutor" />
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="Google.Protobuf" />
    <PackageReference Include="Grpc.Net.Client" />
    <PackageReference Include="Grpc.Tools">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\Discount.Application\Discount.Application.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Services\" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Discount/Core/Discount.Infrastructure/GlobalUsing.cs">
global using Common.Configurations;
global using Common.Constants;
</file>

<file path="Services/Discount/Core/Discount.Infrastructure/InfrastructureMarker.cs">
namespace Discount.Infrastructure;

public sealed class InfrastructureMarker { }
</file>

<file path="Services/Inventory/Api/Inventory.Api/Constants/ApiRoutes.cs">
namespace Inventory.Api.Constants;

public sealed class ApiRoutes
{
    public static class InventoryItem
    {
        #region Constants

        public const string Tags = "Inventory Items";

        private const string Base = "/inventory-items";

        public const string GetInventoryItems = Base;

        public const string GetAllInventoryItems = $"{Base}/all";

        public const string Create = Base;

        public const string DecreaseStock = $"{Base}/{{inventoryItemId}}/stock/decrease";

        public const string IncreaseStock = $"{Base}/{{inventoryItemId}}/stock/increase";

        public const string Update = $"{Base}/{{inventoryItemId}}";

        public const string Delete = $"{Base}/{{inventoryItemId}}";

        #endregion
    }

    public static class Location
    {
        #region Constants

        public const string Tags = "Locations";

        private const string Base = "/locations";

        public const string GetAll = Base;

        public const string GetById = $"{Base}/{{locationId}}";

        public const string Create = Base;

        public const string Update = $"{Base}/{{locationId}}";

        public const string Delete = $"{Base}/{{locationId}}";

        #endregion
    }

    public static class History
    {
        #region Constants

        public const string Tags = "Inventory History";

        private const string Base = "/histories";

        public const string GetAll = Base;

        #endregion
    }

    public static class Reservation
    {
        #region Constants

        public const string Tags = "Inventory Reservations";

        private const string Base = "/reservations";

        public const string GetAll = $"{Base}/all";

        #endregion
    }
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/CreateInventoryItem.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Inventory.Api.Constants;
using Inventory.Application.Features.InventoryItem.Commands;
using Inventory.Application.Dtos.InventoryItems;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class CreateInventoryItem : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.InventoryItem.Create, HandleCreateInventoryItemAsync)
            .WithTags(ApiRoutes.InventoryItem.Tags)
            .WithName(nameof(CreateInventoryItem))
            .Produces<ApiCreatedResponse<Guid>>(StatusCodes.Status201Created)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiCreatedResponse<Guid>> HandleCreateInventoryItemAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromBody] CreateInventoryItemDto dto)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new CreateInventoryItemCommand(dto, Actor.User(currentUser.Email));

        var result = await sender.Send(command);

        return new ApiCreatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/CreateLocation.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Inventory.Api.Constants;
using Inventory.Application.Features.Location.Commands;
using Inventory.Application.Dtos.Locations;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class CreateLocation : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Location.Create, HandleCreateLocationAsync)
            .WithTags(ApiRoutes.Location.Tags)
            .WithName(nameof(CreateLocation))
            .Produces<ApiCreatedResponse<Guid>>(StatusCodes.Status201Created)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiCreatedResponse<Guid>> HandleCreateLocationAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromBody] CreateLocationDto dto)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new CreateLocationCommand(dto, Actor.User(currentUser.Email));

        var result = await sender.Send(command);

        return new ApiCreatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/DecreaseStock.cs">
#region using

using Inventory.Api.Constants;
using Inventory.Application.Features.InventoryItem.Commands;
using Inventory.Application.Dtos.InventoryItems;
using Inventory.Domain.Enums;
using Microsoft.AspNetCore.Mvc;
using Common.Extensions;
using BuildingBlocks.Authentication.Extensions;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class DecreaseStock : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPut(ApiRoutes.InventoryItem.DecreaseStock, HandleUpdateStockAsync)
            .WithTags(ApiRoutes.InventoryItem.Tags)
            .WithName(nameof(DecreaseStock))
            .Produces<ApiUpdatedResponse<Guid>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<Guid>> HandleUpdateStockAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromRoute] Guid inventoryItemId,
        [FromBody] UpdateStockDto dto)
    {
        var currentUser = httpContext.GetCurrentUser();
        dto.Source = InventorySource.ManualAdjustment.GetDescription();
        var command = new UpdateStockCommand(inventoryItemId, InventoryChangeType.Decrease, dto, Actor.User(currentUser.Email));
        var result = await sender.Send(command);

        return new ApiUpdatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/DeleteInventoryItem.cs">
#region using

using Inventory.Api.Constants;
using Inventory.Application.Features.InventoryItem.Commands;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class DeleteInventoryItem : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapDelete(ApiRoutes.InventoryItem.Delete, HandleDeleteInventoryItemAsync)
            .WithTags(ApiRoutes.InventoryItem.Tags)
            .WithName(nameof(DeleteInventoryItem))
            .Produces<ApiDeletedResponse<Guid>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiDeletedResponse<Guid>> HandleDeleteInventoryItemAsync(
        ISender sender,
        [FromRoute] Guid inventoryItemId)
    {
        var command = new DeleteInventoryItemCommand(inventoryItemId);

        await sender.Send(command);

        return new ApiDeletedResponse<Guid>(inventoryItemId);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/DeleteLocation.cs">
#region using

using Inventory.Api.Constants;
using Inventory.Application.Features.Location.Commands;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class DeleteLocation : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapDelete(ApiRoutes.Location.Delete, HandleDeleteLocationAsync)
            .WithTags(ApiRoutes.Location.Tags)
            .WithName(nameof(DeleteLocation))
            .Produces<ApiDeletedResponse<Guid>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiDeletedResponse<Guid>> HandleDeleteLocationAsync(
        ISender sender,
        [FromRoute] Guid locationId)
    {
        var command = new DeleteLocationCommand(locationId);

        await sender.Send(command);

        return new ApiDeletedResponse<Guid>(locationId);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/GetAllHistories.cs">
#region using

using Inventory.Api.Constants;
using Inventory.Application.Features.InventoryItemHistory.Queries;
using Inventory.Application.Models.Results;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class GetAllHistories : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.History.GetAll, HandleGetAllHistoriesAsync)
            .WithTags(ApiRoutes.History.Tags)
            .WithName(nameof(GetAllHistories))
            .Produces<ApiGetResponse<GetAllHistoriesResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetAllHistoriesResult>> HandleGetAllHistoriesAsync(ISender sender)
    {
        var query = new GetAllHistoriesQuery();
        var result = await sender.Send(query);

        return new ApiGetResponse<GetAllHistoriesResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/GetAllInventoryItems.cs">
#region using

using Inventory.Api.Constants;
using Inventory.Application.Features.InventoryItem.Queries;
using Inventory.Application.Models.Results;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class GetAllInventoryItems : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.InventoryItem.GetAllInventoryItems, HandleGetAllInventoryItemsAsync)
            .WithTags(ApiRoutes.InventoryItem.Tags)
            .WithName(nameof(GetAllInventoryItems))
            .Produces<ApiGetResponse<GetAllInventoryItemResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetAllInventoryItemResult>> HandleGetAllInventoryItemsAsync(
        ISender sender)
    {
        var query = new GetAllInventoryItemQuery();
        var result = await sender.Send(query);

        return new ApiGetResponse<GetAllInventoryItemResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/GetAllLocations.cs">
#region using

using Inventory.Api.Constants;
using Inventory.Application.Features.Location.Queries;
using Inventory.Application.Models.Results;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class GetAllLocations : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Location.GetAll, HandleGetAllLocationsAsync)
            .WithTags(ApiRoutes.Location.Tags)
            .WithName(nameof(GetAllLocations))
            .Produces<ApiGetResponse<GetAllLocationsResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetAllLocationsResult>> HandleGetAllLocationsAsync(
        ISender sender)
    {
        var query = new GetAllLocationsQuery();
        var result = await sender.Send(query);

        return new ApiGetResponse<GetAllLocationsResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/GetAllReservations.cs">
#region using

using Inventory.Api.Constants;
using Inventory.Application.Features.InventoryReservation.Queries;
using Inventory.Application.Models.Results;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class GetAllReservations : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Reservation.GetAll, HandleGetAllReservationsAsync)
            .WithTags(ApiRoutes.Reservation.Tags)
            .WithName(nameof(GetAllReservations))
            .Produces<ApiGetResponse<GetAllInventoryReservationResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetAllInventoryReservationResult>> HandleGetAllReservationsAsync(
        ISender sender)
    {
        var query = new GetAllInventoryReservationQuery();
        var result = await sender.Send(query);

        return new ApiGetResponse<GetAllInventoryReservationResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/GetInventoryItems.cs">
#region using

using Common.Models;
using Inventory.Api.Constants;
using Inventory.Application.Features.InventoryItem.Queries;
using Inventory.Application.Models.Filters;
using Inventory.Application.Models.Results;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class GetInventoryItems : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.InventoryItem.GetInventoryItems, HandleGetInventoryItemsAsync)
            .WithTags(ApiRoutes.InventoryItem.Tags)
            .WithName(nameof(GetInventoryItems))
            .Produces<ApiGetResponse<GetInventoryItemsResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetInventoryItemsResult>> HandleGetInventoryItemsAsync(
        ISender sender,
        [AsParameters] GetInventoryItemsFilter filter,
        [AsParameters] PaginationRequest paging)
    {
        var query = new GetInventoryItemsQuery(filter, paging);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetInventoryItemsResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/GetLocationById.cs">
#region using

using Inventory.Api.Constants;
using Inventory.Application.Features.Location.Queries;
using Inventory.Application.Models.Results;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class GetLocationById : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Location.GetById, HandleGetLocationByIdAsync)
            .WithTags(ApiRoutes.Location.Tags)
            .WithName(nameof(GetLocationById))
            .Produces<ApiGetResponse<GetLocationByIdResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetLocationByIdResult>> HandleGetLocationByIdAsync(
        ISender sender,
        [FromRoute] Guid locationId)
    {
        var query = new GetLocationByIdQuery(locationId);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetLocationByIdResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/IncreaseStock.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Common.Extensions;
using Inventory.Api.Constants;
using Inventory.Application.Features.InventoryItem.Commands;
using Inventory.Application.Dtos.InventoryItems;
using Inventory.Domain.Enums;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class IncreaseStock : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPut(ApiRoutes.InventoryItem.IncreaseStock, HandleUpdateStockAsync)
            .WithTags(ApiRoutes.InventoryItem.Tags)
            .WithName(nameof(IncreaseStock))
            .Produces<ApiUpdatedResponse<Guid>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<Guid>> HandleUpdateStockAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromRoute] Guid inventoryItemId,
        [FromBody] UpdateStockDto dto)
    {
        var currentUser = httpContext.GetCurrentUser();
        dto.Source = InventorySource.ManualAdjustment.GetDescription();
        var command = new UpdateStockCommand(inventoryItemId, InventoryChangeType.Increase, dto, Actor.User(currentUser.Email));
        var result = await sender.Send(command);

        return new ApiUpdatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/UpdateInventoryItem.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Inventory.Api.Constants;
using Inventory.Application.Features.InventoryItem.Commands;
using Inventory.Application.Dtos.InventoryItems;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class UpdateInventoryItem : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPut(ApiRoutes.InventoryItem.Update, HandleUpdateInventoryItemAsync)
            .WithTags(ApiRoutes.InventoryItem.Tags)
            .WithName(nameof(UpdateInventoryItem))
            .Produces<ApiUpdatedResponse<Guid>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<Guid>> HandleUpdateInventoryItemAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromRoute] Guid inventoryItemId,
        [FromBody] UpdateInventoryItemDto dto)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new UpdateInventoryItemCommand(inventoryItemId, dto, Actor.User(currentUser.Email));

        var result = await sender.Send(command);

        return new ApiUpdatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/Endpoints/UpdateLocation.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Inventory.Api.Constants;
using Inventory.Application.Features.Location.Commands;
using Inventory.Application.Dtos.Locations;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Inventory.Api.Endpoints;

public sealed class UpdateLocation : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPut(ApiRoutes.Location.Update, HandleUpdateLocationAsync)
            .WithTags(ApiRoutes.Location.Tags)
            .WithName(nameof(UpdateLocation))
            .Produces<ApiUpdatedResponse<Guid>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<Guid>> HandleUpdateLocationAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromRoute] Guid locationId,
        [FromBody] UpdateLocationDto dto)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new UpdateLocationCommand(locationId, dto, Actor.User(currentUser.Email));

        var result = await sender.Send(command);

        return new ApiUpdatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/DependencyInjection.cs">
#region using

using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using BuildingBlocks.Swagger.Extensions;
using HealthChecks.UI.Client;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Common.Configurations;
using Common.Constants;
using BuildingBlocks.Authentication.Extensions;

#endregion

namespace Inventory.Api;

public static class DependencyInjection
{
    public static IServiceCollection AddApiServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services.AddCarter();

        // HealthChecks
        {
            var dbype = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DbType}"];
            var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];

            switch (dbype)
            {
                case DatabaseType.SqlServer:
                    services.AddHealthChecks()
                        .AddSqlServer(connectionString: conn!);
                    break;
                case DatabaseType.MySql:
                    services.AddHealthChecks()
                        .AddMySql(connectionString: conn!);
                    break;
                case DatabaseType.PostgreSql:
                    services.AddHealthChecks()
                        .AddNpgSql(connectionString: conn!);
                    break;
                //case "MONGO":
                //    services.AddHealthChecks()
                //        .AddMongoDb(connectionString: writeConn!, name: "wirte_db")
                //        .AddMongoDb(connectionString: readConn!, name: "read_db");
                //    break;
                default:
                    throw new Exception("Unsupported database type");
            }
        }

        services.AddHttpContextAccessor();
        services.AddAuthenticationAndAuthorization(cfg);
        services.AddSwaggerServices(cfg);

        return services;
    }

    public static WebApplication UseApi(this WebApplication app)
    {
        app.UseSerilogReqLogging();
        app.UsePrometheusEndpoint();
        app.MapCarter();
        app.UseExceptionHandler(options => { });
        app.UseHealthChecks("/health",
            new HealthCheckOptions
            {
                ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
            });

        app.UseAuthentication();
        app.UseAuthorization();
        app.UseSwaggerApi();

        app.MapGet("/", (IWebHostEnvironment env) => new ApiDefaultPathResponse
        {
            Service = "Inventory.Api",
            Status = "Running",
            Timestamp = DateTimeOffset.UtcNow,
            Environment = env.EnvironmentName,
            Endpoints = new Dictionary<string, string>
            {
                { "health", "/health" }
            },
            Message = "API is running..."
        });

        return app;
    }
}
</file>

<file path="Services/Inventory/Api/Inventory.Api/GlobalUsing.cs">
global using Carter;
global using MediatR;
global using Common.ValueObjects;
global using Common.Models.Reponses;
</file>

<file path="Services/Inventory/Api/Inventory.Api/Inventory.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <UserSecretsId>68beccec-977d-4711-a7f7-5d8d06e5c2e0</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="AspNetCore.HealthChecks.MongoDb" />
    <PackageReference Include="AspNetCore.HealthChecks.MySql" />
    <PackageReference Include="AspNetCore.HealthChecks.NpgSql" />
    <PackageReference Include="AspNetCore.HealthChecks.Redis" />
    <PackageReference Include="AspNetCore.HealthChecks.SqlServer" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" />
    <PackageReference Include="Carter" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Inventory.Application\Inventory.Application.csproj" />
    <ProjectReference Include="..\..\Core\Inventory.Infrastructure\Inventory.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Inventory/Api/Inventory.Api/Program.cs">
#region using

using Inventory.Api;
using Inventory.Application;
using Inventory.Infrastructure;

#endregion

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddApiServices(builder.Configuration);

var app = builder.Build();

// Configure the HTTP request pipeline.
app.UseApi();
app.UseInfrastructure();

app.Run();
</file>

<file path="Services/Inventory/Api/Inventory.Grpc/Interceptors/ApiKeyValidationInterceptor.cs">
#region using

using Common.Configurations;
using Common.Constants;
using Grpc.Core;
using Grpc.Core.Interceptors;

#endregion

namespace Inventory.Grpc.Interceptors;

public class ApiKeyValidationInterceptor(IConfiguration cfg) : Interceptor
{
    #region Methods

    public override async Task<TResponse> UnaryServerHandler<TRequest, TResponse>(
        TRequest request,
        ServerCallContext context,
        UnaryServerMethod<TRequest, TResponse> continuation)
    {
        var provided = context.RequestHeaders.FirstOrDefault(h => h.Key == ReqHeaderName.GrpcKey)?.Value;
        var grpcKey = cfg.GetValue<string>($"{AppConfigCfg.Section}:{AppConfigCfg.GrpcApiKey}");

        if (string.IsNullOrEmpty(provided) || !TimeConstantEquals(provided, grpcKey!))
        {
            throw new RpcException(new Status(StatusCode.Unauthenticated, MessageCode.Unauthorized));
        }

        return await continuation(request, context);
    }

    // Constant-time comparison to mitigate timing attacks (micro-optimization).
    private static bool TimeConstantEquals(string a, string b)
    {
        if (a.Length != b.Length) return false;
        var diff = 0;
        for (int i = 0; i < a.Length; i++)
            diff |= a[i] ^ b[i];
        return diff == 0;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Grpc/Services/InventoryGrpcService.cs">
#region using

using Common.ValueObjects;
using Common.Constants;
using Grpc.Core;
using Inventory.Application.Features.InventoryReservation.Commands;
using MediatR;

#endregion

namespace Inventory.Grpc.Services;

public sealed class InventoryGrpcService(
    ISender sender,
    ILogger<InventoryGrpcService> logger) : InventoryGrpc.InventoryGrpcBase
{
    #region Methods

    public override async Task<ExpireReservationResponse> ExpireReservation(
        ExpireReservationRequest request,
        ServerCallContext context)
    {
        logger.LogInformation("gRPC ExpireReservation called");

        try
        {
            var command = new ExpireReservationCommand(Actor.System(AppConstants.Service.Inventory));
            await sender.Send(command, context.CancellationToken);

            logger.LogInformation("Successfully expired reservations");

            return new ExpireReservationResponse
            {
                Success = "Expired reservations successfully"
            };
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Failed to expire reservations");
            throw new RpcException(new Status(StatusCode.Internal, $"Failed to expire reservations: {ex.Message}"));
        }
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Grpc/DependencyInjection.cs">
#region using

using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using Inventory.Grpc.Interceptors;

#endregion

namespace Inventory.Grpc;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddGrpcServices(
       this IServiceCollection services,
       IConfiguration cfg)
    {
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services
            .AddGrpc(o =>
            {
                o.Interceptors.Add<ApiKeyValidationInterceptor>();
            })
            .AddJsonTranscoding();
        services.AddSingleton<ApiKeyValidationInterceptor>();

        return services;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Api/Inventory.Grpc/Inventory.Grpc.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <ItemGroup>
    <Protobuf Include="..\..\..\..\Shared\Contracts\Inventory.Contract\Protos\inventory.proto" GrpcServices="Server" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="grpc.tools">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="microsoft.aspnetcore.grpc.jsontranscoding" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Contracts\Inventory.Contract\Inventory.Contract.csproj" />
    <ProjectReference Include="..\..\Core\Inventory.Application\Inventory.Application.csproj" />
    <ProjectReference Include="..\..\Core\Inventory.Infrastructure\Inventory.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Inventory/Api/Inventory.Grpc/Program.cs">
#region using

using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using Inventory.Application;
using Inventory.Grpc;
using Inventory.Infrastructure;
using Inventory.Grpc.Services;

#endregion

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddGrpcServices(builder.Configuration);

var app = builder.Build();

app.UseSerilogReqLogging();
app.UsePrometheusEndpoint();

app.MapGrpcService<InventoryGrpcService>();
app.MapGet("/", () => "Catalog gRPC is running...");

app.Run();
</file>

<file path="Services/Inventory/Core/Inventory.Application/Constants/KeycloakUserAttributes.cs">
namespace Inventory.Application.Constants;

public sealed class KeycloakUserAttributes
{
    #region Constants

    public const string PhoneNumber = "phoneNumber";

    public const string FirstName = "firstName";

    public const string LastName = "lastName";

    public const string Password = "password";

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Constants/KeycloakUserEvent.cs">
namespace Inventory.Application.Constants;

public sealed class KeycloakUserEvent
{
    #region Constants

    public const string Created = "CREATED";

    public const string Updated = "UPDATED";

    public const string Deleted = "DELETED";

    public const string Login = "LOGIN";

    public const string Logout = "LOGOUT";

    public const string VerifyEmail = "VERIFY_EMAIL";

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/Abstractions/AuditableDto.cs">
namespace Inventory.Application.Dtos.Abstractions;

public abstract class AuditableDto : IAuditableDto
{
    #region Fields, Properties and Indexers

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}

public interface IAuditableDto : ICreationAuditDto, IModificationAuditDto { }
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/Abstractions/DtoId.cs">
namespace Inventory.Application.Dtos.Abstractions;

public class DtoId<T> : IDtoId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    #endregion
}

public interface IDtoId<T>
{
    T Id { get; init; }
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/Abstractions/EntityDto.cs">
namespace Inventory.Application.Dtos.Abstractions;

public abstract class EntityDto<T> : IDtoId<T>, IAuditableDto
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/Abstractions/ICreationAuditDto.cs">
namespace Inventory.Application.Dtos.Abstractions;

public interface ICreationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/Abstractions/IModificationAuditDto.cs">
namespace Inventory.Application.Dtos.Abstractions;

public interface IModificationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/InventoryItems/CreateInventoryItemDto.cs">
namespace Inventory.Application.Dtos.InventoryItems;

public class CreateInventoryItemDto
{
    #region Fields, Properties and Indexers

    public Guid ProductId { get; set; }

    public int Quantity { get; set; }

    public Guid LocationId { get; set; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/InventoryItems/InventoryHistoryDto.cs">
#region using

using Inventory.Application.Dtos.Abstractions;

#endregion

namespace Inventory.Application.Dtos.InventoryItems;

public sealed class InventoryHistoryDto : EntityDto<Guid>
{
    #region Fields, Properties and Indexers

    public string Message { get; set; } = default!;

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/InventoryItems/InventoryItemDto.cs">
#region using

using Inventory.Application.Dtos.Abstractions;

#endregion

namespace Inventory.Application.Dtos.InventoryItems;

public class InventoryItemDto : EntityDto<Guid>
{
    #region Fields, Properties and Indexers

    public Guid ProductId { get; set; }

    public ProductDto Product { get; set; } = default!;

    public int Quantity { get; set; }

    public int Reserved { get; set; }

    public int Available { get; init; }

    public LocationDto Location { get; set; } = default!;

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/InventoryItems/LocationDto.cs">
namespace Inventory.Application.Dtos.InventoryItems;

public class LocationDto
{
    #region Fields, Properties and Indexers

    public Guid Id { get; set; }

    public string? Location { get; set; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/InventoryItems/ProductDto.cs">
#region using

using Inventory.Application.Dtos.Abstractions;

#endregion

namespace Inventory.Application.Dtos.InventoryItems;

public class ProductDto : DtoId<Guid>
{
    #region Fields, Properties and Indexers

    public string? Name { get; set; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/InventoryItems/UpdateInventoryItemDto.cs">
namespace Inventory.Application.Dtos.InventoryItems;

public class UpdateInventoryItemDto
{
    #region Fields, Properties and Indexers

    public Guid ProductId { get; set; }

    public Guid LocationId { get; set; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/InventoryItems/UpdateStockDto.cs">
#region using

#endregion

namespace Inventory.Application.Dtos.InventoryItems;

public class UpdateStockDto
{
    #region Fields, Properties and Indexers

    public int Amount { get; set; }

    public string? Source { get; set; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/InventoryReservations/CreateReservationDto.cs">
namespace Inventory.Application.Dtos.InventoryReservations;

public sealed record CreateReservationDto
{
    #region Fields, Properties and Indexers

    public Guid ProductId { get; init; }

    public string ProductName { get; init; } = default!;

    public Guid ReferenceId { get; init; }

    public int Quantity { get; init; }

    public DateTimeOffset? ExpiresAt { get; init; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/InventoryReservations/ReservationDto.cs">
#region using

using Inventory.Domain.Enums;

#endregion

namespace Inventory.Application.Dtos.InventoryReservations;

public sealed record ReservationDto
{
    #region Fields, Properties and Indexers

    public Guid Id { get; init; }

    public Guid ProductId { get; init; }

    public string ProductName { get; init; } = default!;

    public Guid ReferenceId { get; init; }

    public int Quantity { get; init; }

    public ReservationStatus Status { get; init; }

    public DateTimeOffset? ExpiresAt { get; init; }

    public DateTimeOffset CreatedOnUtc { get; init; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/Locations/CreateLocationDto.cs">
namespace Inventory.Application.Dtos.Locations;

public class CreateLocationDto
{
    #region Fields, Properties and Indexers

    public string? Location { get; set; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Dtos/Locations/UpdateLocationDto.cs">
namespace Inventory.Application.Dtos.Locations;

public class UpdateLocationDto
{
    #region Fields, Properties and Indexers

    public string? Location { get; set; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Exceptions/ApplicationException.cs">
namespace Inventory.Application.Exceptions;

public sealed class ApplicationException : Exception
{
    #region Ctors

    public ApplicationException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryItem/Commands/CreateInventoryItemCommand.cs">
#region using

using Inventory.Application.Dtos.InventoryItems;
using Inventory.Application.Services;
using Inventory.Domain.Abstractions;
using Inventory.Domain.Entities;

#endregion

namespace Inventory.Application.Features.InventoryItem.Commands;

public sealed record CreateInventoryItemCommand(CreateInventoryItemDto Dto, Actor Actor) : ICommand<Guid>;

public sealed class CreateInventoryItemCommandValidator : AbstractValidator<CreateInventoryItemCommand>
{
    #region Ctors

    public CreateInventoryItemCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.ProductId)
                    .NotEmpty()
                    .WithMessage(MessageCode.ProductIdIsRequired);

                RuleFor(x => x.Dto.Quantity)
                    .NotEmpty()
                    .WithMessage(MessageCode.QuantityIsRequired)
                    .GreaterThan(0)
                    .WithMessage(MessageCode.QuantityCannotBeNegative);

                RuleFor(x => x.Dto.LocationId)
                    .NotEmpty()
                    .WithMessage(MessageCode.LocationIsRequired);
            });
    }

    #endregion
}

public sealed class CreateInventoryItemCommandHandler(
    IUnitOfWork unitOfWork,
    ICatalogApiService catalogApi,
    ICatalogGrpcService catalogGrpc) : ICommandHandler<CreateInventoryItemCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(CreateInventoryItemCommand command, CancellationToken cancellationToken)
    {
        var transaction = await unitOfWork.BeginTransactionAsync(cancellationToken);

        try
        {
            var dto = command.Dto;
            var productByApi = await catalogApi.GetProductByIdAsync(dto.ProductId.ToString())
                ?? throw new ClientValidationException(MessageCode.ProductIsNotExists, dto.ProductId);
            var productByGrpc = await catalogGrpc.GetProductByIdAsync(dto.ProductId.ToString(), cancellationToken)
                ?? throw new ClientValidationException(MessageCode.ProductIsNotExists, dto.ProductId);
            var existsingInventoryItem = await unitOfWork.InventoryItems
                .FirstOrDefaultAsync(x =>
                    x.Product.Id == productByGrpc.Product.Id &&
                    x.LocationId == dto.LocationId,
                cancellationToken);

            if (existsingInventoryItem is not null) throw new ClientValidationException(MessageCode.InventoryItemAlreadyExists, dto.ProductId);


            var inventoryItemId = Guid.NewGuid();

            await AddInventoryItemAsync(inventoryItemId,
                productByGrpc.Product.Id,
                productByGrpc.Product.Name!,
                dto.LocationId,
                dto.Quantity,
                command.Actor);

            await unitOfWork.SaveChangesAsync(cancellationToken);
            await transaction.CommitAsync(cancellationToken);

            return inventoryItemId;
        }
        catch (Exception)
        {
            await transaction.RollbackAsync(cancellationToken);
            throw;
        }
    }

    #endregion

    #region Methods

    private async Task AddInventoryItemAsync(
        Guid inventoryItemId,
        Guid productId,
        string productName,
        Guid locationId,
        int qty,
        Actor actor)
    {
        var entity = InventoryItemEntity.Create(
            id: inventoryItemId,
            productId: productId,
            productName: productName,
            locationId: locationId,
            quantity: qty,
            performedBy: actor.ToString());

        await unitOfWork.InventoryItems.AddAsync(entity);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryItem/Commands/DeleteInventoryItemCommand.cs">
#region using

using MediatR;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryItem.Commands;

public sealed record DeleteInventoryItemCommand(Guid InventoryItemId) : ICommand<Unit>;

public sealed class DeleteInventoryItemCommandValidator : AbstractValidator<DeleteInventoryItemCommand>
{
    #region Ctors

    public DeleteInventoryItemCommandValidator()
    {
        RuleFor(x => x.InventoryItemId)
            .NotEmpty()
            .WithMessage(MessageCode.InventoryItemIdIsRequired);
    }

    #endregion
}

public sealed class DeleteInventoryItemCommandHandler(IUnitOfWork unitOfWork)
    : ICommandHandler<DeleteInventoryItemCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(DeleteInventoryItemCommand command, CancellationToken cancellationToken)
    {
        var transaction = await unitOfWork.BeginTransactionAsync(cancellationToken);

        try
        {
            var entity = await unitOfWork.InventoryItems
            .FirstOrDefaultAsync(x => x.Id == command.InventoryItemId, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound);

            entity.Delete();
            unitOfWork.InventoryItems.Remove(entity);

            await unitOfWork.SaveChangesAsync(cancellationToken);
            await transaction.CommitAsync(cancellationToken);

            return Unit.Value;
        }
        catch (Exception)
        {
            await transaction.RollbackAsync(cancellationToken);
            throw;
        }
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryItem/Commands/UpdateInventoryItemCommand.cs">
#region using

using Inventory.Application.Dtos.InventoryItems;
using Inventory.Application.Services;
using Inventory.Domain.Enums;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryItem.Commands;

public sealed record UpdateInventoryItemCommand(
    Guid InventoryItemId,
    UpdateInventoryItemDto Dto,
    Actor Actor) : ICommand<Guid>;

public sealed class UpdateInventoryItemCommandValidator : AbstractValidator<UpdateInventoryItemCommand>
{
    #region Ctors

    public UpdateInventoryItemCommandValidator()
    {
        RuleFor(x => x.InventoryItemId)
            .NotEmpty()
            .WithMessage(MessageCode.InventoryItemIdIsRequired);

        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.ProductId)
                    .NotEmpty()
                    .WithMessage(MessageCode.ProductIdIsRequired);

                RuleFor(x => x.Dto.LocationId)
                    .NotEmpty()
                    .WithMessage(MessageCode.LocationIsRequired);
            });
    }

    #endregion
}

public sealed class UpdateInventoryItemCommandHandler(
    IUnitOfWork unitOfWork,
    ICatalogApiService catalogApi,
    ICatalogGrpcService catalogGrpc) : ICommandHandler<UpdateInventoryItemCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(UpdateInventoryItemCommand command, CancellationToken cancellationToken)
    {
        var transaction = await unitOfWork.BeginTransactionAsync(cancellationToken);

        try
        {
            var dto = command.Dto;
            var entity = await unitOfWork.InventoryItems
                .FirstOrDefaultAsync(x => x.Id == command.InventoryItemId, cancellationToken)
                ?? throw new NotFoundException(MessageCode.ResourceNotFound);
            var productByApi = await catalogApi.GetProductByIdAsync(dto.ProductId.ToString())
                ?? throw new ClientValidationException(MessageCode.ProductIsNotExists, dto.ProductId);
            var productByGrpc = await catalogGrpc.GetProductByIdAsync(dto.ProductId.ToString(), cancellationToken)
                ?? throw new ClientValidationException(MessageCode.ProductIsNotExists, dto.ProductId);
            var locations = await unitOfWork.Locations.GetAllAsync(cancellationToken);
            var requestLocation = locations.FirstOrDefault(x => x.Id == dto.LocationId)
                ?? throw new ClientValidationException(MessageCode.LocationIsNotExists, dto.LocationId);
            var currentLocation = locations.FirstOrDefault(x => x.Id == entity.LocationId);

            if (entity.IsLocationChanged(dto.LocationId))
            {
                var existsingInventoryItem = await unitOfWork.InventoryItems
                    .FirstOrDefaultAsync(x => x.Product.Id == productByGrpc.Product.Id && x.LocationId == dto.LocationId, cancellationToken);

                if (existsingInventoryItem is not null)
                {
                    entity.Increase(entity.Quantity, InventorySource.Merge.GetDescription(), command.Actor.ToString());
                    unitOfWork.InventoryItems.Remove(existsingInventoryItem);
                }
            }

            entity.Update(locationId: dto.LocationId,
                performedBy: command.Actor.ToString(),
                productId: productByGrpc.Product.Id,
                productName: productByGrpc.Product.Name!,
                oldLocationName: currentLocation?.Location,
                newLocationName: requestLocation.Location);

            unitOfWork.InventoryItems.Update(entity);

            await unitOfWork.SaveChangesAsync(cancellationToken);
            await transaction.CommitAsync(cancellationToken);

            return entity.Id;
        }
        catch (Exception)
        {
            await transaction.RollbackAsync(cancellationToken);
            throw;
        }
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryItem/Commands/UpdateStockCommand.cs">
#region using

using Inventory.Application.Dtos.InventoryItems;
using Inventory.Domain.Enums;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryItem.Commands;

public sealed record UpdateStockCommand(
    Guid InventoryItemId,
    InventoryChangeType ChangeType,
    UpdateStockDto Dto,
    Actor Actor) : ICommand<Guid>;

public sealed class UpdateStockCommandValidator : AbstractValidator<UpdateStockCommand>
{
    #region Ctors

    public UpdateStockCommandValidator()
    {
        RuleFor(x => x.InventoryItemId)
            .NotEmpty()
            .WithMessage(MessageCode.InventoryItemIdIsRequired);

        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Source)
                    .NotEmpty()
                    .WithMessage(MessageCode.SourceIsRequired);

                RuleFor(x => x.ChangeType)
                    .Must(status => Enum.IsDefined(typeof(InventoryChangeType), status))
                    .WithMessage(MessageCode.InventoryChangeTypeIsRequired);
            });
    }

    #endregion
}

public sealed class UpdateStockCommandHandler(IUnitOfWork unitOfWork) : ICommandHandler<UpdateStockCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(UpdateStockCommand command, CancellationToken cancellationToken)
    {
        var transaction = await unitOfWork.BeginTransactionAsync(cancellationToken);

        try
        {
            var dto = command.Dto;
            var entity = await unitOfWork.InventoryItems.FirstOrDefaultAsync(x => x.Id == command.InventoryItemId, cancellationToken)
                ?? throw new NotFoundException(MessageCode.ResourceNotFound);

            switch (command.ChangeType)
            {
                case InventoryChangeType.Increase:
                    entity.Increase(dto.Amount, dto.Source!, command.Actor.ToString());
                    break;
                case InventoryChangeType.Decrease:
                    entity.Decrease(dto.Amount, dto.Source!, command.Actor.ToString());
                    break;
                default:
                    throw new ClientValidationException(MessageCode.InventoryChangeTypeIsRequired);
            }

            unitOfWork.InventoryItems.Update(entity);

            await unitOfWork.SaveChangesAsync(cancellationToken);
            await transaction.CommitAsync(cancellationToken);

            return entity.Id;
        }
        catch (Exception)
        {
            await transaction.RollbackAsync(cancellationToken);
            throw;
        }
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryItem/EventHandlers/Domain/InventoryItemDeletedDomainEventHandler.cs">
#region using

using EventSourcing.Events.Inventories;
using Inventory.Domain.Entities;
using Inventory.Domain.Enums;
using Inventory.Domain.Events;
using MediatR;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryItem.EventHandlers.Domain;

public sealed class InventoryItemDeletedDomainEventHandler(
    IUnitOfWork unitOfWork,
    ILogger<InventoryItemDeletedDomainEventHandler> logger) : INotificationHandler<InventoryItemDeletedDomainEvent>
{
    #region Implementations

    public async Task Handle(InventoryItemDeletedDomainEvent @event, CancellationToken cancellationToken)
    {
        logger.LogInformation("Domain Event handled: {DomainEvent}", @event.GetType().Name);

        await PushToOutboxAsync(@event, cancellationToken);
        await LogHistoryAsync(@event, cancellationToken);
    }

    #endregion

    #region Methods

    private async Task PushToOutboxAsync(InventoryItemDeletedDomainEvent @event, CancellationToken cancellationToken)
    {
        var message = new StockChangedIntegrationEvent()
        {
            Id = Guid.NewGuid().ToString(),
            InventoryItemId = @event.Inventory.Id,
            ProductId = @event.Inventory.Product.Id,
            ChangeType = (int)InventoryChangeType.Decrease,
            Amount = 0,
            Source = InventorySource.ManualDelete.GetDescription()
        };
        var outboxMessage = OutboxMessageEntity.Create(
            id: Guid.NewGuid(),
            eventType: message.EventType!,
            content: JsonConvert.SerializeObject(message),
            occurredOnUtc: DateTimeOffset.UtcNow);

        await unitOfWork.OutboxMessages.AddAsync(outboxMessage, cancellationToken);
    }

    private async Task LogHistoryAsync(InventoryItemDeletedDomainEvent @event, CancellationToken cancellationToken)
    {
        var history = InventoryHistoryEntity.Create(id: Guid.NewGuid(),
            message: $"Product {@event.Inventory.Product.Name} has been deleted from warehouse",
            performBy: Actor.System(AppConstants.Service.Inventory).ToString());

        await unitOfWork.InventoryHistories.AddAsync(history, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryItem/EventHandlers/Domain/LocationChangedDomainEventHandler.cs">
#region using

using Inventory.Domain.Entities;
using Inventory.Domain.Events;
using MediatR;
using Microsoft.Extensions.Logging;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryItem.EventHandlers.Domain;

public sealed class LocationChangedDomainEventHandler(
    IUnitOfWork unitOfWork,
    ILogger<LocationChangedDomainEventHandler> logger) : INotificationHandler<LocationChangedDomainEvent>
{
    #region Implementations

    public async Task Handle(LocationChangedDomainEvent @event, CancellationToken cancellationToken)
    {
        logger.LogInformation("Domain Event handled: {DomainEvent}", @event.GetType().Name);

        await LogHistoryAsync(@event, cancellationToken);
    }

    #endregion

    #region Methods

    private async Task LogHistoryAsync(LocationChangedDomainEvent @event, CancellationToken cancellationToken)
    {
        var history = InventoryHistoryEntity.Create(id: Guid.NewGuid(),
            message: $"Product {@event.ProductName} has been moved from warehouse {@event.OldLocation} to warehouse {@event.NewLocation}",
            performBy: Actor.System(AppConstants.Service.Inventory).ToString());

        await unitOfWork.InventoryHistories.AddAsync(history, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryItem/EventHandlers/Domain/StockChangedDomainEventHandler.cs">
#region using

using EventSourcing.Events.Inventories;
using Inventory.Domain.Entities;
using Inventory.Domain.Enums;
using Inventory.Domain.Events;
using MediatR;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryItem.EventHandlers.Domain;

public sealed class StockChangedDomainEventHandler(
    IUnitOfWork unitOfWork,
    ILogger<StockChangedDomainEventHandler> logger) : INotificationHandler<StockChangedDomainEvent>
{
    #region Implementations

    public async Task Handle(StockChangedDomainEvent @event, CancellationToken cancellationToken)
    {
        logger.LogInformation("Domain Event handled: {DomainEvent}", @event.GetType().Name);

        await PushToOutboxAsync(@event, cancellationToken);
        await LogHistoryAsync(@event, cancellationToken);
    }

    #endregion

    #region Methods

    private async Task PushToOutboxAsync(StockChangedDomainEvent @event, CancellationToken cancellationToken)
    {
        var message = new StockChangedIntegrationEvent()
        {
            Id = Guid.NewGuid().ToString(),
            InventoryItemId = @event.InventoryItemId,
            ProductId = @event.ProductId,
            ChangeType = (int)@event.ChangeType,
            Amount = @event.Available,
            Source = @event.Source
        };
        var outboxMessage = OutboxMessageEntity.Create(
            id: Guid.NewGuid(),
            eventType: message.EventType!,
            content: JsonConvert.SerializeObject(message),
            occurredOnUtc: DateTimeOffset.UtcNow);

        await unitOfWork.OutboxMessages.AddAsync(outboxMessage, cancellationToken);
    }

    private async Task LogHistoryAsync(StockChangedDomainEvent @event, CancellationToken cancellationToken)
    {
        var message = @event.ChangeType switch
        {
            InventoryChangeType.Init =>
                $"Initialized inventory for product '{@event.ProductName}' with {Math.Abs(@event.ChangeAmount)} units. " +
                $"\nQuantity: {@event.QuantityAfterChange}, Available: {@event.Available}. Source: {@event.Source}",

            InventoryChangeType.Increase =>
                $"Increased {Math.Abs(@event.ChangeAmount)} units of product '{@event.ProductName}'. " +
                $"\nQuantity: {@event.OldQuantity} ? {@event.QuantityAfterChange}, Available: {@event.Available}. Source: {@event.Source}",

            InventoryChangeType.Decrease =>
                $"Decreased {Math.Abs(@event.ChangeAmount)} units of product '{@event.ProductName}'. " +
                $"\nQuantity: {@event.OldQuantity} ? {@event.QuantityAfterChange}, Available: {@event.Available}. Source: {@event.Source}",

            InventoryChangeType.Reserve =>
                $"Reserved {Math.Abs(@event.ChangeAmount)} units of product '{@event.ProductName}'. " +
                $"\nReserved increased, Available decreased: {@event.Available}. Source: {@event.Source}",

            InventoryChangeType.Release =>
                $"Released {Math.Abs(@event.ChangeAmount)} units of product '{@event.ProductName}'. " +
                $"\nReserved decreased, Available increased: {@event.Available}. Source: {@event.Source}",

            InventoryChangeType.Commit =>
                $"Committed {Math.Abs(@event.ChangeAmount)} units of product '{@event.ProductName}'. " +
                $"\nQuantity: {@event.OldQuantity} ? {@event.QuantityAfterChange}, Available: {@event.Available}. Source: {@event.Source}",

            InventoryChangeType.Transfer =>
                $"Transferred {Math.Abs(@event.ChangeAmount)} units of product '{@event.ProductName}'. " +
                $"\nQuantity: {@event.OldQuantity} ? {@event.QuantityAfterChange}, Available: {@event.Available}. Source: {@event.Source}",

            _ =>
                $"Stock changed for product '{@event.ProductName}' by {Math.Abs(@event.ChangeAmount)} units. " +
                $"\nQuantity: {@event.OldQuantity} ? {@event.QuantityAfterChange}, Available: {@event.Available}. Source: {@event.Source}"
        };

        var history = InventoryHistoryEntity.Create(
            id: Guid.NewGuid(),
            message: message,
            performBy: Actor.System(AppConstants.Service.Inventory).ToString());

        await unitOfWork.InventoryHistories.AddAsync(history, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryItem/Queries/GetAllInventoryItemQuery.cs">
#region using

using AutoMapper;
using Inventory.Application.Dtos.InventoryItems;
using Inventory.Application.Models.Results;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryItem.Queries;

public sealed record GetAllInventoryItemQuery : IQuery<GetAllInventoryItemResult>;

public sealed class GetAllInventoryItemQueryHandler(IUnitOfWork unitOfWork, IMapper mapper)
    : IQueryHandler<GetAllInventoryItemQuery, GetAllInventoryItemResult>
{
    #region Implementations

    public async Task<GetAllInventoryItemResult> Handle(GetAllInventoryItemQuery query, CancellationToken cancellationToken)
    {
        var result = await unitOfWork.InventoryItems.GetAllWithRelationshipAsync(cancellationToken);
        var items = mapper.Map<List<InventoryItemDto>>(result);
        var reponse = new GetAllInventoryItemResult(items);

        return reponse;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryItem/Queries/GetInventoryItemsQuery.cs">
#region using

using AutoMapper;
using Inventory.Application.Dtos.InventoryItems;
using Inventory.Application.Models.Filters;
using Inventory.Application.Models.Results;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryItem.Queries;

public sealed record GetInventoryItemsQuery(
    GetInventoryItemsFilter Filter,
    PaginationRequest Paging) : IQuery<GetInventoryItemsResult>;

public sealed class GetInventoryItemsQueryHandler(IUnitOfWork unitOfWork, IMapper mapper)
    : IQueryHandler<GetInventoryItemsQuery, GetInventoryItemsResult>
{
    #region Implementations

    public async Task<GetInventoryItemsResult> Handle(GetInventoryItemsQuery query, CancellationToken cancellationToken)
    {
        var filter = query.Filter;
        var paging = query.Paging;

        var result = unitOfWork.InventoryItems
            .SearchWithRelationshipAsync(x =>
                string.IsNullOrEmpty(filter.SearchText) ||
                x.Product.Name!.Contains(filter.SearchText) ||
                x.Location.Location!.Contains(filter.SearchText),
                paging,
                cancellationToken);

        var totalCount = await unitOfWork.InventoryItems
            .CountAsync(x =>
                string.IsNullOrEmpty(filter.SearchText) ||
                x.Product.Name!.Contains(filter.SearchText) ||
                x.Location.Location!.Contains(filter.SearchText),
                cancellationToken);

        var items = mapper.Map<List<InventoryItemDto>>(result);
        var reponse = new GetInventoryItemsResult(items, totalCount, paging);

        return reponse;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryItemHistory/Queries/GetAllHistoriesQuery.cs">
#region using

using AutoMapper;
using Inventory.Application.Dtos.InventoryItems;
using Inventory.Application.Models.Results;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryItemHistory.Queries;

public sealed record GetAllHistoriesQuery : IQuery<GetAllHistoriesResult>;

public sealed class GetAllHistoriesQueryHandler(
    IUnitOfWork unitOfWork,
    IMapper mapper) : IQueryHandler<GetAllHistoriesQuery, GetAllHistoriesResult>
{
    #region Implementations

    public async Task<GetAllHistoriesResult> Handle(GetAllHistoriesQuery query, CancellationToken cancellationToken)
    {
        var result = await unitOfWork.InventoryHistories.GetAllAsync(cancellationToken);
        var items = mapper.Map<List<InventoryHistoryDto>>(result);
        var response = new GetAllHistoriesResult(items);

        return response;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryReservation/Commands/CommitReservationCommand.cs">
#region using

using Inventory.Domain.Enums;
using MediatR;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryReservation.Commands;

public sealed record CommitReservationCommand(
    Guid ReferenceId,
    Actor Actor) : ICommand<Unit>;

public sealed class CommitReservationCommandValidator : AbstractValidator<CommitReservationCommand>
{
    #region Ctors

    public CommitReservationCommandValidator()
    {
        RuleFor(x => x.ReferenceId)
            .NotEmpty()
            .WithMessage(MessageCode.BadRequest);
    }

    #endregion
}

public sealed class CommitReservationCommandHandler(IUnitOfWork unitOfWork)
    : ICommandHandler<CommitReservationCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(CommitReservationCommand command, CancellationToken cancellationToken)
    {
        var reservations = await unitOfWork.InventoryReservations
            .FindAsync(x => x.ReferenceId == command.ReferenceId && x.Status == ReservationStatus.Pending,
                cancellationToken);

        if (!reservations.Any()) return Unit.Value;

        foreach (var reservation in reservations)
        {
            var inventoryItem = await unitOfWork.InventoryItems
                .FirstOrDefaultAsync(x =>
                        x.Product.Id == reservation.Product.Id &&
                        x.LocationId == reservation.LocationId,
                    cancellationToken);

            if (inventoryItem != null)
            {
                inventoryItem.CommitReservation(reservation.Quantity, command.Actor.ToString());
                unitOfWork.InventoryItems.Update(inventoryItem);
            }

            reservation.MarkCommitted(command.Actor.ToString());
            unitOfWork.InventoryReservations.Update(reservation);
        }

        await unitOfWork.SaveChangesAsync(cancellationToken);

        return Unit.Value;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryReservation/Commands/ExpireReservationCommand.cs">
#region using

using Inventory.Domain.Enums;
using MediatR;
using Microsoft.Extensions.Logging;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryReservation.Commands;

public sealed record ExpireReservationCommand(Actor Actor) : ICommand<Unit>;

public sealed class ExpireReservationCommandValidator : AbstractValidator<ExpireReservationCommand>
{
    #region Ctors

    public ExpireReservationCommandValidator()
    {

    }

    #endregion
}

public sealed class ExpireReservationCommandHandler(IUnitOfWork unitOfWork, ILogger<ExpireReservationCommandHandler> logger)
    : ICommandHandler<ExpireReservationCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(ExpireReservationCommand command, CancellationToken cancellationToken)
    {
        var now = DateTimeOffset.UtcNow;
        var expiredReservations = await unitOfWork.InventoryReservations
            .FindAsync(x => x.Status == ReservationStatus.Pending
                        && x.ExpiresAt.HasValue
                        && x.ExpiresAt.Value <= now,
                cancellationToken);

        if (!expiredReservations.Any())
        {
            logger.LogDebug("No expired reservations found at {Time}", now);
            return Unit.Value;
        }

        logger.LogInformation("Found {Count} expired reservations to process", expiredReservations.Count);

        foreach (var reservation in expiredReservations)
        {
            try
            {
                var inventoryItem = await unitOfWork.InventoryItems
                    .FirstOrDefaultAsync(x =>
                            x.Product.Id == reservation.Product.Id &&
                            x.LocationId == reservation.LocationId,
                        cancellationToken);

                if (inventoryItem != null)
                {
                    inventoryItem.Unreserve(reservation.Quantity, reservation.Id, Actor.System(AppConstants.Service.Inventory).ToString());
                    unitOfWork.InventoryItems.Update(inventoryItem);
                }

                reservation.Expire();

                if (reservation.Status == Domain.Enums.ReservationStatus.Expired)
                {
                    unitOfWork.InventoryReservations.Update(reservation);
                }

                logger.LogInformation("Successfully expired reservation {ReservationId} for order {OrderId}",
                    reservation.Id, reservation.ReferenceId);
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "Failed to expire reservation {ReservationId}", reservation.Id);
            }
        }

        await unitOfWork.SaveChangesAsync(cancellationToken);

        return Unit.Value;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryReservation/Commands/ReleaseReservationCommand.cs">
#region using

using Inventory.Domain.Enums;
using MediatR;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryReservation.Commands;

public sealed record ReleaseReservationCommand(
    Guid ReferenceId,
    string Reason,
    Actor Actor) : ICommand<Unit>;

public sealed class ReleaseReservationCommandValidator : AbstractValidator<ReleaseReservationCommand>
{
    #region Ctors

    public ReleaseReservationCommandValidator()
    {
        RuleFor(x => x.ReferenceId)
            .NotEmpty()
            .WithMessage(MessageCode.BadRequest);

        RuleFor(x => x.Reason)
            .NotEmpty()
            .WithMessage(MessageCode.BadRequest);
    }

    #endregion
}

public sealed class ReleaseReservationCommandHandler(IUnitOfWork unitOfWork)
    : ICommandHandler<ReleaseReservationCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(ReleaseReservationCommand command, CancellationToken cancellationToken)
    {
        var reservations = await unitOfWork.InventoryReservations
            .FindAsync(x =>
                    x.ReferenceId == command.ReferenceId &&
                    x.Status == ReservationStatus.Pending,
                cancellationToken);

        if (!reservations.Any())
        {
            return Unit.Value;
        }

        foreach (var reservation in reservations)
        {
            var inventoryItem = await unitOfWork.InventoryItems
                .FirstOrDefaultAsync(x =>
                        x.Product.Id == reservation.Product.Id &&
                        x.LocationId == reservation.LocationId,
                    cancellationToken);

            if (inventoryItem != null)
            {
                inventoryItem.Unreserve(reservation.Quantity, reservation.Id, command.Actor.ToString());
                unitOfWork.InventoryItems.Update(inventoryItem);
            }

            reservation.Release(command.Reason, command.Actor.ToString());
            unitOfWork.InventoryReservations.Update(reservation);
        }

        await unitOfWork.SaveChangesAsync(cancellationToken);

        return Unit.Value;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryReservation/Commands/ReserveInventoryCommand.cs">
#region using

using Inventory.Application.Dtos.InventoryReservations;
using Inventory.Domain.Entities;
using MediatR;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryReservation.Commands;

public sealed record ReserveInventoryCommand(
    CreateReservationDto Dto,
    Actor Actor) : ICommand<Unit>;

public sealed class ReserveInventoryCommandValidator : AbstractValidator<ReserveInventoryCommand>
{
    #region Ctors

    public ReserveInventoryCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.ProductId)
                    .NotEmpty()
                    .WithMessage(MessageCode.ProductIdIsRequired);

                RuleFor(x => x.Dto.ProductName)
                    .NotEmpty()
                    .WithMessage(MessageCode.ProductNameIsRequired);

                RuleFor(x => x.Dto.ReferenceId)
                    .NotEmpty()
                    .WithMessage(MessageCode.BadRequest);

                RuleFor(x => x.Dto.Quantity)
                    .GreaterThan(0)
                    .WithMessage(MessageCode.QuantityCannotBeNegative);
            });
    }

    #endregion
}

public sealed class ReserveInventoryCommandHandler(IUnitOfWork unitOfWork)
    : ICommandHandler<ReserveInventoryCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(ReserveInventoryCommand command, CancellationToken cancellationToken)
    {
        var dto = command.Dto;
        var existingReservation = await unitOfWork.InventoryReservations
            .FirstOrDefaultAsync(x => x.ReferenceId == dto.ReferenceId, cancellationToken);

        if (existingReservation != null)
        {
            return Unit.Value;
        }

        var inventoryItems = await unitOfWork.InventoryItems
            .FindByProductWithRelationshipAsync(dto.ProductId, cancellationToken);
        var selectedItem = inventoryItems.FirstOrDefault()
            ?? throw new ClientValidationException(MessageCode.InventoryItemNotFound);

        if (!selectedItem.HasAvailable(dto.Quantity))
        {
            throw new ClientValidationException(MessageCode.InsufficientStock);
        }

        var reservationId = Guid.NewGuid();
        selectedItem.Reserve(dto.Quantity, reservationId, command.Actor.ToString());
        unitOfWork.InventoryItems.Update(selectedItem);

        var reservation = InventoryReservationEntity.Create(
            id: reservationId,
            productId: dto.ProductId,
            productName: dto.ProductName,
            referenceId: dto.ReferenceId,
            locationId: selectedItem.LocationId,
            quantity: dto.Quantity,
            expiresAt: dto.ExpiresAt,
            performedBy: command.Actor.ToString());

        await unitOfWork.InventoryReservations.AddAsync(reservation, cancellationToken);
        await unitOfWork.SaveChangesAsync(cancellationToken);

        return Unit.Value;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryReservation/EventHandlers/Domain/ReservationCommittedDomainEventHandler.cs">
#region using

using Inventory.Domain.Entities;
using Inventory.Domain.Events;
using MediatR;
using Microsoft.Extensions.Logging;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryReservation.EventHandlers.Domain;

public sealed class ReservationCommittedDomainEventHandler(
    IUnitOfWork unitOfWork,
    ILogger<ReservationCommittedDomainEventHandler> logger) : INotificationHandler<ReservationCommittedDomainEvent>
{
    #region Implementations

    public async Task Handle(ReservationCommittedDomainEvent @event, CancellationToken cancellationToken)
    {
        logger.LogInformation("Domain Event handled: {DomainEvent}", @event.GetType().Name);

        await LogHistoryAsync(@event, cancellationToken);
    }

    #endregion

    #region Methods

    private async Task LogHistoryAsync(ReservationCommittedDomainEvent @event, CancellationToken cancellationToken)
    {
        var message = $"Reservation committed: {@event.Quantity} units of {@event.ProductName} for order {@event.ReferenceId}";

        var history = InventoryHistoryEntity.Create(
            id: Guid.NewGuid(),
            message: message,
            performBy: Actor.System(AppConstants.Service.Inventory).ToString());

        await unitOfWork.InventoryHistories.AddAsync(history, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryReservation/EventHandlers/Domain/ReservationCreatedDomainEventHandler.cs">
#region using

using Inventory.Domain.Entities;
using Inventory.Domain.Events;
using MediatR;
using Microsoft.Extensions.Logging;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryReservation.EventHandlers.Domain;

public sealed class ReservationCreatedDomainEventHandler(
    IUnitOfWork unitOfWork,
    ILogger<ReservationCreatedDomainEventHandler> logger) : INotificationHandler<ReservationCreatedDomainEvent>
{
    #region Implementations

    public async Task Handle(ReservationCreatedDomainEvent @event, CancellationToken cancellationToken)
    {
        logger.LogInformation("Domain Event handled: {DomainEvent}", @event.GetType().Name);

        await LogHistoryAsync(@event, cancellationToken);
    }

    #endregion

    #region Methods

    private async Task LogHistoryAsync(ReservationCreatedDomainEvent @event, CancellationToken cancellationToken)
    {
        var message = $"Reservation created: {@event.Quantity} units of {@event.ProductName} reserved for order {@event.ReferenceId}";

        var history = InventoryHistoryEntity.Create(
            id: Guid.NewGuid(),
            message: message,
            performBy: Actor.System(AppConstants.Service.Inventory).ToString());

        await unitOfWork.InventoryHistories.AddAsync(history, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryReservation/EventHandlers/Domain/ReservationExpiredDomainEventHandler.cs">
#region using

using EventSourcing.Events.Inventories;
using Inventory.Domain.Entities;
using Inventory.Domain.Events;
using MediatR;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryReservation.EventHandlers.Domain;

public sealed class ReservationExpiredDomainEventHandler(
    IUnitOfWork unitOfWork,
    ILogger<ReservationExpiredDomainEventHandler> logger) : INotificationHandler<ReservationExpiredDomainEvent>
{
    #region Implementations

    public async Task Handle(ReservationExpiredDomainEvent @event, CancellationToken cancellationToken)
    {
        logger.LogInformation("Domain Event handled: {DomainEvent}", @event.GetType().Name);

        await LogHistoryAsync(@event, cancellationToken);
        await PushToOutboxAsync(@event, cancellationToken);
    }

    #endregion

    #region Methods

    private async Task LogHistoryAsync(ReservationExpiredDomainEvent @event, CancellationToken cancellationToken)
    {
        var message = $"Reservation expired: {@event.Quantity} units of {@event.ProductName} for order {@event.ReferenceId}";

        var history = InventoryHistoryEntity.Create(
            id: Guid.NewGuid(),
            message: message,
            performBy: Actor.System(AppConstants.Service.Inventory).ToString());

        await unitOfWork.InventoryHistories.AddAsync(history, cancellationToken);
    }

    private async Task PushToOutboxAsync(ReservationExpiredDomainEvent @event, CancellationToken cancellationToken)
    {
        var message = new ReservationExpiredIntegrationEvent
        {
            Id = Guid.NewGuid().ToString(),
            ReservationId = @event.ReservationId,
            OrderId = @event.ReferenceId,
            ProductId = @event.ProductId,
            ProductName = @event.ProductName,
            Quantity = @event.Quantity
        };

        var outboxMessage = OutboxMessageEntity.Create(
            id: Guid.NewGuid(),
            eventType: message.EventType!,
            content: JsonConvert.SerializeObject(message),
            occurredOnUtc: DateTimeOffset.UtcNow);

        await unitOfWork.OutboxMessages.AddAsync(outboxMessage, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryReservation/EventHandlers/Domain/ReservationReleasedDomainEventHandler.cs">
#region using

using Inventory.Domain.Entities;
using Inventory.Domain.Events;
using MediatR;
using Microsoft.Extensions.Logging;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryReservation.EventHandlers.Domain;

public sealed class ReservationReleasedDomainEventHandler(
    IUnitOfWork unitOfWork,
    ILogger<ReservationReleasedDomainEventHandler> logger) : INotificationHandler<ReservationReleasedDomainEvent>
{
    #region Implementations

    public async Task Handle(ReservationReleasedDomainEvent @event, CancellationToken cancellationToken)
    {
        logger.LogInformation("Domain Event handled: {DomainEvent}", @event.GetType().Name);

        await LogHistoryAsync(@event, cancellationToken);
    }

    #endregion

    #region Methods

    private async Task LogHistoryAsync(ReservationReleasedDomainEvent @event, CancellationToken cancellationToken)
    {
        var message = $"Reservation released: {@event.Quantity} units of {@event.ProductName} for order {@event.ReferenceId}. Reason: {@event.Reason}";

        var history = InventoryHistoryEntity.Create(
            id: Guid.NewGuid(),
            message: message,
            performBy: Actor.System(AppConstants.Service.Inventory).ToString());

        await unitOfWork.InventoryHistories.AddAsync(history, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/InventoryReservation/Queries/GetAllInventoryReservationQuery.cs">
#region using

using AutoMapper;
using Inventory.Application.Dtos.InventoryReservations;
using Inventory.Application.Models.Results;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.InventoryReservation.Queries;

public sealed record GetAllInventoryReservationQuery : IQuery<GetAllInventoryReservationResult>;

public sealed class GetAllInventoryReservationQueryHandler(IUnitOfWork unitOfWork, IMapper mapper)
    : IQueryHandler<GetAllInventoryReservationQuery, GetAllInventoryReservationResult>
{
    #region Implementations

    public async Task<GetAllInventoryReservationResult> Handle(GetAllInventoryReservationQuery query, CancellationToken cancellationToken)
    {
        var result = await unitOfWork.InventoryReservations
            .GetAllWithRelationshipAsync(cancellationToken);
        var items = mapper.Map<List<ReservationDto>>(result);
        var response = new GetAllInventoryReservationResult(items);

        return response;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/Location/Commands/CreateLocationCommand.cs">
#region using

using Inventory.Application.Dtos.Locations;
using Inventory.Domain.Entities;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.Location.Commands;

public sealed record CreateLocationCommand(CreateLocationDto Dto, Actor Actor) : ICommand<Guid>;

public sealed class CreateLocationCommandValidator : AbstractValidator<CreateLocationCommand>
{
    #region Ctors

    public CreateLocationCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Location)
                    .NotEmpty()
                    .WithMessage(MessageCode.LocationIsRequired);
            });
    }

    #endregion
}

public sealed class CreateLocationCommandHandler(IUnitOfWork unitOfWork)
    : ICommandHandler<CreateLocationCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(CreateLocationCommand command, CancellationToken cancellationToken)
    {
        var dto = command.Dto;
        var locationId = Guid.NewGuid();
        var entity = LocationEntity.Create(
            id: locationId,
            location: dto.Location!,
            performBy: command.Actor.ToString());

        await unitOfWork.Locations.AddAsync(entity, cancellationToken);
        await unitOfWork.SaveChangesAsync(cancellationToken);

        return locationId;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/Location/Commands/DeleteLocationCommand.cs">
#region using

using MediatR;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.Location.Commands;

public sealed record DeleteLocationCommand(Guid LocationId) : ICommand<Unit>;

public sealed class DeleteLocationCommandValidator : AbstractValidator<DeleteLocationCommand>
{
    #region Ctors

    public DeleteLocationCommandValidator()
    {
        RuleFor(x => x.LocationId)
            .NotEmpty()
            .WithMessage(MessageCode.IdIsRequired);
    }

    #endregion
}

public sealed class DeleteLocationCommandHandler(IUnitOfWork unitOfWork)
    : ICommandHandler<DeleteLocationCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(DeleteLocationCommand command, CancellationToken cancellationToken)
    {
        var entity = await unitOfWork.Locations
            .FirstOrDefaultAsync(x => x.Id == command.LocationId, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound);

        var isInUse = await unitOfWork.InventoryItems
            .AnyAsync(x => x.LocationId == command.LocationId, cancellationToken);

        if (isInUse)
        {
            throw new ClientValidationException(MessageCode.BadRequest, command.LocationId);
        }

        unitOfWork.Locations.Remove(entity);
        await unitOfWork.SaveChangesAsync(cancellationToken);

        return Unit.Value;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/Location/Commands/UpdateLocationCommand.cs">
#region using

using Inventory.Application.Dtos.Locations;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.Location.Commands;

public sealed record UpdateLocationCommand(
    Guid LocationId,
    UpdateLocationDto Dto,
    Actor Actor) : ICommand<Guid>;

public sealed class UpdateLocationCommandValidator : AbstractValidator<UpdateLocationCommand>
{
    #region Ctors

    public UpdateLocationCommandValidator()
    {
        RuleFor(x => x.LocationId)
            .NotEmpty()
            .WithMessage(MessageCode.IdIsRequired);

        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Location)
                    .NotEmpty()
                    .WithMessage(MessageCode.LocationIsRequired);
            });
    }

    #endregion
}

public sealed class UpdateLocationCommandHandler(IUnitOfWork unitOfWork)
    : ICommandHandler<UpdateLocationCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(UpdateLocationCommand command, CancellationToken cancellationToken)
    {
        var entity = await unitOfWork.Locations
            .FirstOrDefaultAsync(x => x.Id == command.LocationId, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound);

        entity.Update(
            location: command.Dto.Location!,
            performBy: command.Actor.ToString());

        unitOfWork.Locations.Update(entity);
        await unitOfWork.SaveChangesAsync(cancellationToken);

        return entity.Id;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/Location/Queries/GetAllLocationsQuery.cs">
#region using

using AutoMapper;
using Inventory.Application.Dtos.InventoryItems;
using Inventory.Application.Models.Results;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.Location.Queries;

public sealed record GetAllLocationsQuery : IQuery<GetAllLocationsResult>;

public sealed class GetAllLocationsQueryHandler(IUnitOfWork unitOfWork, IMapper mapper)
    : IQueryHandler<GetAllLocationsQuery, GetAllLocationsResult>
{
    #region Implementations

    public async Task<GetAllLocationsResult> Handle(GetAllLocationsQuery query, CancellationToken cancellationToken)
    {
        var result = await unitOfWork.Locations.GetAllAsync(cancellationToken);
        var items = mapper.Map<List<LocationDto>>(result);
        var response = new GetAllLocationsResult(items);

        return response;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Features/Location/Queries/GetLocationByIdQuery.cs">
#region using

using AutoMapper;
using Inventory.Application.Dtos.InventoryItems;
using Inventory.Application.Models.Results;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Application.Features.Location.Queries;

public sealed record GetLocationByIdQuery(Guid LocationId) : IQuery<GetLocationByIdResult>;

public sealed class GetLocationByIdQueryHandler(IUnitOfWork unitOfWork, IMapper mapper)
    : IQueryHandler<GetLocationByIdQuery, GetLocationByIdResult>
{
    #region Implementations

    public async Task<GetLocationByIdResult> Handle(GetLocationByIdQuery query, CancellationToken cancellationToken)
    {
        var entity = await unitOfWork.Locations
            .SingleOrDefaultAsync(x => x.Id == query.LocationId, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound);

        var location = mapper.Map<LocationDto>(entity);
        var result = new GetLocationByIdResult(location);

        return result;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Mappings/InventoryMappingProfile.cs">
#region using

using AutoMapper;
using Inventory.Application.Dtos.InventoryItems;
using Inventory.Application.Dtos.InventoryReservations;
using Inventory.Domain.Entities;
using Inventory.Domain.ValueObjects;

#endregion

namespace Inventory.Application.Mappings;

public sealed class InventoryMappingProfile : Profile
{
    #region Ctors

    public InventoryMappingProfile()
    {
        CreateInventoryItemMappings();
        CreateLocationMappings();
        CreateProductMappings();
        CreateReservationMappings();
        CreateHistoryMappings();
    }

    #endregion

    #region Methods

    private void CreateInventoryItemMappings()
    {
        // InventoryItemEntity -> InventoryItemDto
        CreateMap<InventoryItemEntity, InventoryItemDto>()
            .ForMember(dest => dest.ProductId, opt => opt.MapFrom(src => src.Product.Id))
            .ForMember(dest => dest.Available, opt => opt.MapFrom(src => src.Available));
    }

    private void CreateLocationMappings()
    {
        // LocationEntity -> LocationDto
        CreateMap<LocationEntity, LocationDto>();
    }

    private void CreateProductMappings()
    {
        // Product ValueObject -> ProductDto
        CreateMap<Product, ProductDto>()
            .ForMember(dest => dest.Id, opt => opt.MapFrom(src => src.Id))
            .ForMember(dest => dest.Name, opt => opt.MapFrom(src => src.Name));
    }

    private void CreateReservationMappings()
    {
        // InventoryReservationEntity -> ReservationDto
        CreateMap<InventoryReservationEntity, ReservationDto>()
            .ForMember(dest => dest.ProductId, opt => opt.MapFrom(src => src.Product.Id))
            .ForMember(dest => dest.ProductName, opt => opt.MapFrom(src => src.Product.Name))
            .ForMember(dest => dest.Quantity, opt => opt.MapFrom(src => (int)src.Quantity));
    }

    private void CreateHistoryMappings()
    {
        // InventoryHistoryEntity -> InventoryHistoryDto
        CreateMap<InventoryHistoryEntity, InventoryHistoryDto>();
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Models/Filters/GetInventoryItemsFilter.cs">
namespace Inventory.Application.Models.Filters;

public sealed record class GetInventoryItemsFilter(string? SearchText);
</file>

<file path="Services/Inventory/Core/Inventory.Application/Models/Responses/Externals/GetProductByIdReponse.cs">
namespace Inventory.Application.Models.Responses.Externals;

public class GetProductByIdReponse
{
    #region Fields, Properties and Indexers

    public ProductReponse Product { get; init; } = default!;

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Models/Responses/Externals/KeycloakAccessTokenResponse.cs">
#region using

using System.Text.Json.Serialization;

#endregion

namespace Inventory.Application.Models.Responses.Externals;

public sealed class KeycloakAccessTokenResponse
{
    #region Fields, Properties and Indexers

    [JsonPropertyName("access_token")]
    public string? AccessToken { get; set; }

    [JsonPropertyName("expires_in")]
    public int ExpiresIn { get; set; }

    [JsonPropertyName("refresh_expires_in")]
    public int RefreshExpiresIn { get; set; }

    [JsonPropertyName("token_type")]
    public string? TokenType { get; set; }

    [JsonPropertyName("id_token")]
    public string? IdToken { get; set; }

    [JsonPropertyName("not-before-policy")]
    public int NotBeforePolicy { get; set; }

    [JsonPropertyName("scope")]
    public string? Scope { get; set; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Models/Responses/Externals/ProductReponse.cs">
namespace Inventory.Application.Models.Responses.Externals;

public class ProductReponse
{
    #region Fields, Properties and Indexers

    public Guid Id { get; set; }

    public string Name { get; set; } = default!;

    public ProductImageResponse Thumbnail { get; set; } = default!;

    public string ThumbnailUrl { get; set; } = default!;

    public decimal Price { get; set; }

    #endregion
}

public class ProductImageResponse
{
    #region Fields, Properties and Indexers

    public string? FileId { get; set; }

    public string? OriginalFileName { get; set; }

    public string? FileName { get; set; }

    public string? PublicURL { get; set; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Models/Responses/Internals/GetAllProductsResponse.cs">
#region using

using Inventory.Application.Models.Responses.Externals;

#endregion

namespace Inventory.Application.Models.Responses.Internals;

public sealed class GetAllProductsResponse
{
    #region Fields, Properties and Indexers

    public List<ProductReponse>? Items { get; set; }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Models/Results/GetAllHistoriesResult.cs">
#region using

using Inventory.Application.Dtos.InventoryItems;

#endregion

namespace Inventory.Application.Models.Results;

public sealed class GetAllHistoriesResult
{
    #region Fields, Properties and Indexers

    public List<InventoryHistoryDto> Items { get; init; }

    #endregion

    #region Ctors

    public GetAllHistoriesResult(List<InventoryHistoryDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Models/Results/GetAllInventoryItemResult.cs">
#region using

using Inventory.Application.Dtos.InventoryItems;

#endregion

namespace Inventory.Application.Models.Results;

public sealed class GetAllInventoryItemResult
{
    #region Fields, Properties and Indexers

    public List<InventoryItemDto> Items { get; init; }

    #endregion

    #region Ctors

    public GetAllInventoryItemResult(List<InventoryItemDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Models/Results/GetAllInventoryReservationResult.cs">
#region using

using Inventory.Application.Dtos.InventoryReservations;

#endregion

namespace Inventory.Application.Models.Results;

public sealed class GetAllInventoryReservationResult
{
    #region Fields, Properties and Indexers

    public List<ReservationDto> Items { get; init; }

    #endregion

    #region Ctors

    public GetAllInventoryReservationResult(List<ReservationDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Models/Results/GetAllLocationsResult.cs">
#region using

using Inventory.Application.Dtos.InventoryItems;

#endregion

namespace Inventory.Application.Models.Results;

public sealed class GetAllLocationsResult
{
    #region Fields, Properties and Indexers

    public List<LocationDto> Items { get; init; }

    #endregion

    #region Ctors

    public GetAllLocationsResult(List<LocationDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Models/Results/GetInventoryItemsResult.cs">
#region using

using Inventory.Application.Dtos.InventoryItems;

#endregion

namespace Inventory.Application.Models.Results;

public sealed class GetInventoryItemsResult
{
    #region Fields, Properties and Indexers

    public List<InventoryItemDto> Items { get; init; }

    public PagingResult Paging { get; init; }

    #endregion

    #region Ctors

    public GetInventoryItemsResult(
        List<InventoryItemDto> items,
        long totalCount,
        PaginationRequest pagination)
    {
        Items = items;
        Paging = PagingResult.Of(totalCount, pagination);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Models/Results/GetLocationByIdResult.cs">
#region using

using Inventory.Application.Dtos.InventoryItems;

#endregion

namespace Inventory.Application.Models.Results;

public sealed class GetLocationByIdResult
{
    #region Fields, Properties and Indexers

    public LocationDto Location { get; init; }

    #endregion

    #region Ctors

    public GetLocationByIdResult(LocationDto location)
    {
        Location = location;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Models/Results/GetReservationsByReferenceResult.cs">
#region using

using Inventory.Application.Dtos.InventoryReservations;

#endregion

namespace Inventory.Application.Models.Results;

public sealed class GetReservationsByReferenceResult
{
    #region Fields, Properties and Indexers

    public List<ReservationDto> Items { get; init; }

    #endregion

    #region Ctors

    public GetReservationsByReferenceResult(List<ReservationDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Services/ICatalogApiService.cs">
#region using

using Common.Models.Reponses;
using Inventory.Application.Models.Responses.Externals;

#endregion

namespace Inventory.Application.Services;

public interface ICatalogApiService
{
    #region Methods

    Task<ApiGetResponse<GetProductByIdReponse>?> GetProductByIdAsync(string productId);

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/Services/ICatalogGrpcService.cs">
#region using

using Inventory.Application.Models.Responses.Externals;
using Inventory.Application.Models.Responses.Internals;

#endregion

namespace Inventory.Application.Services;

public interface ICatalogGrpcService
{
    #region Methods

    Task<GetProductByIdReponse?> GetProductByIdAsync(string productId, CancellationToken cancellationToken = default);

    Task<GetAllProductsResponse?> GetProductsAsync(string[]? ids = null, string searchText = "", CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/ApplicationMarker.cs">
namespace Inventory.Application;

public sealed class ApplicationMarker { }
</file>

<file path="Services/Inventory/Core/Inventory.Application/DependencyInjection.cs">
#region using

using BuildingBlocks.Behaviors;
using BuildingBlocks.Exceptions.Handler;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.FeatureManagement;
using System.Reflection;

#endregion

namespace Inventory.Application;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddApplicationServices(this IServiceCollection services)
    {
        services.AddExceptionHandler<CustomExceptionHandler>();
        services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
        services.AddMediatR(config =>
        {
            config.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
            config.AddOpenBehavior(typeof(ValidationBehavior<,>));
            config.AddOpenBehavior(typeof(LoggingBehavior<,>));
        });
        services.AddFeatureManagement();

        // Register all AutoMapper profiles from the current assembly
        services.AddAutoMapper(Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Application/GlobalUsing.cs">
global using BuildingBlocks.CQRS;
global using FluentValidation;
global using Common.Constants;
global using Common.Extensions;
global using Common.Models;
global using BuildingBlocks.Pagination;
global using BuildingBlocks.Exceptions;
global using Common.ValueObjects;
</file>

<file path="Services/Inventory/Core/Inventory.Application/Inventory.Application.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="AutoMapper" />
    <PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" />
    <PackageReference Include="Scrutor" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\..\Core\Inventory.Domain\Inventory.Domain.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Abstractions/Aggregate.cs">
namespace Inventory.Domain.Abstractions;

public abstract class Aggregate<TId> : Entity<TId>, IAggregate<TId>
{
    #region Fields, Properties and Indexers

    private readonly List<IDomainEvent> _domainEvents = new();

    #endregion

    #region Implementations

    public IReadOnlyList<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    public void AddDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }

    public IDomainEvent[] ClearDomainEvents()
    {
        IDomainEvent[] dequeuedEvents = _domainEvents.ToArray();

        _domainEvents.Clear();

        return dequeuedEvents;
    }

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Abstractions/Entity.cs">
namespace Inventory.Domain.Abstractions;

public abstract class Entity<T> : IEntityId<T>, IAuditable
{
    #region Fields, Properties and Indexers

    public T Id { get; set; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Abstractions/EntityId.cs">
namespace Inventory.Domain.Abstractions;

public abstract class EntityId<T> : IEntityId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; set; } = default!;

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Abstractions/IAggregate.cs">
namespace Inventory.Domain.Abstractions;

public interface IAggregate<T> : IAggregate, IEntityId<T>
{
}

public interface IAggregate : ICreationAuditable, IModificationAuditable
{
    #region Fields, Properties and Indexers

    IReadOnlyList<IDomainEvent> DomainEvents { get; }

    IDomainEvent[] ClearDomainEvents();

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Abstractions/IAuditable.cs">
namespace Inventory.Domain.Abstractions;

public interface IAuditable : ICreationAuditable, IModificationAuditable { }
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Abstractions/ICreationAuditable.cs">
namespace Inventory.Domain.Abstractions;

public interface ICreationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Abstractions/IDbTransaction.cs">
namespace Inventory.Domain.Abstractions;

public interface IDbTransaction : IDisposable, IAsyncDisposable
{
    #region Methods

    Task CommitAsync(CancellationToken cancellationToken = default);

    Task RollbackAsync(CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Abstractions/IDomainEvent.cs">
#region using

using MediatR;

#endregion

namespace Inventory.Domain.Abstractions;

public interface IDomainEvent : INotification
{
    #region Fields, Properties and Indexers

    Guid EventId => Guid.NewGuid();

    public DateTimeOffset OccurredOn => DateTime.Now;

    public string EventType => GetType()?.AssemblyQualifiedName ?? string.Empty;

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Abstractions/IEntityId.cs">
namespace Inventory.Domain.Abstractions;

public interface IEntityId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; set; }

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Abstractions/IModificationAuditable.cs">
namespace Inventory.Domain.Abstractions;

public interface IModificationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Abstractions/IUnitOfWork.cs">
#region using

using Inventory.Domain.Repositories;

#endregion

namespace Inventory.Domain.Abstractions;

public interface IUnitOfWork
{
    #region Fields, Properties and Indexers

    IInventoryReservationRepository InventoryReservations { get; }

    IInventoryItemRepository InventoryItems { get; }

    IInventoryHistoryRepository InventoryHistories { get; }

    ILocationRepository Locations { get; }

    IInboxMessageRepository InboxMessages { get; }

    IOutboxMessageRepository OutboxMessages { get; }

    #endregion

    #region Methods

    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);

    Task<IDbTransaction> BeginTransactionAsync(CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Entities/InboxMessageEntity.cs">
#region using

using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Domain.Entities;

public sealed class InboxMessageEntity : EntityId<Guid>
{
    #region Fields, Properties and Indexers

    public string? EventType { get; set; }

    public string? Content { get; set; }

    public DateTimeOffset ReceivedOnUtc { get; set; }

    public DateTimeOffset? ProcessedOnUtc { get; set; }

    public string? LastErrorMessage { get; set; }

    #endregion

    #region Factories

    public static InboxMessageEntity Create(Guid id, string eventType, string content, DateTimeOffset receivedOnUtc)
    {
        return new InboxMessageEntity()
        {
            Id = id,
            EventType = eventType,
            Content = content,
            ReceivedOnUtc = receivedOnUtc
        };
    }

    #endregion

    #region Methods

    public void CompleteProcessing(DateTimeOffset processedOnUtc, string? lastErrorMessage = null)
    {
        ProcessedOnUtc = processedOnUtc;
        LastErrorMessage = lastErrorMessage;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Entities/InventoryHistoryEntity.cs">
#region using

using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Domain.Entities;

public sealed class InventoryHistoryEntity : Entity<Guid>
{
    #region Fields, Properties and Indexers

    public string Message { get; set; } = default!;

    #endregion

    #region Factories

    public static InventoryHistoryEntity Create(Guid id, string message, string performBy)
    {
        var now = DateTimeOffset.UtcNow;
        return new InventoryHistoryEntity
        {
            Id = id,
            Message = message,
            CreatedBy = performBy,
            CreatedOnUtc = now,
            LastModifiedBy = performBy,
            LastModifiedOnUtc = now
        };
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Entities/InventoryItemEntity.cs">
#region using

using Inventory.Domain.Abstractions;
using Inventory.Domain.Enums;
using Inventory.Domain.Events;
using Inventory.Domain.Exceptions;
using Inventory.Domain.ValueObjects;
using Common.Extensions;

#endregion

namespace Inventory.Domain.Entities;

public sealed class InventoryItemEntity : Aggregate<Guid>
{
    #region Fields, Properties and Indexers

    public Product Product { get; set; } = default!;

    public int Quantity { get; set; }

    public int Reserved { get; set; }

    public int Available => Quantity - Reserved;

    public Guid LocationId { get; set; }

    public LocationEntity Location { get; set; } = default!;

    #endregion

    #region Factories

    public static InventoryItemEntity Create(Guid id,
        Guid productId,
        string productName,
        Guid locationId,
        string performedBy,
        int quantity = 0)
    {
        if (quantity < 0) throw new ArgumentOutOfRangeException(nameof(quantity));
        if (locationId == Guid.Empty) throw new ArgumentException(nameof(locationId));

        var entity = new InventoryItemEntity
        {
            Id = id,
            Product = Product.Of(productId, productName),
            Quantity = quantity,
            Reserved = 0,
            LocationId = locationId,
            CreatedBy = performedBy,
            LastModifiedBy = performedBy
        };

        entity.AddDomainEvent(new StockChangedDomainEvent(id,
            productId,
            productName,
            quantity,
            0,
            quantity,
            InventoryChangeType.Init,
            InventorySource.ManualAdjustment.GetDescription(),
            entity.Available));

        return entity;
    }

    #endregion

    #region Methods

    public void Update(Guid locationId,
        string? oldLocationName,
        string? newLocationName,
        string performedBy,
        Guid productId,
        string productName)
    {
        if (locationId == Guid.Empty) throw new ArgumentException(nameof(locationId));

        var oldLocationId = LocationId;
        var locationChanged = oldLocationId != locationId;

        Product = Product.Of(productId, productName);
        LocationId = locationId;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;

        if (locationChanged)
        {
            AddDomainEvent(new LocationChangedDomainEvent(
                Id,
                Product.Id,
                Product.Name!,
                oldLocationName!,
                newLocationName!));
        }
    }

    public void Increase(
        int amount,
        string source,
        string performedBy)
    {
        if (amount <= 0) throw new DomainException(MessageCode.OutOfRange);

        var oldQuantity = Quantity;

        Quantity += amount;
        LastModifiedBy = performedBy;

        AddDomainEvent(new StockChangedDomainEvent(Id,
            Product.Id,
            Product.Name!,
            amount,
            oldQuantity,
            Quantity,
            InventoryChangeType.Increase,
            source,
            Available));
    }

    public void Decrease(
        int amount,
        string source,
        string performedBy)
    {
        if (amount <= 0) throw new DomainException(MessageCode.OutOfRange);
        if (Quantity - amount < 0) throw new DomainException(MessageCode.InsufficientStock);
        if (Quantity - amount < Reserved) throw new DomainException(MessageCode.InsufficientStock);

        var oldQuantity = Quantity;

        Quantity -= amount;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;

        AddDomainEvent(new StockChangedDomainEvent(Id,
            Product.Id,
            Product.Name!,
            amount,
            oldQuantity,
            Quantity,
            InventoryChangeType.Decrease,
            source,
            Available));
    }

    public bool HasAvailable(int amount)
    {
        if (amount <= 0) throw new DomainException(MessageCode.OutOfRange);
        return Available >= amount;
    }

    public bool IsLocationChanged(Guid newLocationId)
    {
        if (newLocationId == Guid.Empty) throw new ArgumentException(nameof(newLocationId));
        return LocationId != newLocationId;
    }

    public void Delete()
    {
        AddDomainEvent(new InventoryItemDeletedDomainEvent(this));
    }

    public void Reserve(int amount, Guid reservationId, string performedBy)
    {
        if (amount <= 0) throw new DomainException(MessageCode.OutOfRange);
        if (Quantity < amount) throw new DomainException(MessageCode.InsufficientStock);

        var oldQuantity = Quantity;

        Quantity -= amount;
        Reserved += amount;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;

        AddDomainEvent(new StockChangedDomainEvent(
            Id,
            Product.Id,
            Product.Name!,
            amount,
            oldQuantity,
            Quantity,
            InventoryChangeType.Reserve,
            InventorySource.OrderService.GetDescription(),
            Available));
    }

    public void Unreserve(int amount, Guid reservationId, string performedBy)
    {
        if (amount <= 0) throw new DomainException(MessageCode.OutOfRange);
        if (Reserved < amount) throw new DomainException(MessageCode.InvalidReservationAmount);

        var oldQuantity = Quantity;

        Quantity += amount;
        Reserved -= amount;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;

        AddDomainEvent(new StockChangedDomainEvent(
            Id,
            Product.Id,
            Product.Name!,
            amount,
            oldQuantity,
            Quantity,
            InventoryChangeType.Release,
            InventorySource.OrderService.GetDescription(),
            Available));
    }

    public void CommitReservation(int amount, string performedBy)
    {
        if (amount <= 0) throw new DomainException(MessageCode.OutOfRange);
        if (Reserved < amount) throw new DomainException(MessageCode.InvalidReservationAmount);

        var oldQuantity = Quantity;

        Reserved -= amount;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;

        AddDomainEvent(new StockChangedDomainEvent(
            Id,
            Product.Id,
            Product.Name!,
            amount,
            oldQuantity,
            Quantity,
            InventoryChangeType.Commit,
            InventorySource.OrderService.GetDescription(),
            Available));
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Entities/InventoryReservationEntity.cs">
#region using

using Inventory.Domain.Abstractions;
using Inventory.Domain.Enums;
using Inventory.Domain.Events;
using Inventory.Domain.ValueObjects;

#endregion

namespace Inventory.Domain.Entities;

public sealed class InventoryReservationEntity : Aggregate<Guid>
{
    #region Fields, Properties and Indexers

    public Product Product { get; set; } = default!;

    public Guid ReferenceId { get; set; }

    public int Quantity { get; set; }

    public DateTimeOffset? ExpiresAt { get; set; }

    public ReservationStatus Status { get; set; }

    public Guid LocationId { get; set; }

    public LocationEntity Location { get; set; } = default!;

    #endregion

    #region Factories

    public static InventoryReservationEntity Create(
        Guid id,
        Guid productId,
        string productName,
        Guid referenceId,
        Guid locationId,
        int quantity,
        DateTimeOffset? expiresAt,
        string performedBy)
    {
        if (quantity <= 0) throw new ArgumentOutOfRangeException(nameof(quantity));
        if (locationId == Guid.Empty) throw new ArgumentException("LocationId cannot be empty", nameof(locationId));

        var entity = new InventoryReservationEntity
        {
            Id = id,
            Product = Product.Of(productId, productName),
            ReferenceId = referenceId,
            LocationId = locationId,
            Quantity = quantity,
            ExpiresAt = expiresAt,
            Status = ReservationStatus.Pending,
            CreatedBy = performedBy,
            LastModifiedBy = performedBy
        };

        entity.AddDomainEvent(new ReservationCreatedDomainEvent(id, productId, productName, referenceId, locationId, quantity, expiresAt));

        return entity;
    }

    #endregion

    #region Methods

    public void MarkCommitted(string performedBy)
    {
        if (Status != ReservationStatus.Pending) throw new InvalidOperationException(MessageCode.CannotCommitNonPendingReservation);

        Status = ReservationStatus.Committed;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;

        AddDomainEvent(new ReservationCommittedDomainEvent(Id, Product.Id, Product.Name!, ReferenceId, LocationId, Quantity));
    }

    public void Release(string reason, string performedBy)
    {
        if (Status != ReservationStatus.Pending) return;

        Status = ReservationStatus.Released;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;

        AddDomainEvent(new ReservationReleasedDomainEvent(Id, Product.Id, Product.Name!, ReferenceId, LocationId, Quantity, reason));
    }

    public void Expire()
    {
        if (Status == ReservationStatus.Pending && ExpiresAt.HasValue && ExpiresAt.Value <= DateTimeOffset.UtcNow)
        {
            Status = ReservationStatus.Expired;

            AddDomainEvent(new ReservationExpiredDomainEvent(Id, Product.Id, Product.Name!, ReferenceId, LocationId, Quantity));
        }
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Entities/LocationEntity.cs">
#region using

using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Domain.Entities;

public class LocationEntity : Entity<Guid>
{
    #region Fields, Properties and Indexers

    public string? Location { get; set; }

    #endregion

    #region Factories

    public static LocationEntity Create(Guid id, string location, string performBy)
    {
        if (string.IsNullOrWhiteSpace(location)) throw new ArgumentNullException(nameof(location));

        var entity = new LocationEntity
        {
            Id = id,
            Location = location,
            CreatedBy = performBy,
            CreatedOnUtc = DateTimeOffset.UtcNow,
            LastModifiedBy = performBy,
            LastModifiedOnUtc = DateTimeOffset.UtcNow
        };

        return entity;
    }

    #endregion

    #region Methods

    public void Update(string location, string performBy)
    {
        if (string.IsNullOrWhiteSpace(location)) throw new ArgumentNullException(nameof(location));

        Location = location;
        LastModifiedBy = performBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Entities/OutboxMessageEntity.cs">
#region using

using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Domain.Entities;

public sealed class OutboxMessageEntity : EntityId<Guid>
{
    #region Fields, Properties and Indexers

    public string? EventType { get; set; }

    public string? Content { get; set; }

    public DateTimeOffset OccurredOnUtc { get; set; }

    public DateTimeOffset? ProcessedOnUtc { get; set; }

    public string? LastErrorMessage { get; set; }

    public int AttemptCount { get; set; }

    public int MaxAttempts { get; set; }

    public DateTimeOffset? NextAttemptOnUtc { get; set; }

    #endregion

    #region Factories

    public static OutboxMessageEntity Create(
        Guid id,
        string eventType,
        string content,
        DateTimeOffset occurredOnUtc)
    {
        return new OutboxMessageEntity()
        {
            Id = id,
            EventType = eventType,
            Content = content,
            OccurredOnUtc = occurredOnUtc,
            MaxAttempts = AppConstants.MaxAttempts,
            AttemptCount = 0
        };
    }

    #endregion

    #region Methods

    public void CompleteProcessing(DateTimeOffset processedOnUtc)
    {
        ProcessedOnUtc = processedOnUtc;
        LastErrorMessage = null;
        NextAttemptOnUtc = null;
    }

    public void SetRetryProperties(
        int attemptCount,
        int maxAttempts,
        DateTimeOffset? nextAttemptOnUtc,
        string? lastErrorMessage)
    {
        AttemptCount = attemptCount;
        MaxAttempts = maxAttempts;
        NextAttemptOnUtc = nextAttemptOnUtc;
        LastErrorMessage = lastErrorMessage;
    }

    public void RecordFailedAttempt(string errorMessage, DateTimeOffset now)
    {
        IncreaseAttemptCount();

        if (AttemptCount >= MaxAttempts)
        {
            LastErrorMessage = $"Max attempts ({MaxAttempts}) exceeded. Last error: {errorMessage}";
            NextAttemptOnUtc = null;
        }
        else
        {
            // Calculate exponential backoff with jitter
            var baseDelay = TimeSpan.FromSeconds(Math.Pow(2, AttemptCount - 1));
            var maxDelay = TimeSpan.FromMinutes(5);
            var jitter = TimeSpan.FromMilliseconds(Random.Shared.Next(0, 1000));
            var delay = TimeSpan.FromTicks(Math.Min(baseDelay.Ticks, maxDelay.Ticks)) + jitter;

            NextAttemptOnUtc = now + delay;
            LastErrorMessage = errorMessage;
        }
    }

    public void IncreaseAttemptCount()
    {
        AttemptCount += 1;
    }

    public bool CanRetry(DateTimeOffset currentTime)
    {
        return AttemptCount < MaxAttempts &&
               (NextAttemptOnUtc == null || currentTime >= NextAttemptOnUtc.Value);
    }

    public bool IsPermanentlyFailed()
    {
        return AttemptCount >= MaxAttempts;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Enums/InventoryChangeType.cs">
namespace Inventory.Domain.Enums;

public enum InventoryChangeType
{
    Increase = 1,
    Decrease = 2,
    Reserve = 3,
    Release = 4,
    Commit = 5,
    Init = 6,
    Transfer = 7
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Enums/InventorySource.cs">
#region using

using System.ComponentModel;

#endregion

namespace Inventory.Domain.Enums;

public enum InventorySource
{
    [Description("unknown")]
    Unknown = 0,

    [Description("order-service")]
    OrderService = 1,

    [Description("purchase-order")]
    PurchaseOrder = 2,

    [Description("manual-adjustment")]
    ManualAdjustment = 3,

    [Description("transfer")]
    Transfer = 4,

    [Description("return")]
    Return = 5,

    [Description("system")]
    System = 6,

    [Description("manual-delete")]
    ManualDelete = 7,

    [Description("merge")]
    Merge = 8,
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Enums/ReservationStatus.cs">
namespace Inventory.Domain.Enums;

public enum ReservationStatus
{
    Pending = 1,
    Committed = 2,
    Released = 3,
    Expired = 4
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Events/InventoryItemDeletedDomainEvent.cs">
#region using

using Inventory.Domain.Abstractions;
using Inventory.Domain.Entities;

#endregion

namespace Inventory.Domain.Events;

public sealed record class InventoryItemDeletedDomainEvent(InventoryItemEntity Inventory) : IDomainEvent;
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Events/LocationChangedDomainEvent.cs">
#region using

using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Domain.Events;

public sealed record class LocationChangedDomainEvent(
    Guid InventoryItemId,
    Guid ProductId,
    string ProductName,
    string OldLocation,
    string NewLocation) : IDomainEvent;
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Events/ReservationCommittedDomainEvent.cs">
#region using

using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Domain.Events;

public sealed record ReservationCommittedDomainEvent(
    Guid ReservationId,
    Guid ProductId,
    string ProductName,
    Guid ReferenceId,
    Guid LocationId,
    int Quantity) : IDomainEvent;
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Events/ReservationCreatedDomainEvent.cs">
#region using

using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Domain.Events;

public sealed record ReservationCreatedDomainEvent(
    Guid ReservationId,
    Guid ProductId,
    string ProductName,
    Guid ReferenceId,
    Guid LocationId,
    long Quantity,
    DateTimeOffset? ExpiresAt) : IDomainEvent;
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Events/ReservationExpiredDomainEvent.cs">
#region using

using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Domain.Events;

public sealed record ReservationExpiredDomainEvent(
    Guid ReservationId,
    Guid ProductId,
    string ProductName,
    Guid ReferenceId,
    Guid LocationId,
    int Quantity) : IDomainEvent;
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Events/ReservationReleasedDomainEvent.cs">
#region using

using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Domain.Events;

public sealed record ReservationReleasedDomainEvent(
    Guid ReservationId,
    Guid ProductId,
    string ProductName,
    Guid ReferenceId,
    Guid LocationId,
    int Quantity,
    string Reason) : IDomainEvent;
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Events/StockChangedDomainEvent.cs">
#region using

using Inventory.Domain.Abstractions;
using Inventory.Domain.Enums;

#endregion

namespace Inventory.Domain.Events;

public sealed record class StockChangedDomainEvent(
    Guid InventoryItemId,
    Guid ProductId,
    string ProductName,
    int ChangeAmount,
    int OldQuantity,
    int QuantityAfterChange,
    InventoryChangeType ChangeType,
    string Source,
    int Available) : IDomainEvent;
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Events/TransferOutDomainEvent.cs">
#region using

using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Domain.Events;

public sealed record class TransferOutDomainEvent(
    Guid Id,
    Guid ProductId,
    Guid FromLocation,
    Guid ToLocation,
    int Amount,
    string Reference) : IDomainEvent;
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Exceptions/DomainException.cs">
namespace Inventory.Domain.Exceptions;

public sealed class DomainException : Exception
{
    public DomainException(string message) : base(message)
    {
    }
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Repositories/IInboxMessageRepository.cs">
#region using

using Inventory.Domain.Entities;

#endregion

namespace Inventory.Domain.Repositories;

public interface IInboxMessageRepository : IRepository<InboxMessageEntity>
{
    #region Methods

    Task<InboxMessageEntity?> GetByMessageIdAsync(Guid messageId, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Repositories/IInventoryHistoryRepository.cs">
#region using

using Inventory.Domain.Entities;

#endregion

namespace Inventory.Domain.Repositories;

public interface IInventoryHistoryRepository : IRepository<InventoryHistoryEntity>
{
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Repositories/IInventoryItemRepository.cs">
#region using

using Inventory.Domain.Entities;
using System.Linq.Expressions;

#endregion

namespace Inventory.Domain.Repositories;

public interface IInventoryItemRepository : IRepository<InventoryItemEntity>
{
    #region Methods

    Task<List<InventoryItemEntity>> GetAllWithRelationshipAsync(CancellationToken cancellationToken = default);

    Task<List<InventoryItemEntity>> FindByProductWithRelationshipAsync(Guid productId, CancellationToken cancellationToken = default);

    Task<List<InventoryItemEntity>> SearchWithRelationshipAsync(Expression<Func<InventoryItemEntity, bool>> predicate,
        PaginationRequest pagination,
        CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Repositories/IInventoryReservationRepository.cs">
#region using

using Inventory.Domain.Entities;

#endregion

namespace Inventory.Domain.Repositories;

public interface IInventoryReservationRepository : IRepository<InventoryReservationEntity>
{
    #region Methods

    Task<InventoryReservationEntity?> GetByOrderAndProductAsync(
        Guid orderId,
        Guid productId,
        CancellationToken cancellationToken = default);

    Task<List<InventoryReservationEntity>> GetAllWithRelationshipAsync(CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Repositories/ILocationRepository.cs">
#region using

using Inventory.Domain.Entities;

#endregion

namespace Inventory.Domain.Repositories;

public interface ILocationRepository : IRepository<LocationEntity>
{
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Repositories/IOutboxMessageRepository.cs">
#region using

using Inventory.Domain.Entities;

#endregion

namespace Inventory.Domain.Repositories;

public interface IOutboxMessageRepository : IRepository<OutboxMessageEntity>
{
    #region Methods

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Repositories/IRepository.cs">
#region using

using System.Linq.Expressions;

#endregion

namespace Inventory.Domain.Repositories;

public interface IRepository<T> where T : class
{
    #region Methods

    Task<T?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    Task<T?> FirstOrDefaultAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

    Task<T?> SingleOrDefaultAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

    Task<IReadOnlyList<T>> GetAllAsync(CancellationToken cancellationToken = default);

    Task<IReadOnlyList<T>> FindAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

    Task<long> CountAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

    Task<long> CountAsync(CancellationToken cancellationToken = default);

    Task<bool> AnyAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

    Task AddAsync(T entity, CancellationToken cancellationToken = default);

    Task AddRangeAsync(IEnumerable<T> entities, CancellationToken cancellationToken = default);

    void Update(T entity);

    void UpdateRange(IEnumerable<T> entities);

    void Remove(T entity);

    void RemoveRange(IEnumerable<T> entities);

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/ValueObjects/Product.cs">
namespace Inventory.Domain.ValueObjects;

public sealed class Product
{
    #region Fields, Properties and Indexers

    public Guid Id { get; set; }

    public string? Name { get; set; }

    #endregion

    #region Ctors

    private Product() { }

    #endregion

    #region Methods

    public static Product Of(Guid id, string name)
    {
        if (id == Guid.Empty) throw new ArgumentNullException(nameof(id));
        if (string.IsNullOrWhiteSpace(name)) throw new ArgumentNullException(nameof(name));

        return new Product
        {
            Id = id,
            Name = name
        };
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Domain/GlobalUsing.cs">
global using Common.Constants;
global using Common.Models;
</file>

<file path="Services/Inventory/Core/Inventory.Domain/Inventory.Domain.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="MediatR" />
    <PackageReference Include="Newtonsoft.Json" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/ApiClients/Extensions/ApiClientExtension.cs">
#region using

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Refit;

#endregion

namespace Inventory.Infrastructure.ApiClients.Extensions;

public static class ApiClientExtension
{
    #region Methods

    public static IServiceCollection AddRefitClients(this IServiceCollection services, IConfiguration cfg)
    {
        services.AddRefitClient<IKeycloakApi>()
                .ConfigureHttpClient(c =>
                {
                    c.BaseAddress = new Uri(cfg[$"{ApiClientCfg.Keycloak.Section}:{ApiClientCfg.Keycloak.BaseUrl}"]!);
                    c.Timeout = TimeSpan.FromSeconds(30);
                });

        services.AddRefitClient<ICatalogApi>()
            .ConfigureHttpClient(c =>
            {
                c.BaseAddress = new Uri(cfg[$"{ApiClientCfg.Catalog.Section}:{ApiClientCfg.Catalog.BaseUrl}"]!);
                c.Timeout = TimeSpan.FromSeconds(30);
            });

        return services;
    }

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/ApiClients/ICatalogApi.cs">
#region using

using Common.Models.Reponses;
using Inventory.Application.Models.Responses.Externals;
using Refit;

#endregion

namespace Inventory.Infrastructure.ApiClients;

public interface ICatalogApi
{
    #region Methods

    [Get("/admin/products/{productId}")]
    Task<ApiGetResponse<GetProductByIdReponse>> GetProductByIdAsync([AliasAs("productId")] string productId, [Header("Authorization")] string bearerToken);

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/ApiClients/IKeycloakApi.cs">
#region using

using Inventory.Application.Models.Responses.Externals;
using Refit;

#endregion

namespace Inventory.Infrastructure.ApiClients;

public interface IKeycloakApi
{
    #region Methods

    [Post("/realms/{realm}/protocol/openid-connect/token")]
    [Headers("Content-Type: application/x-www-form-urlencoded")]
    Task<KeycloakAccessTokenResponse> GetAccessTokenAsync(
        [AliasAs("realm")] string realm,
        [Body(BodySerializationMethod.UrlEncoded)] Dictionary<string, string> form);

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Configurations/InboxMessageConfiguration.cs">
#region using

using Inventory.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

#endregion

namespace Inventory.Infrastructure.Data.Configurations;

public sealed class InboxMessageConfiguration : IEntityTypeConfiguration<InboxMessageEntity>
{
    #region Implementations

    public void Configure(EntityTypeBuilder<InboxMessageEntity> builder)
    {
        builder.ToTable("inbox_messages");

        builder.HasKey(x => x.Id);

        builder.Property(x => x.Id)
            .HasColumnName("id");

        builder.Property(x => x.EventType)
            .HasColumnName("event_type")
            .IsRequired();

        builder.Property(x => x.Content)
            .HasColumnName("content")
            .IsRequired();

        builder.Property(x => x.ReceivedOnUtc)
            .HasColumnName("received_on_utc")
            .IsRequired();

        builder.Property(x => x.ProcessedOnUtc)
            .HasColumnName("processed_on_utc");

        builder.Property(x => x.LastErrorMessage)
            .HasColumnName("last_error_message");

        builder.HasIndex(x => new { x.ProcessedOnUtc });
    }

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Configurations/InventoryHistoryConfiguration.cs">
#region using

using Inventory.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

#endregion

namespace Inventory.Infrastructure.Data.Configurations;

public sealed class InventoryHistoryConfiguration : IEntityTypeConfiguration<InventoryHistoryEntity>
{
    #region Implementations

    public void Configure(EntityTypeBuilder<InventoryHistoryEntity> builder)
    {
        builder.ToTable("inventory_histories");

        builder.HasKey(x => x.Id);

        builder.Property(x => x.Id)
            .HasColumnName("id");

        builder.Property(x => x.Message)
            .HasColumnName("message");

        builder.Property(x => x.CreatedOnUtc)
            .HasColumnName("created_on_utc")
            .IsRequired();

        builder.Property(x => x.CreatedBy)
            .HasColumnName("created_by")
            .HasMaxLength(50)
            .IsRequired();

        builder.Property(x => x.LastModifiedOnUtc)
            .HasColumnName("last_modified_on_utc");

        builder.Property(x => x.LastModifiedBy)
            .HasColumnName("last_modified_by")
            .HasMaxLength(50);

        //builder.HasIndex(x => x.CreatedOnUtc);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Configurations/InventoryItemConfiguration.cs">
#region using

using Inventory.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

#endregion

namespace Inventory.Infrastructure.Data.Configurations;

public sealed class InventoryItemConfiguration : IEntityTypeConfiguration<InventoryItemEntity>
{
    #region Implementations

    public void Configure(EntityTypeBuilder<InventoryItemEntity> builder)
    {
        builder.ToTable("inventory_items");

        builder.HasKey(x => x.Id);

        builder.Property(x => x.Id)
            .HasColumnName("id");

        builder.Property(x => x.Quantity)
            .HasColumnName("quantity")
            .IsRequired();

        builder.Property(x => x.Reserved)
            .HasColumnName("reserved");

        builder.Property(x => x.CreatedOnUtc)
            .HasColumnName("created_on_utc")
            .IsRequired();

        builder.Property(x => x.CreatedBy)
            .HasColumnName("created_by")
            .HasMaxLength(50)
            .IsRequired();

        builder.Property(x => x.LastModifiedOnUtc)
            .HasColumnName("last_modified_on_utc");

        builder.Property(x => x.LastModifiedBy)
            .HasColumnName("last_modified_by")
            .HasMaxLength(50);

        builder.ComplexProperty(
            o => o.Product, b =>
            {
                b.Property(n => n.Id)
                    .HasColumnName("product_id")
                    .HasMaxLength(50)
                    .IsRequired();

                b.Property(n => n.Name)
                    .HasColumnName("product_name")
                    .HasMaxLength(255)
                    .IsRequired();
            });

        builder.Property(x => x.LocationId)
            .HasColumnName("location_id")
            .IsRequired();

        builder.HasOne(x => x.Location)
            .WithMany()
            .HasForeignKey(x => x.LocationId)
            .OnDelete(DeleteBehavior.Restrict);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Configurations/InventoryReservationConfiguration.cs">
#region using

using Inventory.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

#endregion

namespace Inventory.Infrastructure.Data.Configurations;

public sealed class InventoryReservationConfiguration : IEntityTypeConfiguration<InventoryReservationEntity>
{
    #region Implementations

    public void Configure(EntityTypeBuilder<InventoryReservationEntity> builder)
    {
        builder.ToTable("inventory_reservations");

        builder.HasKey(x => x.Id);

        builder.Property(x => x.Id)
            .HasColumnName("id");

        builder.Property(x => x.ReferenceId)
            .HasColumnName("reference_id")
            .IsRequired();

        builder.Property(x => x.Quantity)
            .HasColumnName("quantity")
            .IsRequired();

        builder.Property(x => x.ExpiresAt)
            .HasColumnName("expires_at");

        builder.Property(x => x.CreatedOnUtc)
            .HasColumnName("created_on_utc")
            .IsRequired();

        builder.Property(x => x.CreatedBy)
            .HasColumnName("created_by")
            .HasMaxLength(50)
            .IsRequired();

        builder.Property(x => x.LastModifiedOnUtc)
            .HasColumnName("last_modified_on_utc");

        builder.Property(x => x.LastModifiedBy)
            .HasColumnName("last_modified_by")
            .HasMaxLength(50);

        builder.Property(x => x.Status)
            .HasColumnName("status")
            .HasConversion<int>()
            .IsRequired();

        builder.ComplexProperty(
            o => o.Product, nameBuilder =>
            {
                nameBuilder.Property(n => n.Id)
                    .HasColumnName("product_id")
                    .HasMaxLength(50)
                    .IsRequired();
                nameBuilder.Property(n => n.Name)
                    .HasColumnName("product_name")
                    .HasMaxLength(50)
                    .IsRequired();
            });

        builder.Property(x => x.LocationId)
            .HasColumnName("location_id")
            .IsRequired();

        builder.HasOne(x => x.Location)
            .WithMany()
            .HasForeignKey(x => x.LocationId)
            .OnDelete(DeleteBehavior.Restrict);

        builder.HasIndex(x => new { x.ReferenceId });
        builder.HasIndex(x => new { x.Status, x.ExpiresAt });
    }

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Configurations/LocationEntityConfiguration.cs">
#region using

using Inventory.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

#endregion

namespace Inventory.Infrastructure.Data.Configurations;

public sealed class LocationEntityConfiguration : IEntityTypeConfiguration<LocationEntity>
{
    #region Implementations

    public void Configure(EntityTypeBuilder<LocationEntity> builder)
    {
        builder.ToTable("locations");

        builder.HasKey(x => x.Id);

        builder.Property(x => x.Id)
            .HasColumnName("id")
            .IsRequired();

        builder.Property(x => x.Location)
            .HasColumnName("location")
            .HasMaxLength(255)
            .IsRequired();
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Configurations/OutboxMessageConfiguration.cs">
#region using

using Inventory.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

#endregion

namespace Inventory.Infrastructure.Data.Configurations;

public sealed class OutboxMessageConfiguration : IEntityTypeConfiguration<OutboxMessageEntity>
{
    #region Implementations

    public void Configure(EntityTypeBuilder<OutboxMessageEntity> builder)
    {
        builder.ToTable("outbox_messages");

        builder.HasKey(x => x.Id);

        builder.Property(x => x.Id)
            .HasColumnName("id");

        builder.Property(x => x.EventType)
            .HasColumnName("event_type")
            .IsRequired();

        builder.Property(x => x.Content)
            .HasColumnName("content")
            .IsRequired();

        builder.Property(x => x.OccurredOnUtc)
            .HasColumnName("occurred_on_utc")
            .IsRequired();

        builder.Property(x => x.ProcessedOnUtc)
            .HasColumnName("processed_on_utc");

        builder.Property(x => x.LastErrorMessage)
            .HasColumnName("last_error_message");

        builder.Property(x => x.AttemptCount)
            .HasColumnName("attempt_count")
            .HasDefaultValue(0)
            .IsRequired();

        builder.Property(x => x.MaxAttempts)
            .HasColumnName("max_attempts")
            .HasDefaultValue(3)
            .IsRequired();

        builder.Property(x => x.NextAttemptOnUtc)
            .HasColumnName("next_attempt_on_utc");

        builder.HasIndex(x => new { x.EventType });
        builder.HasIndex(x => new { x.OccurredOnUtc });
        builder.HasIndex(x => new { x.ProcessedOnUtc });
        builder.HasIndex(x => new { x.NextAttemptOnUtc, x.ProcessedOnUtc, x.AttemptCount });
        builder.HasIndex(x => new { x.ProcessedOnUtc, x.AttemptCount, x.MaxAttempts });

    }

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Extensions/AuditableEntityInterceptorExtensions.cs">
#region using

using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore;

#endregion

namespace Inventory.Infrastructure.Data.Extensions;

public static class AuditableEntityInterceptorExtensions
{
    #region Methods

    /// <summary>
    /// Checks if an entity has changed complex properties (value objects in EF Core 8+)
    /// </summary>
    public static bool HasChangedComplexProperties(this EntityEntry entry) =>
        entry.ComplexProperties.Any(cp => cp.IsModified);

    /// <summary>
    /// Legacy method for backward compatibility - checks for both owned entities and complex properties
    /// </summary>
    public static bool HasChangedOwnedEntities(this EntityEntry entry) =>
        // Check for owned entities (legacy approach)
        entry.References.Any(r =>
            r.TargetEntry != null &&
            r.TargetEntry.Metadata.IsOwned() &&
            (r.TargetEntry.State == EntityState.Added || r.TargetEntry.State == EntityState.Modified)) ||
        // Check for complex properties (EF Core 8+ approach)
        entry.ComplexProperties.Any(cp => cp.IsModified);

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Extensions/DatabaseExtentions.cs">
#region using

using Common.ValueObjects;
using Inventory.Domain.Entities;
using Microsoft.AspNetCore.Builder;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;

#endregion

namespace Inventory.Infrastructure.Data.Extensions;

public static class DatabaseExtentions
{
    #region Methods

    public static async Task InitialiseDatabaseAsync(this WebApplication app)
    {
        using var scope = app.Services.CreateScope();
        var dbContext = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();

        await SeedDataAsync(dbContext);
    }

    private static async Task SeedDataAsync(ApplicationDbContext dbContext)
    {
        if (await dbContext.Locations.AnyAsync())
        {
            return;
        }

        var performBy = Actor.System(AppConstants.Service.Inventory).ToString();
        var location1 = LocationEntity.Create(Guid.Parse("a2d8c5a8-2a64-4b6d-a1c0-0c8b4b9c1a11"),
            "H Ni",
            performBy);
        var location2 = LocationEntity.Create(Guid.Parse("a2d8c5a8-2a64-4b6d-a1c0-0c8b4b9c1a12"),
            " Nng",
            performBy);
        var location3 = LocationEntity.Create(Guid.Parse("a2d8c5a8-2a64-4b6d-a1c0-0c8b4b9c1a13"),
            "H Ch Minh",
            performBy);

        await dbContext.Locations.AddRangeAsync(location1, location2, location3);
        await dbContext.SaveChangesAsync();
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Interceptors/AuditableEntityInterceptor.cs">
#region using

using Inventory.Domain.Abstractions;
using Inventory.Infrastructure.Data.Extensions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;

#endregion

namespace Inventory.Infrastructure.Data.Interceptors;

public sealed class AuditableEntityInterceptor : SaveChangesInterceptor
{
    #region Override Methods

    public override InterceptionResult<int> SavingChanges(DbContextEventData eventData, InterceptionResult<int> result)
    {
        UpdateEntities(eventData.Context);
        return base.SavingChanges(eventData, result);
    }

    public override ValueTask<InterceptionResult<int>> SavingChangesAsync(DbContextEventData eventData,
        InterceptionResult<int> result,
        CancellationToken cancellationToken = default)
    {
        UpdateEntities(eventData.Context);
        return base.SavingChangesAsync(eventData, result, cancellationToken);
    }

    #endregion

    #region Methods

    public static void UpdateEntities(DbContext? context)
    {
        if (context == null) return;

        foreach (var entry in context.ChangeTracker.Entries<IAuditable>())
        {
            if (entry.State == EntityState.Added)
            {
                // For new entities, set both created and modified timestamps
                entry.Entity.CreatedOnUtc = DateTimeOffset.UtcNow;
                entry.Entity.LastModifiedOnUtc = DateTimeOffset.UtcNow;
            }
            else if (entry.State == EntityState.Modified || entry.HasChangedOwnedEntities())
            {
                // For existing entities, only update the modified timestamp
                entry.Entity.LastModifiedOnUtc = DateTimeOffset.UtcNow;
            }
        }
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Interceptors/DispatchDomainEventsInterceptor.cs">
#region using

using MediatR;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Infrastructure.Data.Interceptors;

public class DispatchDomainEventsInterceptor(IMediator mediator) : SaveChangesInterceptor
{
    public override InterceptionResult<int> SavingChanges(DbContextEventData eventData, InterceptionResult<int> result)
    {
        DispatchDomainEvents(eventData.Context).GetAwaiter().GetResult();
        return base.SavingChanges(eventData, result);
    }

    public override async ValueTask<InterceptionResult<int>> SavingChangesAsync(
        DbContextEventData eventData,
        InterceptionResult<int> result,
        CancellationToken cancellationToken = default)
    {
        await DispatchDomainEvents(eventData.Context);
        return await base.SavingChangesAsync(eventData, result, cancellationToken);
    }

    public async Task DispatchDomainEvents(DbContext? context)
    {
        if (context == null) return;

        var aggregates = context.ChangeTracker
            .Entries<IAggregate>()
            .Where(a => a.Entity.DomainEvents.Any())
            .Select(a => a.Entity);

        var domainEvents = aggregates
            .SelectMany(a => a.DomainEvents)
            .ToList();

        aggregates.ToList().ForEach(a => a.ClearDomainEvents());

        foreach (var domainEvent in domainEvents)
            await mediator.Publish(domainEvent);
    }
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Migrations/20251218115210_init_database.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Inventory.Infrastructure.Data.Migrations
{
    /// <inheritdoc />
    public partial class init_database : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AlterDatabase()
                .Annotation("MySQL:Charset", "utf8mb4");

            migrationBuilder.CreateTable(
                name: "inventory_histories",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "char(36)", nullable: false),
                    message = table.Column<string>(type: "longtext", nullable: false),
                    created_on_utc = table.Column<DateTimeOffset>(type: "datetime", nullable: false),
                    created_by = table.Column<string>(type: "varchar(50)", maxLength: 50, nullable: false),
                    last_modified_on_utc = table.Column<DateTimeOffset>(type: "datetime", nullable: true),
                    last_modified_by = table.Column<string>(type: "varchar(50)", maxLength: 50, nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_inventory_histories", x => x.id);
                })
                .Annotation("MySQL:Charset", "utf8mb4");

            migrationBuilder.CreateTable(
                name: "locations",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "char(36)", nullable: false),
                    location = table.Column<string>(type: "varchar(255)", maxLength: 255, nullable: false),
                    CreatedOnUtc = table.Column<DateTimeOffset>(type: "datetime", nullable: false),
                    CreatedBy = table.Column<string>(type: "longtext", nullable: true),
                    LastModifiedOnUtc = table.Column<DateTimeOffset>(type: "datetime", nullable: true),
                    LastModifiedBy = table.Column<string>(type: "longtext", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_locations", x => x.id);
                })
                .Annotation("MySQL:Charset", "utf8mb4");

            migrationBuilder.CreateTable(
                name: "outbox_messages",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "char(36)", nullable: false),
                    event_type = table.Column<string>(type: "varchar(255)", nullable: false),
                    content = table.Column<string>(type: "longtext", nullable: false),
                    occurred_on_utc = table.Column<DateTimeOffset>(type: "datetime", nullable: false),
                    processed_on_utc = table.Column<DateTimeOffset>(type: "datetime", nullable: true),
                    last_error_message = table.Column<string>(type: "longtext", nullable: true),
                    claimed_on_utc = table.Column<DateTimeOffset>(type: "datetime", nullable: true),
                    attempt_count = table.Column<int>(type: "int", nullable: false, defaultValue: 0),
                    max_attempts = table.Column<int>(type: "int", nullable: false, defaultValue: 3),
                    next_attempt_on_utc = table.Column<DateTimeOffset>(type: "datetime", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_outbox_messages", x => x.id);
                })
                .Annotation("MySQL:Charset", "utf8mb4");

            migrationBuilder.CreateTable(
                name: "inventory_items",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "char(36)", nullable: false),
                    quantity = table.Column<int>(type: "int", nullable: false),
                    reserved = table.Column<int>(type: "int", nullable: false),
                    location_id = table.Column<Guid>(type: "char(36)", nullable: false),
                    product_id = table.Column<Guid>(type: "char(50)", maxLength: 50, nullable: false),
                    product_name = table.Column<string>(type: "varchar(255)", maxLength: 255, nullable: false),
                    created_on_utc = table.Column<DateTimeOffset>(type: "datetime", nullable: false),
                    created_by = table.Column<string>(type: "varchar(50)", maxLength: 50, nullable: false),
                    last_modified_on_utc = table.Column<DateTimeOffset>(type: "datetime", nullable: true),
                    last_modified_by = table.Column<string>(type: "varchar(50)", maxLength: 50, nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_inventory_items", x => x.id);
                    table.ForeignKey(
                        name: "FK_inventory_items_locations_location_id",
                        column: x => x.location_id,
                        principalTable: "locations",
                        principalColumn: "id",
                        onDelete: ReferentialAction.Restrict);
                })
                .Annotation("MySQL:Charset", "utf8mb4");

            migrationBuilder.CreateTable(
                name: "inventory_reservations",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "char(36)", nullable: false),
                    reference_id = table.Column<Guid>(type: "char(36)", nullable: false),
                    quantity = table.Column<int>(type: "int", nullable: false),
                    expires_at = table.Column<DateTimeOffset>(type: "datetime", nullable: true),
                    status = table.Column<int>(type: "int", nullable: false),
                    location_id = table.Column<Guid>(type: "char(36)", nullable: false),
                    product_id = table.Column<Guid>(type: "char(50)", maxLength: 50, nullable: false),
                    product_name = table.Column<string>(type: "varchar(50)", maxLength: 50, nullable: false),
                    created_on_utc = table.Column<DateTimeOffset>(type: "datetime", nullable: false),
                    created_by = table.Column<string>(type: "varchar(50)", maxLength: 50, nullable: false),
                    last_modified_on_utc = table.Column<DateTimeOffset>(type: "datetime", nullable: true),
                    last_modified_by = table.Column<string>(type: "varchar(50)", maxLength: 50, nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_inventory_reservations", x => x.id);
                    table.ForeignKey(
                        name: "FK_inventory_reservations_locations_location_id",
                        column: x => x.location_id,
                        principalTable: "locations",
                        principalColumn: "id",
                        onDelete: ReferentialAction.Restrict);
                })
                .Annotation("MySQL:Charset", "utf8mb4");

            migrationBuilder.CreateIndex(
                name: "IX_inventory_items_location_id",
                table: "inventory_items",
                column: "location_id");

            migrationBuilder.CreateIndex(
                name: "IX_inventory_reservations_location_id",
                table: "inventory_reservations",
                column: "location_id");

            migrationBuilder.CreateIndex(
                name: "IX_inventory_reservations_reference_id",
                table: "inventory_reservations",
                column: "reference_id");

            migrationBuilder.CreateIndex(
                name: "IX_inventory_reservations_status_expires_at",
                table: "inventory_reservations",
                columns: new[] { "status", "expires_at" });

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_claimed_on_utc",
                table: "outbox_messages",
                column: "claimed_on_utc");

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_event_type",
                table: "outbox_messages",
                column: "event_type");

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_next_attempt_on_utc_processed_on_utc_attempt~",
                table: "outbox_messages",
                columns: new[] { "next_attempt_on_utc", "processed_on_utc", "attempt_count" });

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_occurred_on_utc",
                table: "outbox_messages",
                column: "occurred_on_utc");

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_processed_on_utc",
                table: "outbox_messages",
                column: "processed_on_utc");

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_processed_on_utc_attempt_count_max_attempts",
                table: "outbox_messages",
                columns: new[] { "processed_on_utc", "attempt_count", "max_attempts" });

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_processed_on_utc_claimed_on_utc",
                table: "outbox_messages",
                columns: new[] { "processed_on_utc", "claimed_on_utc" });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "inventory_histories");

            migrationBuilder.DropTable(
                name: "inventory_items");

            migrationBuilder.DropTable(
                name: "inventory_reservations");

            migrationBuilder.DropTable(
                name: "outbox_messages");

            migrationBuilder.DropTable(
                name: "locations");
        }
    }
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Migrations/20251218115210_init_database.Designer.cs">
// <auto-generated />
using System;
using System.Collections.Generic;
using Inventory.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace Inventory.Infrastructure.Data.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    [Migration("20251218115210_init_database")]
    partial class init_database
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.6")
                .HasAnnotation("Relational:MaxIdentifierLength", 64);

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryHistoryEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<string>("Message")
                        .IsRequired()
                        .HasColumnType("longtext")
                        .HasColumnName("message");

                    b.HasKey("Id");

                    b.ToTable("inventory_histories", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryItemEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<Guid>("LocationId")
                        .HasColumnType("char(36)")
                        .HasColumnName("location_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.Property<int>("Reserved")
                        .HasColumnType("int")
                        .HasColumnName("reserved");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Inventory.Domain.Entities.InventoryItemEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasMaxLength(50)
                                .HasColumnType("char(50)")
                                .HasColumnName("product_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("varchar(255)")
                                .HasColumnName("product_name");
                        });

                    b.HasKey("Id");

                    b.HasIndex("LocationId");

                    b.ToTable("inventory_items", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryReservationEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("created_on_utc");

                    b.Property<DateTimeOffset?>("ExpiresAt")
                        .HasColumnType("datetime")
                        .HasColumnName("expires_at");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<Guid>("LocationId")
                        .HasColumnType("char(36)")
                        .HasColumnName("location_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.Property<Guid>("ReferenceId")
                        .HasColumnType("char(36)")
                        .HasColumnName("reference_id");

                    b.Property<int>("Status")
                        .HasColumnType("int")
                        .HasColumnName("status");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Inventory.Domain.Entities.InventoryReservationEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasMaxLength(50)
                                .HasColumnType("char(50)")
                                .HasColumnName("product_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(50)
                                .HasColumnType("varchar(50)")
                                .HasColumnName("product_name");
                        });

                    b.HasKey("Id");

                    b.HasIndex("LocationId");

                    b.HasIndex("ReferenceId");

                    b.HasIndex("Status", "ExpiresAt");

                    b.ToTable("inventory_reservations", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.LocationEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("longtext");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("longtext");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime");

                    b.Property<string>("Location")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("varchar(255)")
                        .HasColumnName("location");

                    b.HasKey("Id");

                    b.ToTable("locations", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.OutboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<int>("AttemptCount")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(0)
                        .HasColumnName("attempt_count");

                    b.Property<DateTimeOffset?>("ClaimedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("claimed_on_utc");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("longtext")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("varchar(255)")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("longtext")
                        .HasColumnName("last_error_message");

                    b.Property<int>("MaxAttempts")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(3)
                        .HasColumnName("max_attempts");

                    b.Property<DateTimeOffset?>("NextAttemptOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("next_attempt_on_utc");

                    b.Property<DateTimeOffset>("OccurredOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("occurred_on_utc");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("processed_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("ClaimedOnUtc");

                    b.HasIndex("EventType");

                    b.HasIndex("OccurredOnUtc");

                    b.HasIndex("ProcessedOnUtc");

                    b.HasIndex("ProcessedOnUtc", "ClaimedOnUtc");

                    b.HasIndex("NextAttemptOnUtc", "ProcessedOnUtc", "AttemptCount");

                    b.HasIndex("ProcessedOnUtc", "AttemptCount", "MaxAttempts");

                    b.ToTable("outbox_messages", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryItemEntity", b =>
                {
                    b.HasOne("Inventory.Domain.Entities.LocationEntity", "Location")
                        .WithMany()
                        .HasForeignKey("LocationId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Location");
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryReservationEntity", b =>
                {
                    b.HasOne("Inventory.Domain.Entities.LocationEntity", "Location")
                        .WithMany()
                        .HasForeignKey("LocationId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Location");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Migrations/20251229085215_update_outbox_msg.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Inventory.Infrastructure.Data.Migrations
{
    /// <inheritdoc />
    public partial class update_outbox_msg : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropIndex(
                name: "IX_outbox_messages_claimed_on_utc",
                table: "outbox_messages");

            migrationBuilder.DropIndex(
                name: "IX_outbox_messages_processed_on_utc_claimed_on_utc",
                table: "outbox_messages");

            migrationBuilder.DropColumn(
                name: "claimed_on_utc",
                table: "outbox_messages");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<DateTimeOffset>(
                name: "claimed_on_utc",
                table: "outbox_messages",
                type: "datetime",
                nullable: true);

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_claimed_on_utc",
                table: "outbox_messages",
                column: "claimed_on_utc");

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_processed_on_utc_claimed_on_utc",
                table: "outbox_messages",
                columns: new[] { "processed_on_utc", "claimed_on_utc" });
        }
    }
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Migrations/20251229085215_update_outbox_msg.Designer.cs">
// <auto-generated />
using System;
using System.Collections.Generic;
using Inventory.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace Inventory.Infrastructure.Data.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    [Migration("20251229085215_update_outbox_msg")]
    partial class update_outbox_msg
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.6")
                .HasAnnotation("Relational:MaxIdentifierLength", 64);

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryHistoryEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<string>("Message")
                        .IsRequired()
                        .HasColumnType("longtext")
                        .HasColumnName("message");

                    b.HasKey("Id");

                    b.ToTable("inventory_histories", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryItemEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<Guid>("LocationId")
                        .HasColumnType("char(36)")
                        .HasColumnName("location_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.Property<int>("Reserved")
                        .HasColumnType("int")
                        .HasColumnName("reserved");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Inventory.Domain.Entities.InventoryItemEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasMaxLength(50)
                                .HasColumnType("char(50)")
                                .HasColumnName("product_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("varchar(255)")
                                .HasColumnName("product_name");
                        });

                    b.HasKey("Id");

                    b.HasIndex("LocationId");

                    b.ToTable("inventory_items", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryReservationEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("created_on_utc");

                    b.Property<DateTimeOffset?>("ExpiresAt")
                        .HasColumnType("datetime")
                        .HasColumnName("expires_at");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<Guid>("LocationId")
                        .HasColumnType("char(36)")
                        .HasColumnName("location_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.Property<Guid>("ReferenceId")
                        .HasColumnType("char(36)")
                        .HasColumnName("reference_id");

                    b.Property<int>("Status")
                        .HasColumnType("int")
                        .HasColumnName("status");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Inventory.Domain.Entities.InventoryReservationEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasMaxLength(50)
                                .HasColumnType("char(50)")
                                .HasColumnName("product_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(50)
                                .HasColumnType("varchar(50)")
                                .HasColumnName("product_name");
                        });

                    b.HasKey("Id");

                    b.HasIndex("LocationId");

                    b.HasIndex("ReferenceId");

                    b.HasIndex("Status", "ExpiresAt");

                    b.ToTable("inventory_reservations", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.LocationEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("longtext");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("longtext");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime");

                    b.Property<string>("Location")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("varchar(255)")
                        .HasColumnName("location");

                    b.HasKey("Id");

                    b.ToTable("locations", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.OutboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<int>("AttemptCount")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(0)
                        .HasColumnName("attempt_count");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("longtext")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("varchar(255)")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("longtext")
                        .HasColumnName("last_error_message");

                    b.Property<int>("MaxAttempts")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(3)
                        .HasColumnName("max_attempts");

                    b.Property<DateTimeOffset?>("NextAttemptOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("next_attempt_on_utc");

                    b.Property<DateTimeOffset>("OccurredOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("occurred_on_utc");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("processed_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("EventType");

                    b.HasIndex("OccurredOnUtc");

                    b.HasIndex("ProcessedOnUtc");

                    b.HasIndex("NextAttemptOnUtc", "ProcessedOnUtc", "AttemptCount");

                    b.HasIndex("ProcessedOnUtc", "AttemptCount", "MaxAttempts");

                    b.ToTable("outbox_messages", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryItemEntity", b =>
                {
                    b.HasOne("Inventory.Domain.Entities.LocationEntity", "Location")
                        .WithMany()
                        .HasForeignKey("LocationId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Location");
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryReservationEntity", b =>
                {
                    b.HasOne("Inventory.Domain.Entities.LocationEntity", "Location")
                        .WithMany()
                        .HasForeignKey("LocationId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Location");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Migrations/20260106132841_add_inbox.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Inventory.Infrastructure.Data.Migrations
{
    /// <inheritdoc />
    public partial class add_inbox : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "inbox_messages",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "char(36)", nullable: false),
                    event_type = table.Column<string>(type: "longtext", nullable: false),
                    content = table.Column<string>(type: "longtext", nullable: false),
                    received_on_utc = table.Column<DateTimeOffset>(type: "datetime", nullable: false),
                    processed_on_utc = table.Column<DateTimeOffset>(type: "datetime", nullable: true),
                    last_error_message = table.Column<string>(type: "longtext", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_inbox_messages", x => x.id);
                })
                .Annotation("MySQL:Charset", "utf8mb4");

            migrationBuilder.CreateIndex(
                name: "IX_inbox_messages_processed_on_utc",
                table: "inbox_messages",
                column: "processed_on_utc");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "inbox_messages");
        }
    }
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Migrations/20260106132841_add_inbox.Designer.cs">
// <auto-generated />
using System;
using System.Collections.Generic;
using Inventory.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace Inventory.Infrastructure.Data.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    [Migration("20260106132841_add_inbox")]
    partial class add_inbox
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.6")
                .HasAnnotation("Relational:MaxIdentifierLength", 64);

            modelBuilder.Entity("Inventory.Domain.Entities.InboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("longtext")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("longtext")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("longtext")
                        .HasColumnName("last_error_message");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("processed_on_utc");

                    b.Property<DateTimeOffset>("ReceivedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("received_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("ProcessedOnUtc");

                    b.ToTable("inbox_messages", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryHistoryEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<string>("Message")
                        .IsRequired()
                        .HasColumnType("longtext")
                        .HasColumnName("message");

                    b.HasKey("Id");

                    b.ToTable("inventory_histories", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryItemEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<Guid>("LocationId")
                        .HasColumnType("char(36)")
                        .HasColumnName("location_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.Property<int>("Reserved")
                        .HasColumnType("int")
                        .HasColumnName("reserved");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Inventory.Domain.Entities.InventoryItemEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasMaxLength(50)
                                .HasColumnType("char(50)")
                                .HasColumnName("product_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("varchar(255)")
                                .HasColumnName("product_name");
                        });

                    b.HasKey("Id");

                    b.HasIndex("LocationId");

                    b.ToTable("inventory_items", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryReservationEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("created_on_utc");

                    b.Property<DateTimeOffset?>("ExpiresAt")
                        .HasColumnType("datetime")
                        .HasColumnName("expires_at");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<Guid>("LocationId")
                        .HasColumnType("char(36)")
                        .HasColumnName("location_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.Property<Guid>("ReferenceId")
                        .HasColumnType("char(36)")
                        .HasColumnName("reference_id");

                    b.Property<int>("Status")
                        .HasColumnType("int")
                        .HasColumnName("status");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Inventory.Domain.Entities.InventoryReservationEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasMaxLength(50)
                                .HasColumnType("char(50)")
                                .HasColumnName("product_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(50)
                                .HasColumnType("varchar(50)")
                                .HasColumnName("product_name");
                        });

                    b.HasKey("Id");

                    b.HasIndex("LocationId");

                    b.HasIndex("ReferenceId");

                    b.HasIndex("Status", "ExpiresAt");

                    b.ToTable("inventory_reservations", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.LocationEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("longtext");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("longtext");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime");

                    b.Property<string>("Location")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("varchar(255)")
                        .HasColumnName("location");

                    b.HasKey("Id");

                    b.ToTable("locations", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.OutboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<int>("AttemptCount")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(0)
                        .HasColumnName("attempt_count");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("longtext")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("varchar(255)")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("longtext")
                        .HasColumnName("last_error_message");

                    b.Property<int>("MaxAttempts")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(3)
                        .HasColumnName("max_attempts");

                    b.Property<DateTimeOffset?>("NextAttemptOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("next_attempt_on_utc");

                    b.Property<DateTimeOffset>("OccurredOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("occurred_on_utc");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("processed_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("EventType");

                    b.HasIndex("OccurredOnUtc");

                    b.HasIndex("ProcessedOnUtc");

                    b.HasIndex("NextAttemptOnUtc", "ProcessedOnUtc", "AttemptCount");

                    b.HasIndex("ProcessedOnUtc", "AttemptCount", "MaxAttempts");

                    b.ToTable("outbox_messages", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryItemEntity", b =>
                {
                    b.HasOne("Inventory.Domain.Entities.LocationEntity", "Location")
                        .WithMany()
                        .HasForeignKey("LocationId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Location");
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryReservationEntity", b =>
                {
                    b.HasOne("Inventory.Domain.Entities.LocationEntity", "Location")
                        .WithMany()
                        .HasForeignKey("LocationId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Location");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/Migrations/ApplicationDbContextModelSnapshot.cs">
// <auto-generated />
using System;
using System.Collections.Generic;
using Inventory.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace Inventory.Infrastructure.Data.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    partial class ApplicationDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.6")
                .HasAnnotation("Relational:MaxIdentifierLength", 64);

            modelBuilder.Entity("Inventory.Domain.Entities.InboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("longtext")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("longtext")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("longtext")
                        .HasColumnName("last_error_message");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("processed_on_utc");

                    b.Property<DateTimeOffset>("ReceivedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("received_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("ProcessedOnUtc");

                    b.ToTable("inbox_messages", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryHistoryEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<string>("Message")
                        .IsRequired()
                        .HasColumnType("longtext")
                        .HasColumnName("message");

                    b.HasKey("Id");

                    b.ToTable("inventory_histories", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryItemEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<Guid>("LocationId")
                        .HasColumnType("char(36)")
                        .HasColumnName("location_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.Property<int>("Reserved")
                        .HasColumnType("int")
                        .HasColumnName("reserved");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Inventory.Domain.Entities.InventoryItemEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasMaxLength(50)
                                .HasColumnType("char(50)")
                                .HasColumnName("product_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("varchar(255)")
                                .HasColumnName("product_name");
                        });

                    b.HasKey("Id");

                    b.HasIndex("LocationId");

                    b.ToTable("inventory_items", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryReservationEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("created_on_utc");

                    b.Property<DateTimeOffset?>("ExpiresAt")
                        .HasColumnType("datetime")
                        .HasColumnName("expires_at");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("varchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<Guid>("LocationId")
                        .HasColumnType("char(36)")
                        .HasColumnName("location_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.Property<Guid>("ReferenceId")
                        .HasColumnType("char(36)")
                        .HasColumnName("reference_id");

                    b.Property<int>("Status")
                        .HasColumnType("int")
                        .HasColumnName("status");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Inventory.Domain.Entities.InventoryReservationEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasMaxLength(50)
                                .HasColumnType("char(50)")
                                .HasColumnName("product_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(50)
                                .HasColumnType("varchar(50)")
                                .HasColumnName("product_name");
                        });

                    b.HasKey("Id");

                    b.HasIndex("LocationId");

                    b.HasIndex("ReferenceId");

                    b.HasIndex("Status", "ExpiresAt");

                    b.ToTable("inventory_reservations", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.LocationEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("longtext");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetime");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("longtext");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetime");

                    b.Property<string>("Location")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("varchar(255)")
                        .HasColumnName("location");

                    b.HasKey("Id");

                    b.ToTable("locations", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.OutboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("char(36)")
                        .HasColumnName("id");

                    b.Property<int>("AttemptCount")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(0)
                        .HasColumnName("attempt_count");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("longtext")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("varchar(255)")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("longtext")
                        .HasColumnName("last_error_message");

                    b.Property<int>("MaxAttempts")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(3)
                        .HasColumnName("max_attempts");

                    b.Property<DateTimeOffset?>("NextAttemptOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("next_attempt_on_utc");

                    b.Property<DateTimeOffset>("OccurredOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("occurred_on_utc");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetime")
                        .HasColumnName("processed_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("EventType");

                    b.HasIndex("OccurredOnUtc");

                    b.HasIndex("ProcessedOnUtc");

                    b.HasIndex("NextAttemptOnUtc", "ProcessedOnUtc", "AttemptCount");

                    b.HasIndex("ProcessedOnUtc", "AttemptCount", "MaxAttempts");

                    b.ToTable("outbox_messages", (string)null);
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryItemEntity", b =>
                {
                    b.HasOne("Inventory.Domain.Entities.LocationEntity", "Location")
                        .WithMany()
                        .HasForeignKey("LocationId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Location");
                });

            modelBuilder.Entity("Inventory.Domain.Entities.InventoryReservationEntity", b =>
                {
                    b.HasOne("Inventory.Domain.Entities.LocationEntity", "Location")
                        .WithMany()
                        .HasForeignKey("LocationId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Location");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Data/ApplicationDbContext.cs">
#region using

using Microsoft.EntityFrameworkCore;
using System.Reflection;
using Inventory.Domain.Entities;

#endregion

namespace Inventory.Infrastructure.Data;

public sealed class ApplicationDbContext : DbContext
{
    #region Ctors

    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options) { }

    #endregion

    #region Implementations

    public DbSet<InventoryItemEntity> InventoryItems => Set<InventoryItemEntity>();

    public DbSet<InventoryReservationEntity> InventoryReservations => Set<InventoryReservationEntity>();

    public DbSet<InventoryHistoryEntity> InventoryHistories => Set<InventoryHistoryEntity>();

    public DbSet<LocationEntity> Locations => Set<LocationEntity>();

    public DbSet<OutboxMessageEntity> OutboxMessages => Set<OutboxMessageEntity>();

    public DbSet<InboxMessageEntity> InboxMessages => Set<InboxMessageEntity>();


    #endregion

    #region Override Methods

    protected override void OnModelCreating(ModelBuilder builder)
    {
        builder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());
        base.OnModelCreating(builder);
    }

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Exceptions/InfrastructureException.cs">
namespace Inventory.Infrastructure.Exceptions;

public sealed class InfrastructureException : Exception
{
    #region Ctors

    public InfrastructureException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/GrpcClients/Extensions/GrpcClientExtension.cs">
#region using

using Catalog.Grpc;
using Inventory.Infrastructure.GrpcClients.Interceptors;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

#endregion

namespace Inventory.Infrastructure.GrpcClients.Extensions;

public static class GrpcClientExtension
{
    #region Methods

    public static IServiceCollection AddGrpcClients(this IServiceCollection services, IConfiguration cfg)
    {
        var catalogServiceUrl = cfg.GetValue<string>($"{GrpcClientCfg.Catalog.Section}:{GrpcClientCfg.Catalog.Url}")
            ?? throw new InvalidOperationException("Catalog service URL is not configured.");
        services.AddGrpcClient<CatalogGrpc.CatalogGrpcClient>(options =>
        {
            options.Address = new Uri(catalogServiceUrl);
        })
        .AddInterceptor<GrpcApiKeyInterceptor>()
        .ConfigurePrimaryHttpMessageHandler(() =>
        {
            return new HttpClientHandler
            {
                ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
            };
        });

        services.AddSingleton<GrpcApiKeyInterceptor>();

        return services;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/GrpcClients/Interceptors/GrpcApiKeyInterceptor.cs">
#region using

using Grpc.Core;
using Grpc.Core.Interceptors;
using Microsoft.Extensions.Configuration;

#endregion

namespace Inventory.Infrastructure.GrpcClients.Interceptors;

public sealed class GrpcApiKeyInterceptor(IConfiguration cfg) : Interceptor
{
    #region Methods

    public override AsyncUnaryCall<TResponse> AsyncUnaryCall<TRequest, TResponse>(
        TRequest request,
        ClientInterceptorContext<TRequest, TResponse> context,
        AsyncUnaryCallContinuation<TRequest, TResponse> continuation)
    {
        var grpcKey = cfg.GetValue<string>($"{GrpcClientCfg.Catalog.Section}:{GrpcClientCfg.Catalog.ApiKey}")
            ?? throw new InvalidOperationException("gRPC Key is not configured.");
        var headers = context.Options.Headers ?? [];
        if (!headers.Any(h => h.Key.Equals(ReqHeaderName.GrpcKey, StringComparison.OrdinalIgnoreCase)))
        {
            headers.Add(ReqHeaderName.GrpcKey, grpcKey);
        }

        var newOptions = context.Options.WithHeaders(headers);
        var newContext = new ClientInterceptorContext<TRequest, TResponse>(
            context.Method,
            context.Host,
            newOptions);

        return base.AsyncUnaryCall(request, newContext, continuation);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Repositories/InboxMessageRepository.cs">
#region using

using Inventory.Domain.Entities;
using Inventory.Domain.Repositories;
using Inventory.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;

#endregion

namespace Inventory.Infrastructure.Repositories;

public class InboxMessageRepository(ApplicationDbContext context) : Repository<InboxMessageEntity>(context), IInboxMessageRepository
{
    #region Implementations

    public async Task<InboxMessageEntity?> GetByMessageIdAsync(Guid messageId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .FirstOrDefaultAsync(m => m.Id == messageId, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Repositories/InventoryHistoryRepository.cs">
#region using

using Inventory.Domain.Entities;
using Inventory.Domain.Repositories;
using Inventory.Infrastructure.Data;

#endregion

namespace Inventory.Infrastructure.Repositories;

public class InventoryHistoryRepository(ApplicationDbContext context) : Repository<InventoryHistoryEntity>(context), IInventoryHistoryRepository
{
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Repositories/InventoryItemRepository.cs">
#region using

using BuildingBlocks.Pagination.Extensions;
using Common.Models;
using Inventory.Domain.Entities;
using Inventory.Domain.Repositories;
using Inventory.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;
using System.Linq.Expressions;

#endregion

namespace Inventory.Infrastructure.Repositories;

public class InventoryItemRepository(ApplicationDbContext context) : Repository<InventoryItemEntity>(context), IInventoryItemRepository
{
    #region Implementations

    public async Task<List<InventoryItemEntity>> FindByProductWithRelationshipAsync(Guid productId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(x => x.Location)
            .Where(x => x.Product.Id == productId && x.Quantity > x.Reserved)
            .OrderByDescending(x => x.Quantity - x.Reserved)
            .ToListAsync(cancellationToken);
    }

    public async Task<List<InventoryItemEntity>> GetAllWithRelationshipAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(x => x.Location)
            .OrderByDescending(x => x.CreatedOnUtc)
            .ToListAsync(cancellationToken);
    }

    public async Task<List<InventoryItemEntity>> SearchWithRelationshipAsync(Expression<Func<InventoryItemEntity, bool>> predicate,
        PaginationRequest pagination,
        CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(x => x.Location)
            .Where(predicate)
            .OrderByDescending(x => x.CreatedOnUtc)
            .WithPaging(pagination)
            .ToListAsync(cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Repositories/InventoryReservationRepository.cs">
#region using

using Inventory.Domain.Entities;
using Inventory.Domain.Repositories;
using Inventory.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;

#endregion

namespace Inventory.Infrastructure.Repositories;

public class InventoryReservationRepository(ApplicationDbContext context) : Repository<InventoryReservationEntity>(context), IInventoryReservationRepository
{
    #region Implementations

    public async Task<InventoryReservationEntity?> GetByOrderAndProductAsync(
        Guid orderId,
        Guid productId,
        CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .FirstOrDefaultAsync(r =>
                    r.ReferenceId == orderId && r.Product.Id == productId,
                cancellationToken);
    }

    public async Task<List<InventoryReservationEntity>> GetAllWithRelationshipAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(x => x.Location)
            .OrderByDescending(x => x.CreatedOnUtc)
            .ToListAsync(cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Repositories/LocationRepository.cs">
#region using

using Inventory.Domain.Entities;
using Inventory.Domain.Repositories;
using Inventory.Infrastructure.Data;

#endregion

namespace Inventory.Infrastructure.Repositories;

public class LocationRepository(ApplicationDbContext context) : Repository<LocationEntity>(context), ILocationRepository
{
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Repositories/OutboxMessageRepository.cs">
#region using

using Inventory.Domain.Entities;
using Inventory.Domain.Repositories;
using Inventory.Infrastructure.Data;

#endregion

namespace Inventory.Infrastructure.Repositories;

public class OutboxMessageRepository(ApplicationDbContext context) : Repository<OutboxMessageEntity>(context), IOutboxMessageRepository
{
    #region Implementations

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Repositories/Repository.cs">
#region using

using Inventory.Domain.Repositories;
using Inventory.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;
using System.Linq.Expressions;

#endregion

namespace Inventory.Infrastructure.Repositories;

public class Repository<T>(ApplicationDbContext context) : IRepository<T> where T : class
{
    #region Fields

    protected readonly ApplicationDbContext _context = context;

    protected readonly DbSet<T> _dbSet = context.Set<T>();

    #endregion

    #region Implementations

    public virtual async Task<T?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _dbSet.FindAsync([id], cancellationToken);
    }

    public virtual async Task<T?> FirstOrDefaultAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .FirstOrDefaultAsync(predicate, cancellationToken);
    }

    public virtual async Task<T?> SingleOrDefaultAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .SingleOrDefaultAsync(predicate, cancellationToken);
    }

    public virtual async Task<IReadOnlyList<T>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .ToListAsync(cancellationToken);
    }

    public virtual async Task<IReadOnlyList<T>> FindAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(predicate)
            .ToListAsync(cancellationToken);
    }

    public virtual async Task<long> CountAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(predicate)
            .CountAsync(cancellationToken);
    }

    public virtual async Task<long> CountAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .CountAsync(cancellationToken);
    }

    public virtual async Task<bool> AnyAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .AnyAsync(predicate, cancellationToken);
    }

    public virtual async Task AddAsync(T entity, CancellationToken cancellationToken = default)
    {
        await _dbSet.AddAsync(entity, cancellationToken);
    }

    public virtual async Task AddRangeAsync(IEnumerable<T> entities, CancellationToken cancellationToken = default)
    {
        await _dbSet.AddRangeAsync(entities, cancellationToken);
    }

    public virtual void Update(T entity)
    {
        _dbSet.Update(entity);
    }

    public virtual void UpdateRange(IEnumerable<T> entities)
    {
        _dbSet.UpdateRange(entities);
    }

    public virtual void Remove(T entity)
    {
        _dbSet.Remove(entity);
    }

    public virtual void RemoveRange(IEnumerable<T> entities)
    {
        _dbSet.RemoveRange(entities);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Services/CatalogApiService.cs">
#region using

using Inventory.Application.Services;
using Inventory.Infrastructure.ApiClients;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Refit;
using Inventory.Application.Models.Responses.Externals;
using Common.Models.Reponses;

#endregion

namespace Inventory.Infrastructure.Services;

public sealed class CatalogApiService : ICatalogApiService
{
    #region Fields, Properties and Indexers

    private readonly IKeycloakApi _keycloakApi;

    private readonly ICatalogApi _catalogApi;

    private readonly ILogger<CatalogApiService> _logger;

    private readonly string _realm;

    private readonly string _clientId;

    private readonly string _clientSecret;

    private readonly string _grantType;

    private readonly string[] _scopes;

    #endregion

    #region Ctors

    public CatalogApiService(
        IKeycloakApi keycloakApi,
        ICatalogApi catalogApi,
        ILogger<CatalogApiService> logger,
        IConfiguration cfg)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _catalogApi = catalogApi ?? throw new ArgumentNullException(nameof(catalogApi));
        _keycloakApi = keycloakApi ?? throw new ArgumentNullException(nameof(keycloakApi));
        _realm = cfg[$"{ApiClientCfg.Keycloak.Section}:{ApiClientCfg.Keycloak.Realm}"]!;
        _clientId = cfg[$"{ApiClientCfg.Keycloak.Section}:{ApiClientCfg.Keycloak.ClientId}"]!;
        _clientSecret = cfg[$"{ApiClientCfg.Keycloak.Section}:{ApiClientCfg.Keycloak.ClientSecret}"]!;
        _grantType = cfg[$"{ApiClientCfg.Keycloak.Section}:{ApiClientCfg.Keycloak.GrantType}"]!;
        _scopes = cfg.GetRequiredSection($"{ApiClientCfg.Keycloak.Section}:{ApiClientCfg.Keycloak.Scopes}")
            .Get<string[]>() ?? throw new ArgumentNullException($"{ApiClientCfg.Keycloak.Section}:{ApiClientCfg.Keycloak.Scopes}");
    }

    #endregion

    #region Implementations

    public async Task<ApiGetResponse<GetProductByIdReponse>?> GetProductByIdAsync(string productId)
    {
        try
        {
            var tokenResponse = await GetAccessTokenAsync();
            var response = await _catalogApi.GetProductByIdAsync(productId, $"Bearer {tokenResponse.AccessToken}");
            return response;
        }
        catch (ApiException ex)
        {
            _logger.LogWarning(ex, "Error calling Catalog API for productId: {ProductId}", productId);
            return null;
        }
    }

    #endregion

    #region Methods

    private async Task<KeycloakAccessTokenResponse> GetAccessTokenAsync()
    {
        var form = new Dictionary<string, string>
        {
            { "client_id", _clientId },
            { "client_secret", _clientSecret },
            { "grant_type", _grantType },
            { "scope", string.Join(" ", _scopes!) }
        };

        return await _keycloakApi.GetAccessTokenAsync(_realm, form);
    }

    #endregion

}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Services/CatalogGrpcService.cs">
#region using

using Catalog.Grpc;
using Inventory.Application.Models.Responses.Externals;
using Inventory.Application.Models.Responses.Internals;
using Inventory.Application.Services;
using Microsoft.Extensions.Logging;

#endregion

namespace Inventory.Infrastructure.Services;

public sealed class CatalogGrpcService(CatalogGrpc.CatalogGrpcClient grpcClient, ILogger<CatalogGrpcService> logger) : ICatalogGrpcService
{
    public async Task<GetProductByIdReponse?> GetProductByIdAsync(string productId, CancellationToken cancellationToken = default)
    {
        try
        {
            var result = await grpcClient.GetProductByIdAsync(
                new GetProductByIdRequest { Id = productId },
                cancellationToken: cancellationToken);

            var product = result.Product;

            return new GetProductByIdReponse()
            {
                Product = new ProductReponse
                {
                    Id = Guid.Parse(product.Id),
                    Price = (decimal)product.Price,
                    Name = product.Name,
                    ThumbnailUrl = product.Thumbnail
                }
            };
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex, "Failed to get product by ID {ProductId} from Catalog Grpc service", productId);
            return null;
        }
    }

    public async Task<GetAllProductsResponse?> GetProductsAsync(string[]? ids = null, string searchText = "", CancellationToken cancellationToken = default)
    {
        try
        {
            var request = new GetProductsRequest { SearchText = searchText };
            if (ids is not null && ids.Length > 0)
                request.Ids.AddRange(ids);

            var result = await grpcClient.GetProductsAsync(request, cancellationToken: cancellationToken);

            var response = new GetAllProductsResponse
            {
                Items = result.Products
                    .Select(p => new ProductReponse
                    {
                        Id = Guid.Parse(p.Id),
                        Name = p.Name,
                        Price = (decimal)p.Price,
                        ThumbnailUrl = p.Thumbnail
                    })
                    .ToList()
            };

            return response;
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex, "Failed to get products from Catalog Grpc service");
            return null;
        }
    }
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/UnitOfWork/DbTransactionAdapter.cs">
#region using

using Microsoft.EntityFrameworkCore.Storage;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Infrastructure.UnitOfWork;

internal class DbTransactionAdapter(IDbContextTransaction transaction) : IDbTransaction
{
    #region Implementations


    public async Task CommitAsync(CancellationToken cancellationToken = default)
    {
        await transaction.CommitAsync(cancellationToken);
    }


    public async Task RollbackAsync(CancellationToken cancellationToken = default)
    {
        await transaction.RollbackAsync(cancellationToken);
    }


    public void Dispose()
    {
        transaction.Dispose();
    }


    public async ValueTask DisposeAsync()
    {
        await transaction.DisposeAsync();
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/UnitOfWork/UnitOfWork.cs">
#region using

using Inventory.Domain.Abstractions;
using Inventory.Domain.Repositories;
using Inventory.Infrastructure.Data;

#endregion

namespace Inventory.Infrastructure.UnitOfWork;

public class UnitOfWork(
    IInventoryReservationRepository inventoryReservations,
    IInventoryItemRepository inventoryItems,
    IInventoryHistoryRepository inventoryHistories,
    ILocationRepository locations,
    IInboxMessageRepository inboxMessages,
    IOutboxMessageRepository outboxMessages,
    ApplicationDbContext context) : IUnitOfWork
{
    public IInventoryReservationRepository InventoryReservations { get; } = inventoryReservations;
    public IInventoryItemRepository InventoryItems { get; } = inventoryItems;
    public IInventoryHistoryRepository InventoryHistories { get; } = inventoryHistories;
    public ILocationRepository Locations { get; } = locations;
    public IInboxMessageRepository InboxMessages { get; } = inboxMessages;
    public IOutboxMessageRepository OutboxMessages { get; } = outboxMessages;

    public Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
        => context.SaveChangesAsync(cancellationToken);

    public async Task<IDbTransaction> BeginTransactionAsync(CancellationToken cancellationToken = default)
    {
        var tx = await context.Database.BeginTransactionAsync(cancellationToken);
        return new DbTransactionAdapter(tx);
    }
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/DependencyInjection.cs">
#region using

using Inventory.Infrastructure.Data;
using Inventory.Infrastructure.Data.Extensions;
using Inventory.Infrastructure.Data.Interceptors;
using Microsoft.AspNetCore.Builder;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Inventory.Infrastructure.ApiClients.Extensions;
using Inventory.Infrastructure.GrpcClients.Extensions;

#endregion

namespace Inventory.Infrastructure;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddInfrastructureServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Service")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithScopedLifetime());

        // DbContext
        {
            var dbType = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DbType}"];
            services.AddScoped<ISaveChangesInterceptor, AuditableEntityInterceptor>();
            services.AddScoped<ISaveChangesInterceptor, DispatchDomainEventsInterceptor>();
            services.AddDbContext<ApplicationDbContext>((sp, options) =>
            {
                var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];
                options.AddInterceptors(sp.GetServices<ISaveChangesInterceptor>());

                switch (dbType)
                {
                    case DatabaseType.SqlServer:
                        options.UseSqlServer(conn);
                        break;
                    case DatabaseType.MySql:
                        options.UseMySQL(conn!);
                        break;
                    case DatabaseType.PostgreSql:
                        options.UseNpgsql(conn);
                        break;
                    default:
                        throw new Exception("Unsupported database type");
                }
            });
        }

        // Repository & Unit of Work
        {
            services.Scan(s => s
                .FromAssemblyOf<InfrastructureMarker>()
                .AddClasses(c => c.Where(t => t.Name.EndsWith("Repository")))
                .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
                .AsImplementedInterfaces()
                .WithScopedLifetime());

            services.AddScoped<Domain.Abstractions.IUnitOfWork, UnitOfWork.UnitOfWork>();
        }

        services.AddRefitClients(cfg);
        services.AddGrpcClients(cfg);

        return services;
    }

    public static WebApplication UseInfrastructure(this WebApplication app)
    {
        app.InitialiseDatabaseAsync().GetAwaiter().GetResult();

        return app;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/GlobalUsing.cs">
global using Common.Configurations;
global using Common.Constants;
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/InfrastructureMarker.cs">
namespace Inventory.Infrastructure;

public sealed class InfrastructureMarker { }
</file>

<file path="Services/Inventory/Core/Inventory.Infrastructure/Inventory.Infrastructure.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <Protobuf Include="..\..\..\..\Shared\Contracts\Catalog.Contract\Protos\catalog.proto" GrpcServices="Client" />
  </ItemGroup>
  
  <ItemGroup>
    <PackageReference Include="Aspire.Npgsql.EntityFrameworkCore.PostgreSQL" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="MySql.EntityFrameworkCore" />
    <PackageReference Include="Polly" />
    <PackageReference Include="Polly.Extensions.Http" />
    <PackageReference Include="Refit.HttpClientFactory" />
    <PackageReference Include="Scrutor" />
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="Google.Protobuf" />
    <PackageReference Include="Grpc.Net.Client" />
    <PackageReference Include="Grpc.Tools">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Inventory.Application\Inventory.Application.csproj" />
  </ItemGroup>
  
  <ItemGroup>
    <Folder Include="Data\Migrations\" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Consumer/BackgroundServices/InventoryBackgroudService.cs">
namespace Inventory.Worker.Consumer.BackgroundServices;

internal class InventoryBackgroudService(ILogger<InventoryBackgroudService> logger) : BackgroundService
{
    #region Methods

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        logger.LogInformation("Worker starting at: {time}", DateTimeOffset.Now);

        while (!stoppingToken.IsCancellationRequested)
        {
            await Task.Delay(1000, stoppingToken);
        }

        logger.LogInformation("Worker stoping at: {time}", DateTimeOffset.Now);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Consumer/EventHandlers/Integrations/OrderCancelledIntegrationEventHandler.cs">
#region using

using Common.ValueObjects;
using Common.Constants;
using EventSourcing.Events.Orders;
using Inventory.Application.Features.InventoryReservation.Commands;
using Inventory.Domain.Entities;
using MassTransit;
using MediatR;
using System.Text.Json;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Worker.Consumer.EventHandlers.Integrations;

public sealed class OrderCancelledIntegrationEventHandler(
    ISender sender,
    IUnitOfWork unitOfWork,
    ILogger<OrderCancelledIntegrationEventHandler> logger)
    : IConsumer<OrderCancelledIntegrationEvent>
{
    #region Methods

    public async Task Consume(ConsumeContext<OrderCancelledIntegrationEvent> context)
    {
        var message = context.Message;
        var messageId = context.MessageId ?? Guid.NewGuid();

        // Check if message already exists in inbox (idempotency)
        var existingMessage = await unitOfWork.InboxMessages
            .GetByMessageIdAsync(messageId, context.CancellationToken);

        if (existingMessage != null)
        {
            logger.LogInformation("Message {MessageId} already processed. Skipping.", messageId);
            return;
        }

        var inboxMessage = InboxMessageEntity.Create(
            messageId,
            message.GetType().AssemblyQualifiedName!,
            JsonSerializer.Serialize(message),
            DateTimeOffset.UtcNow);

        await unitOfWork.InboxMessages.AddAsync(inboxMessage, context.CancellationToken);
        await unitOfWork.SaveChangesAsync(context.CancellationToken);

        logger.LogInformation("Processing integration event {EventType} with ID {MessageId}",
            message.GetType().Name, messageId);

        try
        {
            var releaseCommand = new ReleaseReservationCommand(
                message.OrderId,
                message.Reason!,
                Actor.Consumer(AppConstants.Service.Order));

            await sender.Send(releaseCommand, context.CancellationToken);

            logger.LogInformation(
                "Successfully released reservations for cancelled order {OrderNo} (ID: {OrderId}). Reason: {Reason}",
                message.OrderNo, message.OrderId, message.Reason);

            inboxMessage.CompleteProcessing(DateTimeOffset.UtcNow);
            await unitOfWork.SaveChangesAsync(context.CancellationToken);
        }
        catch (Exception ex)
        {
            logger.LogError(ex,
                "Failed to release reservations for cancelled order {OrderNo} (ID: {OrderId})",
                message.OrderNo, message.OrderId);

            inboxMessage.CompleteProcessing(DateTimeOffset.UtcNow, ex.Message);
            await unitOfWork.SaveChangesAsync(context.CancellationToken);

            throw;
        }
    }

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Consumer/EventHandlers/Integrations/OrderCreatedIntegrationEventHandler.cs">
#region using

using Common.ValueObjects;
using Common.Configurations;
using Common.Constants;
using EventSourcing.Events.Orders;
using Inventory.Application.Features.InventoryReservation.Commands;
using Inventory.Application.Dtos.InventoryReservations;
using Inventory.Application.Services;
using Inventory.Domain.Entities;
using MassTransit;
using MediatR;
using System.Text.Json;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Worker.Consumer.EventHandlers.Integrations;

public sealed class OrderCreatedIntegrationEventHandler(
    ISender sender,
    IUnitOfWork unitOfWork,
    ILogger<OrderCreatedIntegrationEventHandler> logger,
    ICatalogGrpcService catalogGrpc,
    IConfiguration configuration)
    : IConsumer<OrderCreatedIntegrationEvent>
{
    #region Methods

    public async Task Consume(ConsumeContext<OrderCreatedIntegrationEvent> context)
    {
        var message = context.Message;
        var messageId = Guid.Parse(message.Id);

        // Use execution strategy for retry logic
        await using var transaction = await unitOfWork.BeginTransactionAsync(context.CancellationToken);

        try
        {
            // Check if message already exists in inbox (idempotency)
            var existingMessage = await unitOfWork.InboxMessages
                .GetByMessageIdAsync(messageId, context.CancellationToken);

            if (existingMessage != null)
            {
                logger.LogInformation("Message {MessageId} already processed. Skipping.", messageId);
                await transaction.RollbackAsync(context.CancellationToken);
                return;
            }

            // Create inbox record to track this event
            var inboxMessage = InboxMessageEntity.Create(
                messageId,
                message.GetType().AssemblyQualifiedName!,
                JsonSerializer.Serialize(message),
                DateTimeOffset.UtcNow);

            await unitOfWork.InboxMessages.AddAsync(inboxMessage, context.CancellationToken);
            await unitOfWork.SaveChangesAsync(context.CancellationToken);

            // Commit transaction to lock this message ID
            await transaction.CommitAsync(context.CancellationToken);

            logger.LogInformation(
                "Processing integration event: {IntegrationEvent}, EventId: {EventId}, IntegrationEventId: {IntegrationEventId}, OrderId: {OrderId}, OrderNo: {OrderNo}",
                context.Message.GetType().Name,
                context.MessageId,
                message.Id,
                message.OrderId,
                message.OrderNo);

            try
            {
                // Get product information from Catalog service
                var productIds = message.OrderItems.Select(i => i.ProductId.ToString()).ToArray();
                var products = await catalogGrpc.GetProductsAsync(ids: productIds, cancellationToken: context.CancellationToken)
                    ?? throw new Exception("Products not found");

                // Reserve inventory for each order item
                foreach (var orderItem in message.OrderItems)
                {
                    var product = products.Items!.FirstOrDefault(p => p.Id == orderItem.ProductId)
                        ?? throw new Exception($"ProductId {orderItem.ProductId} not found");

                    // Check if reservation already exists for this ReferenceId + ProductId
                    var existingReservation = await unitOfWork.InventoryReservations
                        .GetByOrderAndProductAsync(message.OrderId, product.Id, context.CancellationToken);

                    if (existingReservation != null)
                    {
                        logger.LogInformation(
                            "Reservation already exists for OrderId {OrderId}, ProductId {ProductId}. Skipping this item.",
                            message.OrderId, product.Id);
                        continue; // Skip this item, process next
                    }

                    var expirationMinutes = configuration.GetValue<int>($"{AppConfigCfg.Section}:{AppConfigCfg.ReservationExpirationMinutes}");

                    var reservationDto = new CreateReservationDto
                    {
                        ProductId = product.Id,
                        ProductName = product.Name,
                        ReferenceId = message.OrderId,
                        Quantity = orderItem.Quantity,
                        ExpiresAt = DateTimeOffset.UtcNow.AddMinutes(expirationMinutes)
                    };

                    // ReserveInventoryCommand will automatically find the inventory item with the highest quantity
                    var reserveCommand = new ReserveInventoryCommand(reservationDto, Actor.Consumer(AppConstants.Service.Inventory));
                    await sender.Send(reserveCommand, context.CancellationToken);

                    logger.LogInformation(
                        "Reserved {Quantity} units of product {ProductId} ({ProductName}) for order {OrderId}",
                        orderItem.Quantity, orderItem.ProductId, product.Name, message.OrderId);
                }

                logger.LogInformation("Successfully reserved inventory for all items in order {OrderId}", message.OrderId);

                // Mark as successfully processed
                inboxMessage.CompleteProcessing(DateTimeOffset.UtcNow);
                await unitOfWork.SaveChangesAsync(context.CancellationToken);
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "Unexpected error while reserving inventory for order {OrderId}", message.OrderId);

                // Mark as failed
                inboxMessage.CompleteProcessing(DateTimeOffset.UtcNow, ex.Message);
                await unitOfWork.SaveChangesAsync(context.CancellationToken);

                // TODO: Publish InventoryReservationFailedIntegrationEvent
                // This should trigger order creation failure notification to user

                throw;
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error processing message {MessageId}", messageId);
            await transaction.RollbackAsync(context.CancellationToken);
            throw;
        }
    }

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Consumer/EventHandlers/Integrations/OrderDeliveredIntegrationEventHandler.cs">
#region using

using Common.ValueObjects;
using Common.Constants;
using EventSourcing.Events.Orders;
using Inventory.Application.Features.InventoryReservation.Commands;
using Inventory.Domain.Entities;
using MassTransit;
using MediatR;
using System.Text.Json;
using Inventory.Domain.Abstractions;

#endregion

namespace Inventory.Worker.Consumer.EventHandlers.Integrations;

public sealed class OrderDeliveredIntegrationEventHandler(
    ISender sender,
    IUnitOfWork unitOfWork,
    ILogger<OrderDeliveredIntegrationEventHandler> logger)
    : IConsumer<OrderDeliveredIntegrationEvent>
{
    #region Methods

    public async Task Consume(ConsumeContext<OrderDeliveredIntegrationEvent> context)
    {
        var message = context.Message;
        var messageId = context.MessageId ?? Guid.NewGuid();

        // Check if message already exists in inbox (idempotency)
        var existingMessage = await unitOfWork.InboxMessages
            .GetByMessageIdAsync(messageId, context.CancellationToken);

        if (existingMessage != null)
        {
            logger.LogInformation("Message {MessageId} already processed. Skipping.", messageId);
            return;
        }

        var inboxMessage = InboxMessageEntity.Create(
            messageId,
            message.GetType().AssemblyQualifiedName!,
            JsonSerializer.Serialize(message),
            DateTimeOffset.UtcNow);

        await unitOfWork.InboxMessages.AddAsync(inboxMessage, context.CancellationToken);
        await unitOfWork.SaveChangesAsync(context.CancellationToken);

        logger.LogInformation("Processing integration event {EventType} with ID {MessageId}",
            message.GetType().Name, messageId);

        try
        {
            var commitCommand = new CommitReservationCommand(
                message.OrderId,
                Actor.Consumer(AppConstants.Service.Order));

            await sender.Send(commitCommand, context.CancellationToken);

            logger.LogInformation(
                "Successfully committed inventory reservations for delivered order {OrderNo} (ID: {OrderId})",
                message.OrderNo, message.OrderId);

            foreach (var item in message.OrderItems)
            {
                logger.LogInformation(
                    "Committed {Quantity} units of product {ProductId} ({ProductName}) for order {OrderNo}",
                    item.Quantity, item.ProductId, item.ProductName, message.OrderNo);
            }

            inboxMessage.CompleteProcessing(DateTimeOffset.UtcNow);
            await unitOfWork.SaveChangesAsync(context.CancellationToken);
        }
        catch (Exception ex)
        {
            logger.LogError(ex,
                "Failed to commit reservations for delivered order {OrderNo} (ID: {OrderId})",
                message.OrderNo, message.OrderId);

            inboxMessage.CompleteProcessing(DateTimeOffset.UtcNow, ex.Message);
            await unitOfWork.SaveChangesAsync(context.CancellationToken);

            throw;
        }
    }

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Consumer/DependencyInjection.cs">
#region using

using BuildingBlocks.Logging;
using EventSourcing.MassTransit;
using System.Reflection;

#endregion

namespace Inventory.Worker.Consumer;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddWorkerServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddSerilogLogging(cfg);
        services.AddMessageBroker(cfg, Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Consumer/Inventory.Worker.Consumer.csproj">
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Inventory.Application\Inventory.Application.csproj" />
    <ProjectReference Include="..\..\Core\Inventory.Infrastructure\Inventory.Infrastructure.csproj" />
  </ItemGroup>
  
</Project>
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Consumer/Program.cs">
#region using

using Inventory.Application;
using Inventory.Infrastructure;
using Inventory.Worker.Consumer;
using Inventory.Worker.Consumer.BackgroundServices;

#endregion

var builder = Host.CreateApplicationBuilder(args);

builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddWorkerServices(builder.Configuration)
    .AddHostedService<InventoryBackgroudService>();

var host = builder.Build();
host.Run();
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Outbox/Abstractions/IDatabaseProvider.cs">
#region using

using Inventory.Worker.Outbox.Models;
using Inventory.Worker.Outbox.Structs;

#endregion

namespace Inventory.Worker.Outbox.Abstractions;

public interface IDatabaseProvider
{
    #region Methods

    Task<List<OutboxMessage>> GetUnprocessedMessagesAsync(string connectionString, int batchSize, CancellationToken cancellationToken = default);

    Task UpdateProcessedMessagesAsync(string connectionString, IEnumerable<OutboxUpdate> updates, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Outbox/BackgroundServices/OutboxBackgroundService.cs">
#region using

using Common.Configurations;
using Inventory.Worker.Outbox.Processors;


#endregion

namespace Inventory.Worker.Outbox.BackgroundServices;

internal class OutboxBackgroundService : BackgroundService
{
    #region Fields, Properties and Indexers

    private readonly int _processorFrequency;

    private readonly int _maxParallelism;

    private int _totalIterations = 0;

    private int _totalProcessedMessage = 0;

    private readonly IServiceScopeFactory _serviceScopeFactory;

    private readonly ILogger<OutboxBackgroundService> _logger;

    #endregion

    #region Ctors

    public OutboxBackgroundService(
        IServiceScopeFactory serviceScopeFactory,
        IConfiguration cfg,
        ILogger<OutboxBackgroundService> logger)
    {
        _processorFrequency = cfg.GetValue<int>($"{WorkerCfg.Outbox.Section}:{WorkerCfg.Outbox.ProcessorFrequency}", 5);
        _maxParallelism = cfg.GetValue<int>($"{WorkerCfg.Outbox.Section}:{WorkerCfg.Outbox.MaxParallelism}", 5);
        _serviceScopeFactory = serviceScopeFactory;
        _logger = logger;
    }

    #endregion

    #region Methods

    protected override async Task ExecuteAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Outbox processor started");

        var parallelOptions = new ParallelOptions
        {
            MaxDegreeOfParallelism = _maxParallelism,
            CancellationToken = cancellationToken
        };

        try
        {
            await Parallel.ForEachAsync(
                Enumerable.Range(0, _maxParallelism),
                parallelOptions,
                async (_, token) =>
                {
                    await ProcessOutboxMessages(token);
                });
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Outbox processor operation cancelled");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred while processing outbox messages");
        }
    }

    private async Task ProcessOutboxMessages(CancellationToken cancellationToken)
    {
        using var scope = _serviceScopeFactory.CreateScope();
        var outboxProcessor = scope.ServiceProvider.GetRequiredService<OutboxProcessor>();

        while (true)
        {
            int processedMessages = await outboxProcessor.ExecuteAsync(cancellationToken);
            var totalProcessedMessages = Interlocked.Add(ref _totalProcessedMessage, processedMessages);

            // Only log if there were messages processed or every 100 iterations
            var iterationCount = Interlocked.Increment(ref _totalIterations);
            if (processedMessages > 0 || iterationCount % 100 == 0)
            {
                _logger.LogInformation("Iteration {IterationCount}: Processed {ProcessedMessages} messages. Total: {TotalProcessedMessages}",
                    iterationCount, processedMessages, totalProcessedMessages);
            }

            await Task.Delay(TimeSpan.FromSeconds(_processorFrequency), cancellationToken);
        }
    }

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Outbox/Factories/DatabaseProviderFactory.cs">
#region using

using Common.Constants;
using Inventory.Worker.Outbox.Abstractions;
using Inventory.Worker.Outbox.Providers;

#endregion

namespace Inventory.Worker.Outbox.Factories;

public static class DatabaseProviderFactory
{
    #region Methods

    public static IDatabaseProvider CreateProvider(string dbType)
    {
        return dbType.ToUpperInvariant() switch
        {
            DatabaseType.MySql => new MySqlDatabaseProvider(),
            DatabaseType.PostgreSql => new PostgreSqlDatabaseProvider(),
            DatabaseType.SqlServer => new SqlServerDatabaseProvider(),
            _ => throw new NotSupportedException($"Unsupported database type: {dbType}. Supported types: {DatabaseType.MySql}, {DatabaseType.PostgreSql}, {DatabaseType.SqlServer}")
        };
    }

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Outbox/Models/OutboxMessage.cs">
namespace Inventory.Worker.Outbox.Models;

public sealed record OutboxMessage
{
    #region Fields, Properties and Indexers

    public Guid Id { get; init; }

    public string Type { get; init; } = default!;

    public string Content { get; init; } = default!;

    public int AttemptCount { get; init; }

    public int MaxAttempts { get; init; }

    public DateTimeOffset? NextAttemptOnUtc { get; init; }

    public string? LastErrorMessage { get; init; }

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Outbox/Processors/OutboxProcessor.cs">
#region using

using Common.Configurations;
using Inventory.Worker.Outbox.Abstractions;
using Inventory.Worker.Outbox.Factories;
using Inventory.Worker.Outbox.Structs;
using MassTransit;
using System.Collections.Concurrent;
using System.Text.Json;

#endregion

namespace Inventory.Worker.Outbox.Processors;

internal sealed class OutboxProcessor
{
    #region Fields, Properties and Indexers

    private readonly int _batchSize;

    private readonly string _connectionString;

    private readonly IDatabaseProvider _databaseProvider;

    private static readonly ConcurrentDictionary<string, Type> TypeCache = new();

    private readonly IPublishEndpoint _publish;

    private readonly ILogger<OutboxProcessor> _logger;

    #endregion

    #region Ctors

    public OutboxProcessor(
        IConfiguration cfg,
        IPublishEndpoint publish,
        ILogger<OutboxProcessor> logger)
    {
        _connectionString = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"]!;
        _batchSize = cfg.GetValue<int>($"{WorkerCfg.Outbox.Section}:{WorkerCfg.Outbox.BatchSize}", 1000);
        _databaseProvider = DatabaseProviderFactory.CreateProvider(cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DbType}"]!);
        _publish = publish;
        _logger = logger;
    }

    #endregion

    #region Methods

    public async Task<int> ExecuteAsync(CancellationToken cancellationToken = default)
    {
        var messages = await _databaseProvider.GetUnprocessedMessagesAsync(_connectionString, _batchSize, cancellationToken);

        if (messages.Count == 0)
            return 0;

        var updateQueue = new ConcurrentQueue<OutboxUpdate>();

        var publishTasks = messages
            .Select(message => PublishMessageAsync(message, updateQueue, cancellationToken))
            .ToList();

        await Task.WhenAll(publishTasks);

        if (!updateQueue.IsEmpty)
        {
            await _databaseProvider.UpdateProcessedMessagesAsync(_connectionString, updateQueue, cancellationToken);
        }

        return messages.Count;
    }

    private async Task PublishMessageAsync(
        Models.OutboxMessage message,
        ConcurrentQueue<OutboxUpdate> updateQueue,
        CancellationToken cancellationToken)
    {
        try
        {
            var messageType = GetOrAddMessageType(message.Type);
            var deserializedMessage = JsonSerializer.Deserialize(message.Content, messageType)!;

            await _publish.Publish(deserializedMessage, cancellationToken);

            updateQueue.Enqueue(new OutboxUpdate(
                message.Id,
                DateTimeOffset.UtcNow,
                null,
                message.AttemptCount + 1,
                null));
        }
        catch (Exception ex)
        {
            var currentTime = DateTimeOffset.UtcNow;
            var attemptCount = message.AttemptCount + 1;

            if (attemptCount >= message.MaxAttempts)
            {
                updateQueue.Enqueue(new OutboxUpdate(
                    message.Id,
                    currentTime,
                    $"Max attempts ({message.MaxAttempts}) exceeded. Last error: {ex}",
                    attemptCount,
                    null));

                _logger.LogError(ex, "Permanently failed to publish outbox message {Id} after {AttemptCount} attempts",
                    message.Id, attemptCount);
            }
            else
            {
                var baseDelay = TimeSpan.FromSeconds(Math.Pow(2, attemptCount - 1));
                var maxDelay = TimeSpan.FromMinutes(5);
                var jitter = TimeSpan.FromMilliseconds(Random.Shared.Next(0, 1000));
                var delay = TimeSpan.FromTicks(Math.Min(baseDelay.Ticks, maxDelay.Ticks)) + jitter;
                var nextAttemptOnUtc = currentTime + delay;

                updateQueue.Enqueue(new OutboxUpdate(
                    message.Id,
                    currentTime,
                    ex.ToString(),
                    attemptCount,
                    nextAttemptOnUtc));

                _logger.LogWarning(ex, "Failed to publish outbox message {Id} (attempt {AttemptCount}/{MaxAttempts}), will retry at {NextAttemptOnUtc}",
                    message.Id, attemptCount, message.MaxAttempts, nextAttemptOnUtc);
            }
        }
    }

    private static Type GetOrAddMessageType(string typename)
    {
        return TypeCache.GetOrAdd(typename, name => Type.GetType(name)!);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Outbox/Providers/MySqlDatabaseProvider.cs">
#region using

using Dapper;
using Inventory.Worker.Outbox.Abstractions;
using Inventory.Worker.Outbox.Models;
using Inventory.Worker.Outbox.Structs;
using MySql.Data.MySqlClient;

#endregion

namespace Inventory.Worker.Outbox.Providers;

public sealed class MySqlDatabaseProvider : IDatabaseProvider
{
    #region Implementations

    public async Task<List<OutboxMessage>> GetUnprocessedMessagesAsync(
        string connectionString,
        int batchSize,
        CancellationToken cancellationToken = default)
    {
        await using var connection = new MySqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var transaction = await connection.BeginTransactionAsync(cancellationToken);

        var messages = await connection.QueryAsync<OutboxMessage>(
            """
            SELECT 
                id AS Id,
                event_type AS Type,
                content AS Content,
                attempt_count AS AttemptCount,
                max_attempts AS MaxAttempts,
                next_attempt_on_utc AS NextAttemptOnUtc,
                last_error_message AS LastErrorMessage
            FROM outbox_messages 
            WHERE processed_on_utc IS NULL 
              AND attempt_count < max_attempts
              AND (next_attempt_on_utc IS NULL OR next_attempt_on_utc <= @CurrentTime)
            ORDER BY occurred_on_utc
            LIMIT @BatchSize
            FOR UPDATE SKIP LOCKED
            """,
            new { BatchSize = batchSize, CurrentTime = DateTimeOffset.UtcNow },
            transaction: transaction);

        await transaction.CommitAsync(cancellationToken);

        return messages.AsList();
    }

    public async Task UpdateProcessedMessagesAsync(
        string connectionString,
        IEnumerable<OutboxUpdate> updates,
        CancellationToken cancellationToken = default)
    {
        var updatesList = updates.ToList();
        if (!updatesList.Any())
            return;

        await using var connection = new MySqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var transaction = await connection.BeginTransactionAsync(cancellationToken);

        var updateSql =
            """
            UPDATE outbox_messages
            SET processed_on_utc = CASE 
                {0}
            END,
            last_error_message = CASE 
                {1}
            END,
            attempt_count = CASE 
                {2}
            END,
            next_attempt_on_utc = CASE 
                {3}
            END
            WHERE id IN ({4})
            """;

        var whenThenProcessed = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @ProcessedOn{i}"));
        var whenThenError = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @Error{i}"));
        var whenThenAttemptCount = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @AttemptCount{i}"));
        var whenThenNextAttempt = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @NextAttempt{i}"));
        var ids = string.Join(",", updatesList.Select((_, i) => $"@Id{i}"));

        var parameters = new DynamicParameters();

        for (int i = 0; i < updatesList.Count; i++)
        {
            parameters.Add($"Id{i}", updatesList[i].Id);
            parameters.Add($"ProcessedOn{i}", updatesList[i].ProcessedOnUtc);
            parameters.Add($"Error{i}", updatesList[i].LastErrorMessage);
            parameters.Add($"AttemptCount{i}", updatesList[i].AttemptCount);
            parameters.Add($"NextAttempt{i}", updatesList[i].NextAttemptOnUtc);
        }

        var formattedSql = string.Format(updateSql, whenThenProcessed, whenThenError, whenThenAttemptCount, whenThenNextAttempt, ids);

        await connection.ExecuteAsync(formattedSql, parameters, transaction: transaction);
        await transaction.CommitAsync(cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Outbox/Providers/PostgreSqlDatabaseProvider.cs">
#region using

using Dapper;
using Inventory.Worker.Outbox.Abstractions;
using Inventory.Worker.Outbox.Models;
using Inventory.Worker.Outbox.Structs;
using Npgsql;

#endregion

namespace Inventory.Worker.Outbox.Providers;

public sealed class PostgreSqlDatabaseProvider : IDatabaseProvider
{
    #region Implementations

    public async Task<List<OutboxMessage>> GetUnprocessedMessagesAsync(
        string connectionString,
        int batchSize,
        CancellationToken cancellationToken = default)
    {
        await using var connection = new NpgsqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var transaction = await connection.BeginTransactionAsync(cancellationToken);

        var messages = await connection.QueryAsync<OutboxMessage>(
            """
            SELECT 
                id AS Id,
                event_type AS Type,
                content AS Content,
                attempt_count AS AttemptCount,
                max_attempts AS MaxAttempts,
                next_attempt_on_utc AS NextAttemptOnUtc,
                last_error_message AS LastErrorMessage
            FROM outbox_messages 
            WHERE processed_on_utc IS NULL 
              AND attempt_count < max_attempts
              AND (next_attempt_on_utc IS NULL OR next_attempt_on_utc <= @CurrentTime)
            ORDER BY occurred_on_utc
            LIMIT @BatchSize
            FOR UPDATE SKIP LOCKED
            """,
            new { BatchSize = batchSize, CurrentTime = DateTimeOffset.UtcNow },
            transaction: transaction);

        await transaction.CommitAsync(cancellationToken);

        return messages.AsList();
    }

    public async Task UpdateProcessedMessagesAsync(
        string connectionString,
        IEnumerable<OutboxUpdate> updates,
        CancellationToken cancellationToken = default)
    {
        var updatesList = updates.ToList();
        if (!updatesList.Any())
            return;

        await using var connection = new NpgsqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var transaction = await connection.BeginTransactionAsync(cancellationToken);

        var updateSql =
            """
            UPDATE outbox_messages
            SET processed_on_utc = v.processed_on_utc,
                last_error_message = v.error,
                attempt_count = v.attempt_count,
                next_attempt_on_utc = v.next_attempt_on_utc
            FROM (VALUES
                {0}
            ) AS v(id, processed_on_utc, error, attempt_count, next_attempt_on_utc)
            WHERE outbox_messages.id = v.id::uuid
            """;

        var valuesList = string.Join(",",
            updatesList.Select((_, i) => $"(@Id{i}, @ProcessedOn{i}, @Error{i}, @AttemptCount{i}, @NextAttempt{i})"));

        var parameters = new DynamicParameters();

        for (int i = 0; i < updatesList.Count; i++)
        {
            parameters.Add($"Id{i}", updatesList[i].Id.ToString());
            parameters.Add($"ProcessedOn{i}", updatesList[i].ProcessedOnUtc);
            parameters.Add($"Error{i}", updatesList[i].LastErrorMessage);
            parameters.Add($"AttemptCount{i}", updatesList[i].AttemptCount);
            parameters.Add($"NextAttempt{i}", updatesList[i].NextAttemptOnUtc);
        }

        var formattedSql = string.Format(updateSql, valuesList);

        await connection.ExecuteAsync(formattedSql, parameters, transaction: transaction);
        await transaction.CommitAsync(cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Outbox/Providers/SqlServerDatabaseProvider.cs">
#region using

using Dapper;
using Inventory.Worker.Outbox.Abstractions;
using Inventory.Worker.Outbox.Models;
using Inventory.Worker.Outbox.Structs;
using Microsoft.Data.SqlClient;

#endregion

namespace Inventory.Worker.Outbox.Providers;

public sealed class SqlServerDatabaseProvider : IDatabaseProvider
{
    #region Implementations

    public async Task<List<OutboxMessage>> GetUnprocessedMessagesAsync(
        string connectionString,
        int batchSize,
        CancellationToken cancellationToken = default)
    {
        await using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var transaction = await connection.BeginTransactionAsync(cancellationToken);

        var messages = await connection.QueryAsync<OutboxMessage>(
            """
            SELECT TOP(@BatchSize)
                id AS Id,
                event_type AS Type,
                content AS Content,
                attempt_count AS AttemptCount,
                max_attempts AS MaxAttempts,
                next_attempt_on_utc AS NextAttemptOnUtc,
                last_error_message AS LastErrorMessage
            FROM outbox_messages WITH (READPAST, ROWLOCK)
            WHERE processed_on_utc IS NULL 
              AND attempt_count < max_attempts
              AND (next_attempt_on_utc IS NULL OR next_attempt_on_utc <= @CurrentTime)
            ORDER BY occurred_on_utc
            """,
            new { BatchSize = batchSize, CurrentTime = DateTimeOffset.UtcNow },
            transaction: transaction);

        await transaction.CommitAsync(cancellationToken);

        return messages.AsList();
    }

    public async Task UpdateProcessedMessagesAsync(
        string connectionString,
        IEnumerable<OutboxUpdate> updates,
        CancellationToken cancellationToken = default)
    {
        var updatesList = updates.ToList();
        if (!updatesList.Any())
            return;

        await using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var transaction = await connection.BeginTransactionAsync(cancellationToken);

        var updateSql =
            """
            UPDATE outbox_messages
            SET processed_on_utc = CASE 
                {0}
            END,
            last_error_message = CASE 
                {1}
            END,
            attempt_count = CASE 
                {2}
            END,
            next_attempt_on_utc = CASE 
                {3}
            END
            WHERE id IN ({4})
            """;

        var whenThenProcessed = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @ProcessedOn{i}"));
        var whenThenError = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @Error{i}"));
        var whenThenAttemptCount = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @AttemptCount{i}"));
        var whenThenNextAttempt = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @NextAttempt{i}"));
        var ids = string.Join(",", updatesList.Select((_, i) => $"@Id{i}"));

        var parameters = new DynamicParameters();

        for (int i = 0; i < updatesList.Count; i++)
        {
            parameters.Add($"Id{i}", updatesList[i].Id);
            parameters.Add($"ProcessedOn{i}", updatesList[i].ProcessedOnUtc);
            parameters.Add($"Error{i}", updatesList[i].LastErrorMessage);
            parameters.Add($"AttemptCount{i}", updatesList[i].AttemptCount);
            parameters.Add($"NextAttempt{i}", updatesList[i].NextAttemptOnUtc);
        }

        var formattedSql = string.Format(updateSql, whenThenProcessed, whenThenError, whenThenAttemptCount, whenThenNextAttempt, ids);

        await connection.ExecuteAsync(formattedSql, parameters, transaction: transaction);
        await transaction.CommitAsync(cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Outbox/Structs/OutboxUpdate.cs">
namespace Inventory.Worker.Outbox.Structs;

public record struct OutboxUpdate(
    Guid Id,
    DateTimeOffset ProcessedOnUtc,
    string? LastErrorMessage,
    int AttemptCount,
    DateTimeOffset? NextAttemptOnUtc);
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Outbox/DependencyInjection.cs">
#region using

using BuildingBlocks.Logging;
using EventSourcing.MassTransit;
using Inventory.Worker.Outbox.Processors;
using System.Reflection;

#endregion

namespace Inventory.Worker.Outbox;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddWorkerServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddSerilogLogging(cfg);
        services.AddMessageBroker(cfg, Assembly.GetExecutingAssembly());
        services.AddScoped<OutboxProcessor>();

        return services;
    }

    #endregion
}
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Outbox/Inventory.Worker.Outbox.csproj">
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <PropertyGroup>
    <UserSecretsId>dotnet-Worker-7f7483a9-e5da-45da-b9d6-631ff820055e</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Dapper" />
    <PackageReference Include="Microsoft.Data.SqlClient" />
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="MySql.Data" />
    <PackageReference Include="Npgsql" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Inventory.Domain\Inventory.Domain.csproj" />
    <ProjectReference Include="..\..\Core\Inventory.Infrastructure\Inventory.Infrastructure.csproj" />
  </ItemGroup>
</Project>
</file>

<file path="Services/Inventory/Worker/Inventory.Worker.Outbox/Program.cs">
#region using

using Inventory.Application;
using Inventory.Infrastructure;
using Inventory.Worker.Outbox;
using Inventory.Worker.Outbox.BackgroundServices;

#endregion

var builder = Host.CreateApplicationBuilder(args);

builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddWorkerServices(builder.Configuration)
    .AddHostedService<OutboxBackgroundService>();

var host = builder.Build();

host.Run();
</file>

<file path="Services/Notification/Api/Notification.Api/Constants/ApiRoutes.cs">
namespace Notification.Api.Constants;

public sealed class ApiRoutes
{
    public static class Notification
    {
        #region Constants

        public const string Tags = "Notifications";

        private const string Base = "/notifications";

        public const string MarkAsRead = $"{Base}/read";

        public const string GetNotifications = Base;

        public const string GetAllNotifications = $"{Base}/all";

        public const string GetCountUnread = $"{Base}/unread/count";

        public const string GetTop10Unread = $"{Base}/unread/top10";

        #endregion
    }
}
</file>

<file path="Services/Notification/Api/Notification.Api/Endpoints/GetAllNotifications.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Notification.Api.Constants;
using Notification.Application.Features.Notification.Queries;
using Notification.Application.Models.Results;

#endregion

namespace Notification.Api.Endpoints;

public sealed class GetAllNotifications : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Notification.GetAllNotifications, HandleGetAllNotificationsAsync)
            .WithTags(ApiRoutes.Notification.Tags)
            .WithName(nameof(GetAllNotifications))
            .Produces<ApiGetResponse<GetAllNotificationsResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetAllNotificationsResult>> HandleGetAllNotificationsAsync(
        ISender sender,
        IHttpContextAccessor httpContext)
    {
        var currentUser = httpContext.GetCurrentUser();
        var query = new GetAllNotificationsQuery(Actor.User(currentUser.Id));
        var result = await sender.Send(query);

        return new ApiGetResponse<GetAllNotificationsResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Notification/Api/Notification.Api/Endpoints/GetCountNotificationUnread.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Notification.Api.Constants;
using Notification.Application.Features.Notification.Queries;
using Notification.Application.Models.Results;

#endregion

namespace Notification.Api.Endpoints;

public sealed class GetCountNotificationUnread : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Notification.GetCountUnread, HandleGetCountNotificationUnreadAsync)
            .WithTags(ApiRoutes.Notification.Tags)
            .WithName(nameof(GetCountNotificationUnread))
            .Produces<ApiGetResponse<GetCountNotificationUnreadResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetCountNotificationUnreadResult>> HandleGetCountNotificationUnreadAsync(
        ISender sender,
        IHttpContextAccessor httpContext)
    {
        var currentUser = httpContext.GetCurrentUser();
        var query = new GetCountNotificationUnreadQuery(Actor.User(currentUser.Id));
        var result = await sender.Send(query);

        return new ApiGetResponse<GetCountNotificationUnreadResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Notification/Api/Notification.Api/Endpoints/GetNotifications.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Notification.Api.Constants;
using Notification.Application.Features.Notification.Queries;
using Notification.Application.Models.Results;
using Common.Models;

#endregion

namespace Notification.Api.Endpoints;

public sealed class GetNotifications : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Notification.GetNotifications, HandleGetNotificationsAsync)
            .WithTags(ApiRoutes.Notification.Tags)
            .WithName(nameof(GetNotifications))
            .Produces<ApiGetResponse<GetNotificationsResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetNotificationsResult>> HandleGetNotificationsAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [AsParameters] PaginationRequest paging)
    {
        var currentUser = httpContext.GetCurrentUser();
        var query = new GetNotificationsQuery(Actor.User(currentUser.Id), paging);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetNotificationsResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Notification/Api/Notification.Api/Endpoints/GetTop10NotificationsUnread.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Notification.Api.Constants;
using Notification.Application.Features.Notification.Queries;
using Notification.Application.Models.Results;

#endregion

namespace Notification.Api.Endpoints;

public sealed class GetTop10NotificationsUnread : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Notification.GetTop10Unread, HandleGetTop10NotificationsUnreadAsync)
            .WithTags(ApiRoutes.Notification.Tags)
            .WithName(nameof(GetTop10NotificationsUnread))
            .Produces<ApiGetResponse<GetTop10NotificationsUnreadResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetTop10NotificationsUnreadResult>> HandleGetTop10NotificationsUnreadAsync(
        ISender sender,
        IHttpContextAccessor httpContext)
    {
        var currentUser = httpContext.GetCurrentUser();
        var query = new GetTop10NotificationsUnreadQuery(Actor.User(currentUser.Id));
        var result = await sender.Send(query);

        return new ApiGetResponse<GetTop10NotificationsUnreadResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Notification/Api/Notification.Api/Endpoints/MarkAsRead.cs">
#region using

using Microsoft.AspNetCore.Mvc;
using Notification.Api.Constants;
using Notification.Application.Features.Notification.Commands;
using BuildingBlocks.Authentication.Extensions;
using Notification.Application.Dtos.Notifications;

#endregion

namespace Notification.Api.Endpoints;

public sealed class MarkAsRead : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Notification.MarkAsRead, HandleMarkAsReadAsync)
            .WithTags(ApiRoutes.Notification.Tags)
            .WithName(nameof(MarkAsRead))
            .Produces<ApiUpdatedResponse<Unit>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<Unit>> HandleMarkAsReadAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromBody] MarkAsReadNotificationDto req)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new MarkAsReadNotificationCommand(req, Actor.User(currentUser.Id));
        var result = await sender.Send(command);

        return new ApiUpdatedResponse<Unit>(result);
    }

    #endregion
}
</file>

<file path="Services/Notification/Api/Notification.Api/DependencyInjection.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using BuildingBlocks.Swagger.Extensions;
using Common.Configurations;
using Common.Constants;
using HealthChecks.UI.Client;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;

#endregion

namespace Notification.Api;

public static class DependencyInjection
{
    public static IServiceCollection AddApiServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services.AddCarter();

        var dbype = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DbType}"];
        var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];
        var dbName = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DatabaseName}"];

        switch (dbype)
        {
            case DatabaseType.SqlServer:
                services.AddHealthChecks()
                    .AddSqlServer(connectionString: conn!);
                break;
            case DatabaseType.MySql:
                services.AddHealthChecks()
                    .AddMySql(connectionString: conn!);
                break;
            case DatabaseType.PostgreSql:
                services.AddHealthChecks()
                    .AddNpgSql(connectionString: conn!);
                break;
            case DatabaseType.MongoDb:
                services.AddHealthChecks()
                    .AddMongoDb(
                        clientFactory: sp => new MongoDB.Driver.MongoClient(conn!),
                        databaseNameFactory: sp => dbName!);
                break;
            default:
                throw new Exception("Unsupported database type");
        }

        services.AddHttpContextAccessor();
        services.AddAuthenticationAndAuthorization(cfg);
        services.AddSwaggerServices(cfg);

        return services;
    }

    public static WebApplication UseApi(this WebApplication app)
    {
        app.UseSerilogReqLogging();
        app.UsePrometheusEndpoint();
        app.MapCarter();
        app.UseExceptionHandler(options => { });
        app.UseHealthChecks("/health",
            new HealthCheckOptions
            {
                ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
            });

        app.UseAuthentication();
        app.UseAuthorization();
        app.UseSwaggerApi();

        app.MapGet("/", (IWebHostEnvironment env) => new ApiDefaultPathResponse
        {
            Service = "Notification.Api",
            Status = "Running",
            Timestamp = DateTimeOffset.UtcNow,
            Environment = env.EnvironmentName,
            Endpoints = new Dictionary<string, string>
            {
                { "health", "/health" }
            },
            Message = "API is running..."
        });

        return app;
    }
}
</file>

<file path="Services/Notification/Api/Notification.Api/GlobalUsing.cs">
global using Carter;
global using MediatR;
global using Common.ValueObjects;
global using Common.Models.Reponses;
</file>

<file path="Services/Notification/Api/Notification.Api/Notification.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <UserSecretsId>68beccec-977d-4711-a7f7-5d8d06e5c2e0</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="AspNetCore.HealthChecks.MongoDb" />
    <PackageReference Include="AspNetCore.HealthChecks.MySql" />
    <PackageReference Include="AspNetCore.HealthChecks.NpgSql" />
    <PackageReference Include="AspNetCore.HealthChecks.Redis" />
    <PackageReference Include="AspNetCore.HealthChecks.SqlServer" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" />
    <PackageReference Include="Carter" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Notification.Application\Notification.Application.csproj" />
    <ProjectReference Include="..\..\Core\Notification.Infrastructure\Notification.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Notification/Api/Notification.Api/Program.cs">
#region using

using Notification.Api;
using Notification.Application;
using Notification.Infrastructure;

#endregion

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddApiServices(builder.Configuration);

var app = builder.Build();

// Configure the HTTP request pipeline.
app.UseApi();
app.UseInfrastructure();

app.Run();
</file>

<file path="Services/Notification/Core/Notification.Application/Constants/TemplateKey.cs">
namespace Notification.Application.Constants;

public sealed class TemplateKey
{
    #region Constants

    public const string OrderPaid = "ORDER_PAID";

    public const string ProductUpserted = "PRODUCT_UPSERTED";

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Constants/TemplateVariables.cs">
namespace Notification.Application.Constants;

public sealed class TemplateVariables
{
    #region Constants

    public const string DisplayName = "DISPLAY_NAME";

    public const string ProductName = "PRODUCT_NAME";

    public const string PerformBy = "PERFORM_BY";

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Data/Repositories/ICommandDeliveryRepository.cs">
#region using

using Notification.Domain.Entities;

#endregion

namespace Notification.Application.Data.Repositories;

public interface ICommandDeliveryRepository
{
    #region Methods

    Task InsertManyAsync(IEnumerable<DeliveryEntity> docs, CancellationToken cancellationToken = default);

    Task UpsertAsync(DeliveryEntity doc, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Data/Repositories/ICommandNotificationRepository.cs">
#region using

using Notification.Domain.Entities;

#endregion

namespace Notification.Application.Data.Repositories;

public interface ICommandNotificationRepository
{
    #region Methods

    Task UpsertAsync(NotificationEntity doc, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Data/Repositories/IQueryDeliveryRepository.cs">
#region using

using Notification.Domain.Entities;

#endregion

namespace Notification.Application.Data.Repositories;

public interface IQueryDeliveryRepository
{
    #region Methods

    Task<IReadOnlyList<DeliveryEntity>> GetDueAsync(DateTimeOffset now, int batchSize, CancellationToken cancellationToken = default);

    Task<DeliveryEntity?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    Task<DeliveryEntity> GetByEventIdAsync(string eventId, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Data/Repositories/IQueryNotificationRepository.cs">
#region using

using Notification.Domain.Entities;

#endregion

namespace Notification.Application.Data.Repositories;

public interface IQueryNotificationRepository
{
    #region Methods

    Task<List<NotificationEntity>> GetNotificationsAsync(Guid userId, CancellationToken cancellationToken = default);

    Task<NotificationEntity> GetNotificationByIdAsync(Guid id, Guid userId, CancellationToken cancellationToken = default);

    Task<List<NotificationEntity>> GetAllNotificationsAsync(Guid userId, CancellationToken cancellationToken = default);

    Task<long> GetCountNotificationUnreadAsync(Guid userId, CancellationToken cancellationToken = default);

    Task<List<NotificationEntity>> GetTop10NotificationsUnreadAsync(Guid userId, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Data/Repositories/IQueryTemplateRepository.cs">
#region using

using Notification.Domain.Entities;
using Notification.Domain.Enums;

#endregion

namespace Notification.Application.Data.Repositories;

public interface IQueryTemplateRepository
{
    #region Methods

    Task<TemplateEntity> GetAsync(string key, ChannelType channel, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Dtos/Abstractions/AuditableDto.cs">
#region using

#endregion

namespace Notification.Application.Dtos.Abstractions;

public abstract class AuditableDto : IAuditableDto
{
    #region Fields, Properties and Indexers

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}

public interface IAuditableDto : ICreationAuditDto, IModificationAuditDto { }
</file>

<file path="Services/Notification/Core/Notification.Application/Dtos/Abstractions/DtoId.cs">
namespace Notification.Application.Dtos.Abstractions;

public class DtoId<T> : IDtoId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    #endregion
}

public interface IDtoId<T>
{
    T Id { get; init; }
}
</file>

<file path="Services/Notification/Core/Notification.Application/Dtos/Abstractions/EntityDto.cs">
namespace Notification.Application.Dtos.Abstractions;

public abstract class EntityDto<T> : IDtoId<T>, IAuditableDto
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Dtos/Abstractions/ICreationAuditDto.cs">
namespace Notification.Application.Dtos.Abstractions;

public interface ICreationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Dtos/Abstractions/IModificationAuditDto.cs">
namespace Notification.Application.Dtos.Abstractions;

public interface IModificationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Notification/Core/Notification.Application/Dtos/Deliveries/CreateDeliveryDto.cs">
#region using

using Notification.Domain.Enums;

#endregion

namespace Notification.Application.Dtos.Deliveries;

public sealed class CreateDeliveryDto
{
    #region Fields, Properties and Indexers

    public string EventId { get; set; } = string.Empty;

    public string TemplateKey { get; set; } = string.Empty;

    public ChannelType ChannelType { get; set; }

    public List<string> To { get; set; } = [];

    public Dictionary<string, object>? TemplateVariables { get; set; }

    public DeliveryPriority Priority { get; set; } = DeliveryPriority.Medium;

    public List<string>? Cc { get; set; }

    public List<string>? Bcc { get; set; }

    public int MaxAttempts { get; set; } = AppConstants.MaxAttempts;

    public string? TargetUrl { get; set; }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Dtos/Keycloaks/KeycloakAccessTokenDto.cs">
namespace Notification.Application.Dtos.Keycloaks;

public sealed class KeycloakAccessTokenDto
{
    #region Fields, Properties and Indexers

    public string AccessToken { get; set; } = default!;

    public int ExpiresIn { get; set; }

    public int RefreshExpiresIn { get; set; }

    public string? TokenType { get; set; }

    public string? IdToken { get; set; }

    public int NotBeforePolicy { get; set; }

    public string? Scope { get; set; }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Dtos/Keycloaks/KeycloakUserDto.cs">
namespace Notification.Application.Dtos.Keycloaks;

public class KeycloakUserDto
{
    #region Fields, Properties and Indexers

    public string Id { get; set; } = default!;

    public long CreatedTimestamp { get; set; }

    public string? Username { get; set; }

    public bool Enabled { get; set; }

    public bool Totp { get; set; }

    public bool EmailVerified { get; set; }

    public string? FirstName { get; set; }

    public string? LastName { get; set; }

    public string? Email { get; set; }

    public int NotBefore { get; set; }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Dtos/Notifications/MarkAsReadNotificationDto.cs">
namespace Notification.Application.Dtos.Notifications;

public sealed class MarkAsReadNotificationDto
{
    #region Fields, Properties and Indexers

    public List<Guid> Ids { get; set; } = default!;

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Dtos/Notifications/NotificationDto.cs">
#region using

using Notification.Application.Dtos.Abstractions;

#endregion

namespace Notification.Application.Dtos.Notifications;

public class NotificationDto : EntityDto<Guid>
{
    #region Fields, Properties and Indexers

    public string? Title { get; set; }

    public string? Message { get; set; }

    public bool IsRead { get; set; }

    public DateTimeOffset? ReadAt { get; set; }

    public string? TargetUrl { get; set; }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Exceptions/ApplicationException.cs">
namespace Notification.Application.Exceptions;

public sealed class ApplicationException : Exception
{
    #region Ctors

    public ApplicationException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Features/Delivery/Commands/CreateDeliveryCommand.cs">
#region using

using Notification.Application.Dtos.Deliveries;
using Notification.Application.Data.Repositories;
using Notification.Application.Providers;
using Notification.Domain.Entities;
using Microsoft.Extensions.Logging;

#endregion

namespace Notification.Application.Features.Delivery.Commands;

public sealed record CreateDeliveryCommand(CreateDeliveryDto Dto, Actor Actor) : ICommand<Guid>;

public sealed class CreateDeliveryCommandValidator : AbstractValidator<CreateDeliveryCommand>
{
    #region Ctors

    public CreateDeliveryCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.EventId)
                    .NotEmpty()
                    .WithMessage(MessageCode.EventIdIsRequired);

                RuleFor(x => x.Dto.TemplateKey)
                    .NotEmpty()
                    .WithMessage(MessageCode.TemplateKeyIsRequired);

                RuleFor(x => x.Dto.To)
                    .NotEmpty()
                    .WithMessage(MessageCode.ToRecipientsIsRequired)
                    .Must(to => to != null && to.Count > 0)
                    .WithMessage(MessageCode.AtLeastOneRecipientIsRequired);

                RuleFor(x => x.Dto.MaxAttempts)
                    .GreaterThan(0)
                    .WithMessage(MessageCode.MaxAttemptsMustBeGreaterThanZero);
            });
    }

    #endregion
}

public sealed class CreateDeliveryCommandHandler(
    IQueryTemplateRepository templateRepo,
    IQueryDeliveryRepository deliveryQueryRepo,
    ICommandDeliveryRepository deliveryCommandRepo,
    ITemplateProvider templateProvider,
    ILogger<CreateDeliveryCommandHandler> logger)
    : ICommandHandler<CreateDeliveryCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(CreateDeliveryCommand command, CancellationToken cancellationToken)
    {
        var dto = command.Dto;

        // Check if delivery already exists for this event
        var existing = await deliveryQueryRepo.GetByEventIdAsync(dto.EventId, cancellationToken);
        if (existing != null)
        {
            logger.LogWarning("Delivery already exists for EventId: {EventId}", dto.EventId);
            return existing.Id;
        }

        // Get template
        var template = await templateRepo.GetAsync(
            key: dto.TemplateKey,
            channel: dto.ChannelType,
            cancellationToken: cancellationToken);

        if (template == null) throw new NotFoundException(MessageCode.TemplateNotFound);

        // Render template body with data
        var templateVariables = dto.TemplateVariables ?? new Dictionary<string, object>();
        var renderedBody = templateProvider.Render(template.Body!, templateVariables);

        // Create delivery entity
        var deliveryId = Guid.NewGuid();
        var delivery = DeliveryEntity.Create(
            id: deliveryId,
            channel: dto.ChannelType,
            to: dto.To,
            subject: template.Subject!,
            isHtml: template.IsHtml,
            body: renderedBody,
            priority: dto.Priority,
            eventId: dto.EventId,
            performedBy: command.Actor.ToString(),
            maxAttempts: dto.MaxAttempts,
            targetUrl: dto.TargetUrl,
            cc: dto.Cc,
            bcc: dto.Bcc);

        // Save delivery
        await deliveryCommandRepo.UpsertAsync(delivery, cancellationToken);

        logger.LogInformation("Delivery created with Id: {DeliveryId} for EventId: {EventId}", deliveryId, dto.EventId);

        return deliveryId;
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Features/Delivery/Commands/ProcessDeliveryCommand.cs">
#region using

using Notification.Application.Data.Repositories;
using Notification.Application.Models;
using Notification.Domain.Enums;
using Microsoft.Extensions.Logging;
using Notification.Application.Strategy;

#endregion

namespace Notification.Application.Features.Delivery.Commands;

public sealed record ProcessDeliveryCommand(Guid DeliveryId, Actor Actor) : ICommand<bool>;

public sealed class ProcessDeliveryCommandValidator : AbstractValidator<ProcessDeliveryCommand>
{
    #region Ctors

    public ProcessDeliveryCommandValidator()
    {
        RuleFor(x => x.DeliveryId)
            .NotEmpty()
            .WithMessage(MessageCode.IdIsRequired);
    }

    #endregion
}

public sealed class ProcessDeliveryCommandHandler(
    IQueryDeliveryRepository deliveryQueryRepo,
    ICommandDeliveryRepository deliveryCommandRepo,
    INotificationSenderResolver resolver,
    ILogger<ProcessDeliveryCommandHandler> logger)
    : ICommandHandler<ProcessDeliveryCommand, bool>
{
    #region Implementations

    public async Task<bool> Handle(ProcessDeliveryCommand command, CancellationToken cancellationToken)
    {
        var delivery = await deliveryQueryRepo.GetByIdAsync(command.DeliveryId, cancellationToken);

        if (delivery == null)
        {
            logger.LogWarning("Delivery not found: {DeliveryId}", command.DeliveryId);
            return false;
        }

        try
        {
            // Check if payload is valid
            if (delivery.Payload == null || delivery.Payload.To == null)
            {
                logger.LogWarning("DeliveryId={DeliveryId} has null payload, marking as Illegal", delivery.Id);
                delivery.UpdateStatus(DeliveryStatus.Illegal, command.Actor.ToString());
                await deliveryCommandRepo.UpsertAsync(delivery, cancellationToken);
                return false;
            }

            // Update status to Sending
            delivery.UpdateStatus(DeliveryStatus.Sending, command.Actor.ToString());
            await deliveryCommandRepo.UpsertAsync(delivery, cancellationToken);

            // Create notification context
            var ctx = new NotificationContext
            {
                To = delivery.Payload.To,
                Cc = delivery.Payload.Cc ?? [],
                Bcc = delivery.Payload.Bcc ?? [],
                Subject = delivery.Payload.Subject,
                Body = delivery.Payload.Body,
                IsHtml = delivery.Payload.IsHtml
            };

            // Send notification
            var result = await resolver.Resolve(delivery.Payload!.Channel).SendAsync(ctx, cancellationToken);

            // Increase attempt count
            delivery.IncreaseAttemptCount();

            var now = DateTimeOffset.UtcNow;

            // Update status based on result
            if (result.IsSuccess)
            {
                delivery.UpdateStatus(DeliveryStatus.Sent, command.Actor.ToString());
                logger.LogInformation("DeliveryId={DeliveryId} sent successfully", delivery.Id);
            }
            else
            {
                delivery.RaiseError(result.ErrorMessage!, now);
                logger.LogWarning("DeliveryId={DeliveryId} failed: {Error}", delivery.Id, result.ErrorMessage);
            }

            // Save delivery
            await deliveryCommandRepo.UpsertAsync(delivery, cancellationToken);

            return result.IsSuccess;
        }
        catch (Exception ex)
        {
            var now = DateTimeOffset.UtcNow;
            delivery.RaiseError(ex.Message, now);
            await deliveryCommandRepo.UpsertAsync(delivery, cancellationToken);
            logger.LogError(ex, "Unhandled error occurred while processing DeliveryId={DeliveryId}", delivery.Id);
            return false;
        }
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Features/Delivery/Queries/GetDueDeliveriesQuery.cs">
#region using

using Notification.Application.Data.Repositories;
using Notification.Domain.Entities;

#endregion

namespace Notification.Application.Features.Delivery.Queries;

public sealed record GetDueDeliveriesQuery(DateTimeOffset Now, int BatchSize) : IQuery<IReadOnlyList<DeliveryEntity>>;

public sealed class GetDueDeliveriesQueryHandler(
    IQueryDeliveryRepository deliveryQueryRepo)
    : IQueryHandler<GetDueDeliveriesQuery, IReadOnlyList<DeliveryEntity>>
{
    #region Implementations

    public async Task<IReadOnlyList<DeliveryEntity>> Handle(GetDueDeliveriesQuery query, CancellationToken cancellationToken)
    {
        return await deliveryQueryRepo.GetDueAsync(query.Now, query.BatchSize, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Features/Keycloak/Queries/GetKeycloakUsersByRoleQuery.cs">
#region using

using Notification.Application.Dtos.Keycloaks;
using Notification.Application.Services;

#endregion

namespace Notification.Application.Features.Keycloak.Queries;

public sealed record GetKeycloakUsersByRoleQuery(string Role) : IQuery<List<KeycloakUserDto>>;

public sealed class GetKeycloakUsersByRoleQueryHandler(
    IKeycloakService keycloakService)
    : IQueryHandler<GetKeycloakUsersByRoleQuery, List<KeycloakUserDto>>
{
    #region Implementations

    public async Task<List<KeycloakUserDto>> Handle(GetKeycloakUsersByRoleQuery query, CancellationToken cancellationToken)
    {
        return await keycloakService.GetUsersByRoleAsync(query.Role, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Features/Keycloak/Queries/GetKeycloakUsersQuery.cs">
#region using

using Notification.Application.Dtos.Keycloaks;
using Notification.Application.Services;

#endregion

namespace Notification.Application.Features.Keycloak.Queries;

public sealed record GetKeycloakUsersQuery() : IQuery<List<KeycloakUserDto>>;

public sealed class GetKeycloakUsersQueryHandler(
    IKeycloakService keycloakService)
    : IQueryHandler<GetKeycloakUsersQuery, List<KeycloakUserDto>>
{
    #region Implementations

    public async Task<List<KeycloakUserDto>> Handle(GetKeycloakUsersQuery query, CancellationToken cancellationToken)
    {
        return await keycloakService.GetUsersAsync(cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Features/Notification/Commands/MarkAsReadNotificationCommand.cs">
#region using

using MediatR;
using Notification.Application.Data.Repositories;
using Notification.Application.Dtos.Notifications;

#endregion

namespace Notification.Application.Features.Notification.Commands;

public sealed record MarkAsReadNotificationCommand(MarkAsReadNotificationDto Dto, Actor Actor) : ICommand<Unit>;

public sealed class MarkAsReadNotificationCommandValidator : AbstractValidator<MarkAsReadNotificationCommand>
{
    #region Ctors

    public MarkAsReadNotificationCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Ids)
                    .NotEmpty()
                    .WithMessage(MessageCode.IdIsRequired);
            });
    }

    #endregion
}

public class MarkAsReadNotificationCommandHandler(
    ICommandNotificationRepository commandRepo,
    IQueryNotificationRepository queryRepo)
    : ICommandHandler<MarkAsReadNotificationCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(MarkAsReadNotificationCommand command, CancellationToken cancellationToken)
    {
        foreach (var id in command.Dto.Ids)
        {
            var doc = await queryRepo.GetNotificationByIdAsync(
            id: id,
            userId: Guid.Parse(command.Actor.ToString()),
            cancellationToken: cancellationToken) ?? throw new NotFoundException(MessageCode.ResourceNotFound);

            doc.MarkAsRead(command.Actor.ToString());

            await commandRepo.UpsertAsync(doc, cancellationToken);
        }

        return Unit.Value;
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Features/Notification/Queries/GetAllNotificationsQuery.cs">
#region using

using AutoMapper;
using Notification.Application.Data.Repositories;
using Notification.Application.Dtos.Notifications;
using Notification.Application.Models.Results;

#endregion

namespace Notification.Application.Features.Notification.Queries;

public sealed record GetAllNotificationsQuery(Actor Actor) : IQuery<GetAllNotificationsResult>;

public sealed class GetAllNotificationsQueryHandler(
    IQueryNotificationRepository queryRepo,
    IMapper mapper)
    : IQueryHandler<GetAllNotificationsQuery, GetAllNotificationsResult>
{
    #region Implementations

    public async Task<GetAllNotificationsResult> Handle(GetAllNotificationsQuery query, CancellationToken cancellationToken)
    {
        var userId = Guid.Parse(query.Actor.ToString());
        var result = await queryRepo.GetAllNotificationsAsync(userId, cancellationToken);
        var items = mapper.Map<List<NotificationDto>>(result);
        var response = new GetAllNotificationsResult(items);
        return response;
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Features/Notification/Queries/GetCountNotificationUnreadQuery.cs">
#region using

using Notification.Application.Data.Repositories;
using Notification.Application.Models.Results;

#endregion

namespace Notification.Application.Features.Notification.Queries;

public sealed record GetCountNotificationUnreadQuery(Actor Actor) : IQuery<GetCountNotificationUnreadResult>;

public sealed class GetCountNotificationUnreadQueryHandler(
    IQueryNotificationRepository queryRepo)
    : IQueryHandler<GetCountNotificationUnreadQuery, GetCountNotificationUnreadResult>
{
    #region Implementations

    public async Task<GetCountNotificationUnreadResult> Handle(GetCountNotificationUnreadQuery query, CancellationToken cancellationToken)
    {
        var userId = Guid.Parse(query.Actor.ToString());
        var count = await queryRepo.GetCountNotificationUnreadAsync(userId, cancellationToken);
        var response = new GetCountNotificationUnreadResult(count);
        return response;
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Features/Notification/Queries/GetNotificationsQuery.cs">
#region using

using AutoMapper;
using Notification.Application.Data.Repositories;
using Notification.Application.Dtos.Notifications;
using Notification.Application.Models.Results;

#endregion

namespace Notification.Application.Features.Notification.Queries;

public sealed record GetNotificationsQuery(Actor Actor, PaginationRequest Paging) : IQuery<GetNotificationsResult>;

public sealed class GetNotificationsQueryHandler(
    IQueryNotificationRepository queryRepo,
    IMapper mapper)
    : IQueryHandler<GetNotificationsQuery, GetNotificationsResult>
{
    #region Implementations

    public async Task<GetNotificationsResult> Handle(GetNotificationsQuery query, CancellationToken cancellationToken)
    {
        var userId = Guid.Parse(query.Actor.ToString());
        var result = await queryRepo.GetNotificationsAsync(userId, cancellationToken);
        var items = mapper.Map<List<NotificationDto>>(result);
        var reponse = new GetNotificationsResult(items);
        return reponse;
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Features/Notification/Queries/GetTop10NotificationsUnreadQuery.cs">
#region using

using AutoMapper;
using Notification.Application.Data.Repositories;
using Notification.Application.Dtos.Notifications;
using Notification.Application.Models.Results;

#endregion

namespace Notification.Application.Features.Notification.Queries;

public sealed record GetTop10NotificationsUnreadQuery(Actor Actor) : IQuery<GetTop10NotificationsUnreadResult>;

public sealed class GetTop10NotificationsUnreadQueryHandler(
    IQueryNotificationRepository queryRepo,
    IMapper mapper)
    : IQueryHandler<GetTop10NotificationsUnreadQuery, GetTop10NotificationsUnreadResult>
{
    #region Implementations

    public async Task<GetTop10NotificationsUnreadResult> Handle(GetTop10NotificationsUnreadQuery query, CancellationToken cancellationToken)
    {
        var userId = Guid.Parse(query.Actor.ToString());
        var result = await queryRepo.GetTop10NotificationsUnreadAsync(userId, cancellationToken);
        var items = mapper.Map<List<NotificationDto>>(result);
        var response = new GetTop10NotificationsUnreadResult(items);
        return response;
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Mappings/NotificationMappingProfile.cs">
#region using

using AutoMapper;
using Notification.Application.Dtos.Keycloaks;
using Notification.Application.Dtos.Notifications;
using Notification.Domain.Entities;
using Notification.Domain.Models.Externals.Keycloaks;

#endregion

namespace Notification.Application.Mappings;

public sealed class NotificationMappingProfile : Profile
{
    #region Ctors

    public NotificationMappingProfile()
    {
        CreateMap<NotificationEntity, NotificationDto>();
        CreateMap<KeycloakUser, KeycloakUserDto>();
        CreateMap<KeycloakAccessToken, KeycloakAccessTokenDto>();
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Models/Results/GetAllNotificationsResult.cs">
#region using

using Notification.Application.Dtos.Notifications;

#endregion

namespace Notification.Application.Models.Results;

public sealed class GetAllNotificationsResult
{
    #region Fields, Properties and Indexers

    public List<NotificationDto>? Notifications { get; set; }

    #endregion

    #region Ctors

    public GetAllNotificationsResult(List<NotificationDto> items)
    {
        Notifications = items;
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Models/Results/GetCountNotificationUnreadResult.cs">
namespace Notification.Application.Models.Results;

public sealed class GetCountNotificationUnreadResult
{
    #region Fields, Properties and Indexers

    public long Count { get; set; }

    #endregion

    #region Ctors

    public GetCountNotificationUnreadResult(long count)
    {
        Count = count;
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Models/Results/GetNotificationsResult.cs">
#region using

using Notification.Application.Dtos.Notifications;

#endregion

namespace Notification.Application.Models.Results;

public sealed class GetNotificationsResult
{
    #region Fields, Properties and Indexers

    public List<NotificationDto>? Notifications { get; set; }

    #endregion

    #region Ctors

    public GetNotificationsResult(List<NotificationDto> items)
    {
        Notifications = items;
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Models/Results/GetTop10NotificationsUnreadResult.cs">
#region using

using Notification.Application.Dtos.Notifications;

#endregion

namespace Notification.Application.Models.Results;

public sealed class GetTop10NotificationsUnreadResult
{
    #region Fields, Properties and Indexers

    public List<NotificationDto>? Notifications { get; set; }

    #endregion

    #region Ctors

    public GetTop10NotificationsUnreadResult(List<NotificationDto> items)
    {
        Notifications = items;
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Models/ChannelResult.cs">
namespace Notification.Application.Models;

public sealed class ChannelResult
{
    #region Fields, Properties and Indexers

    public bool IsSuccess { get; }

    public string? ProviderMessageId { get; }

    public string? ErrorMessage { get; }

    #endregion

    #region Ctors

    private ChannelResult(bool ok, string? id = null, string? msg = null)
    {
        IsSuccess = ok; ProviderMessageId = id; ErrorMessage = msg;
    }

    #endregion

    #region Methods

    public static ChannelResult Success(string? providerMessageId = null) =>
        new(true, providerMessageId);

    public static ChannelResult Failure(string errorMessage) =>
        new(false, null, errorMessage);

    #endregion

}
</file>

<file path="Services/Notification/Core/Notification.Application/Models/NotificationContext.cs">
namespace Notification.Application.Models;

public sealed class NotificationContext
{
    #region Fields, Properties and Indexers

    public Guid? UserId { get; init; }

    public IReadOnlyCollection<string> To { get; init; } = [];

    public IReadOnlyCollection<string> Cc { get; init; } = [];

    public IReadOnlyCollection<string> Bcc { get; init; } = [];

    public string? Subject { get; init; }

    public string? Body { get; init; }

    public bool IsHtml { get; init; }

    public IReadOnlyDictionary<string, object> Data { get; init; } = new Dictionary<string, object>();

    public string? TargetUrl { get; set; }

    #endregion

}
</file>

<file path="Services/Notification/Core/Notification.Application/Providers/ITemplateProvider.cs">
namespace Notification.Application.Providers;

public interface ITemplateProvider
{
    #region Methods

    string Render(string template, IDictionary<string, object> data = default!);

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Services/IKeycloakService.cs">
#region using

using Notification.Application.Dtos.Keycloaks;

#endregion

namespace Notification.Application.Services;

public interface IKeycloakService
{
    #region Methods

    Task<List<KeycloakUserDto>> GetUsersAsync(CancellationToken cancellationToken = default);

    Task<List<KeycloakUserDto>> GetUsersByRoleAsync(string role, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Strategy/INotificationSender.cs">
#region using

using Notification.Application.Models;
using Notification.Domain.Enums;

#endregion

namespace Notification.Application.Strategy;

public interface INotificationSender
{
    #region Fields, Properties and Indexers

    ChannelType Channel { get; }

    #endregion

    #region Methods

    Task<ChannelResult> SendAsync(NotificationContext context, CancellationToken cancellationToken);

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/Strategy/INotificationSenderResolver.cs">
#region using

using Notification.Domain.Enums;

#endregion

namespace Notification.Application.Strategy;

public interface INotificationSenderResolver
{
    #region Methods

    INotificationSender Resolve(ChannelType channel);

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/ApplicationMarker.cs">
namespace Notification.Application;

public sealed class ApplicationMarker { }
</file>

<file path="Services/Notification/Core/Notification.Application/DependencyInjection.cs">
#region using

using BuildingBlocks.Behaviors;
using BuildingBlocks.Exceptions.Handler;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.FeatureManagement;
using System.Reflection;

#endregion

namespace Notification.Application;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddApplicationServices(this IServiceCollection services)
    {
        services.AddExceptionHandler<CustomExceptionHandler>();
        services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
        services.AddMediatR(config =>
        {
            config.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
            config.AddOpenBehavior(typeof(ValidationBehavior<,>));
            config.AddOpenBehavior(typeof(LoggingBehavior<,>));
        });
        services.AddFeatureManagement();
        services.AddAutoMapper(Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Application/GlobalUsing.cs">
global using BuildingBlocks.CQRS;
global using FluentValidation;
global using Common.Constants;
global using Common.Models;
global using BuildingBlocks.Exceptions;
global using Common.ValueObjects;
</file>

<file path="Services/Notification/Core/Notification.Application/Notification.Application.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="AutoMapper" />
    <PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" />
    <PackageReference Include="Scrutor" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\Notification.Domain\Notification.Domain.csproj" />
  </ItemGroup>

  <ItemGroup>
    <None Include="Strategy\INotificationSender.cs" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Models\Responses\Externals\" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Notification/Core/Notification.Domain/Abstractions/Aggregate.cs">
namespace Notification.Domain.Abstractions;

public abstract class Aggregate<TId> : Entity<TId>, IAggregate<TId>
{
    #region Fields, Properties and Indexers

    private readonly List<IDomainEvent> _domainEvents = new();

    #endregion

    #region Implementations

    public IReadOnlyList<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    public void AddDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }

    public IDomainEvent[] ClearDomainEvents()
    {
        IDomainEvent[] dequeuedEvents = _domainEvents.ToArray();

        _domainEvents.Clear();

        return dequeuedEvents;
    }

    #endregion

}
</file>

<file path="Services/Notification/Core/Notification.Domain/Abstractions/Entity.cs">
#region using

using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;

#endregion

namespace Notification.Domain.Abstractions;

public abstract class Entity<T> : IEntityId<T>, IAuditable
{
    #region Fields, Properties and Indexers

    [BsonId]
    [BsonRepresentation(BsonType.String)]
    public T Id { get; set; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Notification/Core/Notification.Domain/Abstractions/IAggregate.cs">
namespace Notification.Domain.Abstractions;

public interface IAggregate<T> : IAggregate, IEntityId<T>
{
}

public interface IAggregate : ICreationAuditable, IModificationAuditable
{
    #region Fields, Properties and Indexers

    IReadOnlyList<IDomainEvent> DomainEvents { get; }

    IDomainEvent[] ClearDomainEvents();

    #endregion

}
</file>

<file path="Services/Notification/Core/Notification.Domain/Abstractions/IAuditable.cs">
namespace Notification.Domain.Abstractions;

public interface IAuditable : ICreationAuditable, IModificationAuditable { }
</file>

<file path="Services/Notification/Core/Notification.Domain/Abstractions/ICreationAuditable.cs">
namespace Notification.Domain.Abstractions;

public interface ICreationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Notification/Core/Notification.Domain/Abstractions/IDomainEvent.cs">
#region using

using MediatR;

#endregion

namespace Notification.Domain.Abstractions;

public interface IDomainEvent : INotification
{
    #region Fields, Properties and Indexers

    Guid EventId => Guid.NewGuid();

    public DateTimeOffset OccurredOn => DateTime.Now;

    public string EventType => GetType()?.AssemblyQualifiedName ?? string.Empty;

    #endregion

}
</file>

<file path="Services/Notification/Core/Notification.Domain/Abstractions/IEntityId.cs">
namespace Notification.Domain.Abstractions;

public interface IEntityId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; set; }

    #endregion

}
</file>

<file path="Services/Notification/Core/Notification.Domain/Abstractions/IModificationAuditable.cs">
namespace Notification.Domain.Abstractions;

public interface IModificationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Notification/Core/Notification.Domain/Entities/DeliveryEntity.cs">
#region using

using Notification.Domain.Abstractions;
using Notification.Domain.Enums;

#endregion

namespace Notification.Domain.Entities;

public sealed class DeliveryEntity : Aggregate<Guid>
{
    #region Fields, Properties and Indexers

    public string? EventId { get; set; }

    public MessagePayloadEntity? Payload { get; set; }

    public DeliveryStatus Status { get; set; }

    public DeliveryPriority Priority { get; set; }

    public int AttemptCount { get; set; }

    public int MaxAttempts { get; set; }

    public string? LastErrorMessage { get; set; }

    public DateTimeOffset? SentOnUtc { get; set; }

    public DateTimeOffset? ProcessedOnUtc { get; set; }

    public DateTimeOffset? NextAttemptUtc { get; set; }

    #endregion

    #region Methods

    public static DeliveryEntity Create(
        Guid id,
        ChannelType channel,
        List<string> to,
        string subject,
        bool isHtml,
        string body,
        DeliveryPriority priority,
        string eventId,
        string performedBy,
        int maxAttempts,
        string? targetUrl = null,
        List<string>? cc = null,
        List<string>? bcc = null)
    {
        var payload = MessagePayloadEntity.Create(
            channel: channel,
            subject: subject,
            isHtml: isHtml,
            to: to,
            cc: cc,
            bcc: bcc,
            body: body,
            targetUrl: targetUrl);

        return new DeliveryEntity()
        {
            Id = id,
            Payload = payload,
            Status = DeliveryStatus.Queued,
            Priority = priority,
            EventId = eventId,
            MaxAttempts = maxAttempts,
            CreatedBy = performedBy,
            LastModifiedBy = performedBy,
            CreatedOnUtc = DateTimeOffset.UtcNow,
            LastModifiedOnUtc = DateTimeOffset.UtcNow
        };
    }

    public void UpdateStatus(DeliveryStatus status, string performedBy)
    {
        Status = status;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
        SentOnUtc = status == DeliveryStatus.Sent ? DateTimeOffset.UtcNow : SentOnUtc;
        ProcessedOnUtc = DateTimeOffset.UtcNow;
    }

    public void RaiseError(
        string errorMessage,
        DateTimeOffset nextAttemptUtc)
    {
        if (AttemptCount >= MaxAttempts)
        {
            Status = DeliveryStatus.GiveUp;
            LastErrorMessage = errorMessage;
            NextAttemptUtc = null;
        }
        else
        {
            Status = DeliveryStatus.Failed;
            LastErrorMessage = errorMessage;
            var backoff = TimeSpan.FromSeconds(Math.Min(60, Math.Pow(2, AttemptCount)))
                        + TimeSpan.FromMilliseconds(Random.Shared.Next(0, 250));
            NextAttemptUtc = nextAttemptUtc + backoff;
        }
    }

    public void IncreaseAttemptCount()
    {
        AttemptCount += 1;
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Domain/Entities/MessagePayloadEntity.cs">
#region using

using Notification.Domain.Enums;

#endregion

namespace Notification.Domain.Entities;

public sealed class MessagePayloadEntity
{
    #region Fields, Properties and Indexers

    public ChannelType Channel { get; set; }

    public IReadOnlyCollection<string>? To { get; set; }

    public IReadOnlyCollection<string>? Cc { get; set; }

    public IReadOnlyCollection<string>? Bcc { get; set; }

    public string? Subject { get; set; }

    public string? Body { get; set; }

    public bool IsHtml { get; set; }

    public string? TargetUrl { get; set; }

    #endregion

    #region Methods

    public static MessagePayloadEntity Create(
        ChannelType channel,
        List<string> to,
        string subject,
        string body,
        bool isHtml = false,
        string? targetUrl = null,
        List<string>? cc = null,
        List<string>? bcc = null)
    {
        return new MessagePayloadEntity()
        {
            Channel = channel,
            To = to,
            Cc = cc,
            Bcc = bcc,
            Subject = subject,
            Body = body,
            IsHtml = isHtml,
            TargetUrl = targetUrl
        };
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Domain/Entities/NotificationEntity.cs">
#region using

using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;
using Notification.Domain.Abstractions;

#endregion

namespace Notification.Domain.Entities;

public sealed class NotificationEntity : Entity<Guid>
{
    #region Fields, Properties and Indexers

    [BsonRepresentation(BsonType.String)]
    public Guid? UserId { get; set; }

    public string? Title { get; set; }

    public string? Message { get; set; }

    public bool IsRead { get; set; }

    public DateTimeOffset? ReadAt { get; set; }

    public string? TargetUrl { get; set; }

    #endregion

    #region Methods

    public static NotificationEntity Create(
        Guid id,
        Guid userId,
        string title,
        string message,
        string performedBy)
    {
        return new NotificationEntity()
        {
            Id = id,
            UserId = userId,
            Title = title,
            Message = message,
            CreatedBy = performedBy,
            LastModifiedBy = performedBy,
            CreatedOnUtc = DateTimeOffset.UtcNow,
            LastModifiedOnUtc = DateTimeOffset.UtcNow
        };
    }

    public void MarkAsRead(string modifiedBy)
    {
        IsRead = true;
        ReadAt = DateTimeOffset.UtcNow;
        LastModifiedBy = modifiedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    public void UpdateTargetUrl(string targetUrl, string modifiedBy)
    {
        TargetUrl = targetUrl;
        LastModifiedBy = modifiedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Domain/Entities/TemplateEntity.cs">
#region using

using Notification.Domain.Abstractions;
using Notification.Domain.Enums;

#endregion

namespace Notification.Domain.Entities;

public sealed class TemplateEntity : Entity<Guid>
{
    #region Fields, Properties and Indexers

    public string? Key { get; set; }

    public ChannelType Channel { get; set; }

    public string? Subject { get; set; }

    public string? Body { get; set; }

    public bool IsHtml { get; set; }

    #endregion

    #region Methods

    public static TemplateEntity Create(
        Guid id,
        string key,
        ChannelType channel,
        string subject,
        bool isHtml,
        string body,
        string performedBy)
    {
        return new TemplateEntity()
        {
            Id = id,
            Key = key,
            Channel = channel,
            Subject = subject,
            Body = body,
            IsHtml = isHtml,
            CreatedBy = performedBy,
            LastModifiedBy = performedBy,
            CreatedOnUtc = DateTimeOffset.UtcNow,
            LastModifiedOnUtc = DateTimeOffset.UtcNow
        };
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Domain/Enums/ChannelType.cs">
namespace Notification.Domain.Enums;

public enum ChannelType
{
    Email = 1,

    InApp = 2,

    Discord = 3
}
</file>

<file path="Services/Notification/Core/Notification.Domain/Enums/DeliveryPriority.cs">
namespace Notification.Domain.Enums;

public enum DeliveryPriority
{
    Low = 1,
    Medium = 2,
    High = 3,
}
</file>

<file path="Services/Notification/Core/Notification.Domain/Enums/DeliveryStatus.cs">
namespace Notification.Domain.Enums;

public enum DeliveryStatus
{
    Queued = 1,
    Sent = 2,
    Failed = 3,
    Sending = 4,
    Illegal = 5,
    GiveUp = 6,
}
</file>

<file path="Services/Notification/Core/Notification.Domain/Enums/DiscordColor.cs">
namespace Notification.Domain.Enums;

public enum DiscordColor
{
    Red = 13369344,
    Yellow = 16776960,
    Green = 6736896,
    Blue = 1127128,
    Orange = 14177041
}
</file>

<file path="Services/Notification/Core/Notification.Domain/Exceptions/DomainException.cs">
namespace Notification.Domain.Exceptions;

public sealed class DomainException : Exception
{
    public DomainException(string message) : base(message)
    {
    }
}
</file>

<file path="Services/Notification/Core/Notification.Domain/Models/Externals/Discord/DiscordWebhookPayload.cs">
#region using

using System.Text.Json.Serialization;

#endregion

namespace Notification.Domain.Models.Externals.Discord;

public sealed class DiscordWebhookPayload
{
    #region Fields, Properties and Indexers

    [JsonPropertyName("username")]
    public string? Username { get; set; }

    [JsonPropertyName("avatar_url")]
    public string? AvatarUrl { get; set; }

    [JsonPropertyName("embeds")]
    public List<DiscordEmbed> Embeds { get; set; } = [];

    #endregion
}

public sealed class DiscordEmbed
{
    #region Fields, Properties and Indexers

    [JsonPropertyName("title")]
    public string? Title { get; set; }

    [JsonPropertyName("color")]
    public int Color { get; set; }

    [JsonPropertyName("url")]
    public string? Url { get; set; }

    [JsonPropertyName("description")]
    public string? Description { get; set; }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Domain/Models/Externals/Keycloaks/KeycloakAccessToken.cs">
#region using

using System.Text.Json.Serialization;

#endregion

namespace Notification.Domain.Models.Externals.Keycloaks;

public sealed class KeycloakAccessToken
{
    #region Fields, Properties and Indexers

    [JsonPropertyName("access_token")]
    public string? AccessToken { get; set; }

    [JsonPropertyName("expires_in")]
    public int ExpiresIn { get; set; }

    [JsonPropertyName("refresh_expires_in")]
    public int RefreshExpiresIn { get; set; }

    [JsonPropertyName("token_type")]
    public string? TokenType { get; set; }

    [JsonPropertyName("id_token")]
    public string? IdToken { get; set; }

    [JsonPropertyName("not-before-policy")]
    public int NotBeforePolicy { get; set; }

    [JsonPropertyName("scope")]
    public string? Scope { get; set; }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Domain/Models/Externals/Keycloaks/KeycloakUser.cs">
#region using

using System.Text.Json.Serialization;

#endregion

namespace Notification.Domain.Models.Externals.Keycloaks;

public sealed class KeycloakUser
{
    #region Fields, Properties and Indexers

    [JsonPropertyName("id")]
    public string Id { get; set; } = default!;

    [JsonPropertyName("createdTimestamp")]
    public long CreatedTimestamp { get; set; }

    [JsonPropertyName("username")]
    public string? Username { get; set; }

    [JsonPropertyName("enabled")]
    public bool Enabled { get; set; }

    [JsonPropertyName("totp")]
    public bool Totp { get; set; }

    [JsonPropertyName("emailVerified")]
    public bool EmailVerified { get; set; }

    [JsonPropertyName("firstName")]
    public string? FirstName { get; set; }

    [JsonPropertyName("lastName")]
    public string? LastName { get; set; }

    [JsonPropertyName("email")]
    public string? Email { get; set; }

    [JsonPropertyName("notBefore")]
    public int NotBefore { get; set; }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Domain/GlobalUsing.cs">

</file>

<file path="Services/Notification/Core/Notification.Domain/Notification.Domain.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="MediatR" />
    <PackageReference Include="MongoDB.Bson" />
    <PackageReference Include="Newtonsoft.Json" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Events\" />
    <Folder Include="ValueObjects\" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/ApiClients/IDiscordApi.cs">
#region using

using Notification.Domain.Models.Externals.Discord;
using Refit;

#endregion

namespace Notification.Infrastructure.ApiClients;

public interface IDiscordApi
{
    #region Methods

    [Post("/api/webhooks/{webhookId}/{webhookToken}")]
    Task<ApiResponse<object>> SendMessageAsync(
        [AliasAs("webhookId")] string webhookId,
        [AliasAs("webhookToken")] string webhookToken,
        [Body] DiscordWebhookPayload payload);

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/ApiClients/IKeycloakApi.cs">
#region using

using Notification.Domain.Models.Externals.Keycloaks;
using Refit;

#endregion

namespace Notification.Infrastructure.ApiClients;

public interface IKeycloakApi
{
    #region Methods

    [Post("/realms/{realm}/protocol/openid-connect/token")]
    [Headers("Content-Type: application/x-www-form-urlencoded")]
    Task<KeycloakAccessToken> GetAccessTokenAsync(
        [AliasAs("realm")] string realm,
        [Body(BodySerializationMethod.UrlEncoded)] Dictionary<string, string> form);

    [Get("/admin/realms/{realm}/users")]
    Task<List<KeycloakUser>> GetUsersAsync(
        [AliasAs("realm")] string realm,
        [Header("Authorization")] string bearerToken);

    [Get("/admin/realms/{realm}/roles/{role}/users")]
    Task<List<KeycloakUser>> GetUsersByRoleAsync(
        [AliasAs("realm")] string realm,
        [AliasAs("role")] string role,
        [Header("Authorization")] string bearerToken);

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/Constants/MongoCollection.cs">
namespace Notification.Infrastructure.Constants;

public sealed class MongoCollection
{
    #region Constants

    public const string Notification = "notifications";

    public const string Delivery = "deliveries";

    public const string Template = "templates";

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/Data/Extensions/DatabaseExtentions.cs">
#region using

using Common.ValueObjects;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using MongoDB.Driver;
using Notification.Application.Constants;
using Notification.Domain.Entities;
using Notification.Infrastructure.Constants;

#endregion

namespace Notification.Infrastructure.Data.Extensions;

public static class DatabaseExtentions
{
    #region Methods

    public static async Task InitialiseDatabaseAsync(this WebApplication app)
    {
        var db = app.Services.GetRequiredService<IMongoDatabase>();
        var collection = db.GetCollection<TemplateEntity>(MongoCollection.Template);

        var models = new List<WriteModel<TemplateEntity>>();
        var docs = new List<TemplateEntity>()
        {
            TemplateEntity.Create(
                id: Guid.Parse("c63f5f8d-daba-409f-88f9-fc3a9eb3e7e1"),
                key: TemplateKey.ProductUpserted,
                channel: Domain.Enums.ChannelType.InApp,
                subject: "Product Have Updated",
                isHtml: false,
                body: "The product #PRODUCT_NAME# has updated by #PERFORM_BY#",
                performedBy: Actor.System(AppConstants.Service.Notification).ToString()),

            TemplateEntity.Create(
                id: Guid.Parse("c63f5f8d-daba-409f-88f9-fc3a9eb3e7e2"),
                key: TemplateKey.ProductUpserted,
                channel: Domain.Enums.ChannelType.Discord,
                subject: "Product Have Updated",
                isHtml: false,
                body: "The product #PRODUCT_NAME# has updated by #PERFORM_BY#",
                performedBy: Actor.System(AppConstants.Service.Notification).ToString()),

            TemplateEntity.Create(
                id: Guid.Parse("c63f5f8d-daba-409f-88f9-fc3a9eb3e7e3"),
                key: TemplateKey.ProductUpserted,
                channel: Domain.Enums.ChannelType.Email,
                subject: "Product Have Updated",
                isHtml: true,
                body: "<p>Dear #USERNAME#</p>, <p>The product #PRODUCT_NAME# has updated by #PERFORM_BY#</p> <p>Best Regards,</p> <p>ProG Coder</p>",
                performedBy: Actor.System(AppConstants.Service.Notification).ToString()),
        };

        foreach (var template in docs)
        {
            var filter = Builders<TemplateEntity>.Filter.Eq(x => x.Id, template.Id);
            var replace = new ReplaceOneModel<TemplateEntity>(filter, template)
            {
                IsUpsert = true
            };

            models.Add(replace);
        }

        await collection.BulkWriteAsync(models);
    }

    public static async Task EnsureIndexesAsync(this WebApplication app)
    {
        var db = app.Services.GetRequiredService<IMongoDatabase>();
        var notif = db.GetCollection<NotificationEntity>(MongoCollection.Notification);
        var deliv = db.GetCollection<DeliveryEntity>(MongoCollection.Delivery);
        var tmpl = db.GetCollection<TemplateEntity>(MongoCollection.Template);

        await notif.Indexes.CreateOneAsync(new CreateIndexModel<NotificationEntity>(
        Builders<Domain.Entities.NotificationEntity>.IndexKeys
            .Ascending(x => x.UserId)
            .Ascending(x => x.IsRead)
            .Descending(x => x.CreatedOnUtc)));

        await deliv.Indexes.CreateOneAsync(new CreateIndexModel<DeliveryEntity>(
            Builders<DeliveryEntity>.IndexKeys
                .Ascending(x => x.Status)
                .Ascending(x => x.NextAttemptUtc)
                .Descending(x => x.Priority)
                .Ascending(x => x.CreatedOnUtc)));

        await tmpl.Indexes.CreateOneAsync(new CreateIndexModel<TemplateEntity>(
            Builders<TemplateEntity>.IndexKeys
                .Ascending(x => x.Key)
                .Ascending(x => x.Channel),
            new CreateIndexOptions { Unique = true }));
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/Exceptions/InfrastructureException.cs">
namespace Notification.Infrastructure.Exceptions;

public sealed class InfrastructureException : Exception
{
    #region Ctors

    public InfrastructureException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/Providers/TemplateProvider.cs">
#region using

using Notification.Application.Providers;
using System.Text.RegularExpressions;

#endregion

namespace Notification.Infrastructure.Providers;

public sealed class TemplateProvider : ITemplateProvider
{
    #region Fields, Properties and Indexers

    private static readonly Regex Pattern = new(@"#(\w+)#", RegexOptions.Compiled);

    #endregion

    #region Implementations

    public string Render(string template, IDictionary<string, object> data = default!)
    {
        if (data == null) return template;

        return Pattern.Replace(template, m =>
        {
            var key = m.Groups[1].Value;
            return data.TryGetValue(key, out var val) && val is not null
            ? val.ToString()!
            : string.Empty;
        });
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/Repositories/DeliveryRepository.cs">
#region using

using MongoDB.Driver;
using Notification.Application.Data.Repositories;
using Notification.Domain.Entities;
using Notification.Domain.Enums;
using Notification.Infrastructure.Constants;

#endregion

namespace Notification.Infrastructure.Repositories;

public sealed class DeliveryRepository : ICommandDeliveryRepository, IQueryDeliveryRepository
{
    #region Fields, Properties and Indexers

    private readonly IMongoCollection<DeliveryEntity> _collection;

    #endregion

    #region Ctors

    public DeliveryRepository(IMongoDatabase db)
    {
        _collection = db.GetCollection<DeliveryEntity>(MongoCollection.Delivery);
    }

    #endregion

    #region Implementations

    public async Task<IReadOnlyList<DeliveryEntity>> GetDueAsync(
        DateTimeOffset now,
        int batchSize,
        CancellationToken cancellationToken = default)
    {
        var filterBuilder = Builders<DeliveryEntity>.Filter;
        var queuedDue = filterBuilder.And(
            filterBuilder.Eq(x => x.Status, DeliveryStatus.Queued),
            filterBuilder.Or(
                filterBuilder.Eq(x => x.NextAttemptUtc, null),
                filterBuilder.Lte(x => x.NextAttemptUtc, now)
            )
        );
        var failedDue = filterBuilder.And(
            filterBuilder.Eq(x => x.Status, DeliveryStatus.Failed),
            filterBuilder.Ne(x => x.NextAttemptUtc, null),
            filterBuilder.Lte(x => x.NextAttemptUtc, now)
        );
        var filter = filterBuilder.Or(queuedDue, failedDue);
        var sort = Builders<DeliveryEntity>.Sort
            .Ascending(x => x.NextAttemptUtc)
            .Descending(x => x.Priority)
            .Ascending(x => x.CreatedOnUtc);

        return await _collection.Find(filter)
            .Sort(sort)
            .Limit(batchSize)
            .ToListAsync(cancellationToken);
    }

    public async Task InsertManyAsync(IEnumerable<DeliveryEntity> docs, CancellationToken cancellationToken = default)
    {
        await _collection.InsertManyAsync(docs, cancellationToken: cancellationToken);
    }

    public async Task UpsertAsync(DeliveryEntity doc, CancellationToken cancellationToken = default)
    {
        var filter = Builders<DeliveryEntity>.Filter.Eq(x => x.Id, doc.Id);

        await _collection.ReplaceOneAsync(
            filter: filter,
            replacement: doc,
            options: new ReplaceOptions { IsUpsert = true },
            cancellationToken: cancellationToken
        );
    }

    public async Task<DeliveryEntity?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var filter = Builders<DeliveryEntity>.Filter.Eq(x => x.Id, id);

        return await _collection.Find(filter).SingleOrDefaultAsync(cancellationToken);
    }

    public async Task<DeliveryEntity> GetByEventIdAsync(string eventId, CancellationToken cancellationToken = default)
    {
        var filter = Builders<DeliveryEntity>.Filter.Eq(x => x.EventId, eventId);

        return await _collection.Find(filter).SingleOrDefaultAsync(cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/Repositories/NotificationRepository.cs">
#region using

using MongoDB.Driver;
using Notification.Application.Data.Repositories;
using Notification.Domain.Entities;
using Notification.Infrastructure.Constants;

#endregion

namespace Notification.Infrastructure.Repositories;

public sealed class NotificationRepository : ICommandNotificationRepository, IQueryNotificationRepository
{
    #region Fields, Properties and Indexers

    private readonly IMongoCollection<NotificationEntity> _collection;

    #endregion

    #region Ctors

    public NotificationRepository(IMongoDatabase db)
    {
        _collection = db.GetCollection<NotificationEntity>(MongoCollection.Notification);
    }

    #endregion

    #region Implementations

    public async Task<List<NotificationEntity>> GetNotificationsAsync(Guid userId, CancellationToken cancellationToken = default)
    {
        var filterBuilder = Builders<NotificationEntity>.Filter;
        var finalFilter = filterBuilder.And(
            filterBuilder.Eq(x => x.UserId, (Guid?)userId),
            filterBuilder.Eq(x => x.IsRead, false)
        );
        var sort = Builders<NotificationEntity>.Sort
            .Descending(x => x.CreatedOnUtc);

        return await _collection.Find(finalFilter)
            .Sort(sort)
            .ToListAsync(cancellationToken);
    }

    public async Task<NotificationEntity> GetNotificationByIdAsync(Guid id, Guid userId, CancellationToken cancellationToken = default)
    {
        var filterBuilder = Builders<NotificationEntity>.Filter;
        var filter = filterBuilder.And(
            filterBuilder.Eq(x => x.UserId, (Guid?)userId),
            filterBuilder.Eq(x => x.Id, id)
        );

        return await _collection.Find(filter).SingleOrDefaultAsync(cancellationToken);
    }

    public async Task UpsertAsync(NotificationEntity doc, CancellationToken cancellationToken = default)
    {
        var filter = Builders<NotificationEntity>.Filter.Eq(x => x.Id, doc.Id);

        await _collection.ReplaceOneAsync(
            filter: filter,
            replacement: doc,
            options: new ReplaceOptions { IsUpsert = true },
            cancellationToken: cancellationToken
        );
    }

    public async Task<List<NotificationEntity>> GetAllNotificationsAsync(Guid userId, CancellationToken cancellationToken = default)
    {
        var filter = Builders<NotificationEntity>.Filter.Eq(x => x.UserId, (Guid?)userId);
        var sort = Builders<NotificationEntity>.Sort
            .Descending(x => x.CreatedOnUtc);

        return await _collection.Find(filter)
            .Sort(sort)
            .ToListAsync(cancellationToken);
    }

    public async Task<long> GetCountNotificationUnreadAsync(Guid userId, CancellationToken cancellationToken = default)
    {
        var filterBuilder = Builders<NotificationEntity>.Filter;
        var filter = filterBuilder.And(
            filterBuilder.Eq(x => x.UserId, (Guid?)userId),
            filterBuilder.Eq(x => x.IsRead, false)
        );

        return await _collection.CountDocumentsAsync(filter, cancellationToken: cancellationToken);
    }

    public async Task<List<NotificationEntity>> GetTop10NotificationsUnreadAsync(Guid userId, CancellationToken cancellationToken = default)
    {
        var filterBuilder = Builders<NotificationEntity>.Filter;
        var filter = filterBuilder.And(
            filterBuilder.Eq(x => x.UserId, (Guid?)userId),
            filterBuilder.Eq(x => x.IsRead, false)
        );
        var sort = Builders<NotificationEntity>.Sort
            .Descending(x => x.CreatedOnUtc);

        return await _collection.Find(filter)
            .Sort(sort)
            .Limit(10)
            .ToListAsync(cancellationToken);
    }

    #endregion

}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/Repositories/TemplateRepository.cs">
#region using

using MongoDB.Driver;
using Notification.Application.Data.Repositories;
using Notification.Domain.Entities;
using Notification.Domain.Enums;
using Notification.Infrastructure.Constants;

#endregion

namespace Notification.Infrastructure.Repositories;

public sealed class TemplateRepository : IQueryTemplateRepository
{
    #region Fields, Properties and Indexers

    private readonly IMongoCollection<TemplateEntity> _collection;

    #endregion

    #region Ctors

    public TemplateRepository(IMongoDatabase db)
    {
        _collection = db.GetCollection<TemplateEntity>(MongoCollection.Template);
    }

    #endregion

    #region Implementations

    public async Task<TemplateEntity> GetAsync(
        string key,
        ChannelType channel,
        CancellationToken cancellationToken = default)
    {
        return await _collection.Find(x => x.Key == key && x.Channel == channel)
            .FirstOrDefaultAsync(cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/Resolvers/NotificationChannelResolver.cs">
#region using

using Notification.Application.Strategy;
using Notification.Domain.Enums;
using Notification.Infrastructure.Exceptions;

#endregion

namespace Notification.Infrastructure.Resolvers;

public sealed class NotificationChannelResolver : INotificationSenderResolver
{
    #region Fields, Properties and Indexers

    private readonly IReadOnlyDictionary<ChannelType, INotificationSender> _map;

    #endregion

    #region Ctors

    public NotificationChannelResolver(IEnumerable<INotificationSender> channels)
        => _map = channels.ToDictionary(c => c.Channel);

    #endregion

    #region Implementations

    public INotificationSender Resolve(ChannelType channel) =>
        _map.TryGetValue(channel, out var impl)
            ? impl
            : throw new InfrastructureException($"No channel registered for {channel}.");

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/Senders/DiscordNotificationSender.cs">
#region using

using Microsoft.Extensions.Configuration;
using Notification.Application.Models;
using Notification.Domain.Enums;
using Notification.Domain.Models.Externals.Discord;
using Notification.Infrastructure.ApiClients;
using Notification.Application.Strategy;

#endregion

namespace Notification.Infrastructure.Senders;

public sealed class DiscordNotificationSender : INotificationSender
{
    #region Fields, Properties and Indexers

    public ChannelType Channel => ChannelType.Discord;

    private readonly IDiscordApi _discordApi;

    private readonly string _webhookId;

    private readonly string _webhookToken;

    private readonly string _botName;

    private readonly string _avatarUrl;

    private readonly string _url;

    #endregion

    #region Ctors

    public DiscordNotificationSender(
        IConfiguration cfg,
        IDiscordApi discordApi)
    {
        _webhookId = cfg.GetValue<string>($"{NotificationCfg.DiscordSettings.Section}:{NotificationCfg.DiscordSettings.WebhookId}")!;
        _webhookToken = cfg.GetValue<string>($"{NotificationCfg.DiscordSettings.Section}:{NotificationCfg.DiscordSettings.WebhookToken}")!;
        _botName = cfg.GetValue<string>($"{NotificationCfg.DiscordSettings.Section}:{NotificationCfg.DiscordSettings.BotName}")!;
        _avatarUrl = cfg.GetValue<string>($"{NotificationCfg.DiscordSettings.Section}:{NotificationCfg.DiscordSettings.AvatarUrl}")!;
        _url = cfg.GetValue<string>($"{NotificationCfg.DiscordSettings.Section}:{NotificationCfg.DiscordSettings.Url}")!;
        _discordApi = discordApi;
    }

    #endregion

    #region Methods

    public async Task<ChannelResult> SendAsync(NotificationContext context, CancellationToken cancellationToken)
    {
        try
        {
            var payload = new DiscordWebhookPayload
            {
                Username = _botName,
                AvatarUrl = _avatarUrl,
                Embeds = new List<DiscordEmbed>
                {
                    new DiscordEmbed
                    {
                        Title = context.Subject,
                        Color = (int)DiscordColor.Green,
                        Url = _url,
                        Description = context.Body
                    }
                }
            };

            var response = await _discordApi.SendMessageAsync(_webhookId, _webhookToken, payload);

            if (response.IsSuccessStatusCode)
            {
                return ChannelResult.Success();
            }

            var errorMessage = response.Error?.Content ?? response.StatusCode.ToString();
            return ChannelResult.Failure($"Discord API error: {response.StatusCode} - {errorMessage}");
        }
        catch (Exception ex)
        {
            return ChannelResult.Failure(ex.Message);
        }
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/Senders/EmailNotificationSender.cs">
#region using

using Microsoft.Extensions.Configuration;
using Notification.Application.Models;
using Notification.Domain.Enums;
using System.Net;
using System.Net.Mail;
using System.Text;
using Notification.Application.Strategy;

#endregion

namespace Notification.Infrastructure.Senders;

public sealed class EmailNotificationSender : INotificationSender
{
    #region Fields, Properties and Indexers

    public ChannelType Channel => ChannelType.Email;

    private readonly string _smtpServer;

    private readonly int _smtpPort;

    private readonly string _fromAddress;

    private readonly string _fromName;

    private readonly string _username;

    private readonly string _password;

    private readonly bool _enableSsl;

    private readonly int _timeoutMs;

    #endregion

    #region Ctors

    public EmailNotificationSender(IConfiguration cfg)
    {
        _smtpServer = cfg.GetValue<string>($"{NotificationCfg.EmailSettings.Section}:{NotificationCfg.EmailSettings.SmtpServer}")!;
        _smtpPort = cfg.GetValue($"{NotificationCfg.EmailSettings.Section}:{NotificationCfg.EmailSettings.SmtpPort}", 587);
        _fromAddress = cfg.GetValue($"{NotificationCfg.EmailSettings.Section}:{NotificationCfg.EmailSettings.FromAddress}", "admin@progcoder.com")!;
        _fromName = cfg.GetValue($"{NotificationCfg.EmailSettings.Section}:{NotificationCfg.EmailSettings.FromName}", "ProG Coder")!;
        _username = cfg.GetValue<string>($"{NotificationCfg.EmailSettings.Section}:{NotificationCfg.EmailSettings.Username}")!;
        _password = cfg.GetValue<string>($"{NotificationCfg.EmailSettings.Section}:{NotificationCfg.EmailSettings.Password}")!;
        _enableSsl = cfg.GetValue($"{NotificationCfg.EmailSettings.Section}:{NotificationCfg.EmailSettings.EnableSsl}", false);
        _timeoutMs = cfg.GetValue($"{NotificationCfg.EmailSettings.Section}:{NotificationCfg.EmailSettings.TimeoutMs}", 30000);
    }

    #endregion

    #region Methods

    public async Task<ChannelResult> SendAsync(NotificationContext context, CancellationToken cancellationToken)
    {
        try
        {
            using var smtpClient = CreateSmtpClient();
            using var mailMessage = CreateMailMessage(context);

            await smtpClient.SendMailAsync(mailMessage);

            return ChannelResult.Success();
        }
        catch (Exception ex)
        {
            return ChannelResult.Failure(ex.Message);
        }
    }

    #endregion

    #region Private Methods

    private SmtpClient CreateSmtpClient()
    {
        var smtpClient = new SmtpClient(_smtpServer, _smtpPort)
        {
            EnableSsl = _enableSsl,
            Timeout = _timeoutMs
        };

        if (!string.IsNullOrWhiteSpace(_username) &&
            !string.IsNullOrWhiteSpace(_password))
        {
            smtpClient.Credentials = new NetworkCredential(_username, _password);
        }

        return smtpClient;
    }

    private MailMessage CreateMailMessage(NotificationContext context)
    {
        var mailMessage = new MailMessage
        {
            From = new MailAddress(_fromAddress, _fromName),
            Subject = context.Subject,
            Body = context.Body,
            IsBodyHtml = context.IsHtml,
            BodyEncoding = Encoding.UTF8,
            SubjectEncoding = Encoding.UTF8
        };

        foreach (var to in context.To)
        {
            mailMessage.To.Add(new MailAddress(to));
        }

        foreach (var cc in context.Cc)
        {
            mailMessage.CC.Add(new MailAddress(cc));
        }

        foreach (var bcc in context.Bcc)
        {
            mailMessage.Bcc.Add(new MailAddress(bcc));
        }

        return mailMessage;
    }

    #endregion

}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/Senders/InAppNotificationSender.cs">
#region using

using Common.ValueObjects;
using Notification.Application.Data.Repositories;
using Notification.Application.Models;
using Notification.Application.Strategy;
using Notification.Domain.Entities;
using Notification.Domain.Enums;

#endregion

namespace Notification.Infrastructure.Senders;

public sealed class InAppNotificationSender(ICommandNotificationRepository repository) : INotificationSender
{
    #region Fields, Properties and Indexers

    public ChannelType Channel => ChannelType.InApp;

    #endregion

    #region Methods

    public async Task<ChannelResult> SendAsync(NotificationContext context, CancellationToken cancellationToken)
    {
        try
        {
            foreach (var to in context.To)
            {
                var notification = NotificationEntity.Create(id: Guid.NewGuid(),
                    userId: Guid.Parse(to),
                    title: context.Subject!,
                    message: context.Body!,
                    performedBy: Actor.Worker(AppConstants.Service.Notification).ToString());

                if (!string.IsNullOrWhiteSpace(context.TargetUrl))
                {
                    notification.UpdateTargetUrl(context.TargetUrl!, Actor.Worker(AppConstants.Service.Notification).ToString());
                }

                await repository.UpsertAsync(notification, cancellationToken);
            }

            return ChannelResult.Success();
        }
        catch (Exception ex)
        {
            return ChannelResult.Failure(ex.Message);
        }
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/Services/KeycloakService.cs">
#region using

using AutoMapper;
using Microsoft.Extensions.Configuration;
using Notification.Application.Dtos.Keycloaks;
using Notification.Application.Services;
using Notification.Domain.Models.Externals.Keycloaks;
using Notification.Infrastructure.ApiClients;

#endregion

namespace Notification.Infrastructure.Services;

public sealed class KeycloakService(
    IKeycloakApi keycloakApi,
    IConfiguration cfg,
    IMapper mapper) : IKeycloakService
{
    #region Implementations

    public async Task<List<KeycloakUserDto>> GetUsersAsync(CancellationToken cancellationToken = default)
    {
        var accessToken = await GetAccessTokenAsync(cancellationToken);
        var realm = cfg[$"{KeycloakApiCfg.Section}:{KeycloakApiCfg.Realm}"]!;

        var result = await keycloakApi.GetUsersAsync(
            realm: realm,
            bearerToken: $"Bearer {accessToken.AccessToken}");

        return mapper.Map<List<KeycloakUserDto>>(result);
    }

    public async Task<List<KeycloakUserDto>> GetUsersByRoleAsync(string role, CancellationToken cancellationToken = default)
    {
        var accessToken = await GetAccessTokenAsync(cancellationToken);
        var realm = cfg[$"{KeycloakApiCfg.Section}:{KeycloakApiCfg.Realm}"]!;

        var result = await keycloakApi.GetUsersByRoleAsync(
            realm: realm,
            role: role,
            bearerToken: $"Bearer {accessToken.AccessToken}");

        return mapper.Map<List<KeycloakUserDto>>(result);
    }

    #endregion

    #region Methods

    private async Task<KeycloakAccessToken> GetAccessTokenAsync(CancellationToken cancellationToken)
    {
        var realm = cfg[$"{KeycloakApiCfg.Section}:{KeycloakApiCfg.Realm}"]!;
        var clientId = cfg[$"{KeycloakApiCfg.Section}:{KeycloakApiCfg.ClientId}"]!;
        var clientSecret = cfg[$"{KeycloakApiCfg.Section}:{KeycloakApiCfg.ClientSecret}"]!;
        var grantType = cfg[$"{KeycloakApiCfg.Section}:{KeycloakApiCfg.GrantType}"]!;
        var scopes = cfg.GetRequiredSection($"{KeycloakApiCfg.Section}:{KeycloakApiCfg.Scopes}")
            .Get<string[]>() ?? throw new ArgumentNullException($"{KeycloakApiCfg.Section}:{KeycloakApiCfg.Scopes}");

        var form = new Dictionary<string, string>
        {
            { "client_id", clientId },
            { "client_secret", clientSecret },
            { "grant_type", grantType },
            { "scope", string.Join(" ", scopes) }
        };

        return await keycloakApi.GetAccessTokenAsync(realm, form);
    }

    #endregion
}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/DependencyInjection.cs">
#region using

using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using MongoDB.Driver;
using Notification.Application.Providers;
using Notification.Application.Strategy;
using Notification.Infrastructure.ApiClients;
using Notification.Infrastructure.Data.Extensions;
using Notification.Infrastructure.Providers;
using Notification.Infrastructure.Resolvers;
using Refit;

#endregion

namespace Notification.Infrastructure;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddInfrastructureServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("NotificationSender")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Append)
            .AsImplementedInterfaces()
            .WithTransientLifetime());

        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Service")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithScopedLifetime());

        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Repository")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithSingletonLifetime());

        // DbContext
        {
            var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];
            var dbName = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DatabaseName}"];

            services.AddSingleton<IMongoClient>(sp =>
            {
                var settings = MongoClientSettings.FromConnectionString(conn);
                return new MongoClient(settings);
            });
            services.AddSingleton<IMongoDatabase>(sp =>
            {
                return sp.GetRequiredService<IMongoClient>().GetDatabase(dbName);
            });
        }

        services.AddSingleton<ITemplateProvider, TemplateProvider>();
        services.AddScoped<INotificationSenderResolver, NotificationChannelResolver>();
        services.AddRefitClients(cfg);

        return services;
    }

    public static WebApplication UseInfrastructure(this WebApplication app)
    {
        app.EnsureIndexesAsync().GetAwaiter();
        app.InitialiseDatabaseAsync().GetAwaiter();

        return app;
    }

    #endregion

    #region Private Methods

    public static IServiceCollection AddRefitClients(this IServiceCollection services, IConfiguration cfg)
    {
        // HTTP Clients
        services.AddRefitClient<IKeycloakApi>()
                .ConfigureHttpClient(c =>
                {
                    c.BaseAddress = new Uri(cfg[$"{KeycloakApiCfg.Section}:{KeycloakApiCfg.BaseUrl}"]!);
                    c.Timeout = TimeSpan.FromSeconds(30);
                });

        services.AddRefitClient<IDiscordApi>()
                .ConfigureHttpClient(c =>
                {
                    c.BaseAddress = new Uri(cfg[$"{NotificationCfg.DiscordSettings.Section}:{NotificationCfg.DiscordSettings.BaseUrl}"]!);
                    c.Timeout = TimeSpan.FromSeconds(30);
                });

        return services;
    }

    #endregion 
}
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/GlobalUsing.cs">
global using Common.Configurations;
global using Common.Constants;
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/InfrastructureMarker.cs">
namespace Notification.Infrastructure;

public sealed class InfrastructureMarker { }
</file>

<file path="Services/Notification/Core/Notification.Infrastructure/Notification.Infrastructure.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="Scrutor" />
    <PackageReference Include="MongoDB.Driver" />
    <PackageReference Include="Refit.HttpClientFactory" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\Notification.Application\Notification.Application.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Notification/Worker/Notification.Worker.Consumer/BackgroundServices/NotificationBackgroundService.cs">
namespace Notification.Worker.Consumer.BackgroundServices;

public sealed class NotificationBackgroundService(ILogger<NotificationBackgroundService> logger) : BackgroundService
{
    #region Overide Methods

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        logger.LogInformation("Worker starting at: {time}", DateTimeOffset.Now);

        while (!stoppingToken.IsCancellationRequested)
        {
            await Task.Delay(1000, stoppingToken);
        }

        logger.LogInformation("Worker stoping at: {time}", DateTimeOffset.Now);
    }

    #endregion
}
</file>

<file path="Services/Notification/Worker/Notification.Worker.Consumer/EventHandlers/Integrations/UpsertedProductIntegrationEventHandler.cs">
#region using

using EventSourcing.Events.Catalog;
using MassTransit;
using MediatR;
using Notification.Application.Features.Delivery.Commands;
using Notification.Application.Dtos.Deliveries;
using Notification.Application.Constants;
using Notification.Domain.Enums;
using Common.ValueObjects;
using Common.Constants;
using Common.Extensions;
using Notification.Application.Services;
using Common.Configurations;

#endregion

namespace Notification.Worker.Consumer.EventHandlers.Integrations;

public sealed class UpsertedProductIntegrationEventHandler(
    ISender sender,
    IKeycloakService keycloak,
    IConfiguration cfg,
    ILogger<UpsertedProductIntegrationEventHandler> logger)
    : IConsumer<UpsertedProductIntegrationEvent>
{
    #region Methods

    public async Task Consume(ConsumeContext<UpsertedProductIntegrationEvent> context)
    {
        logger.LogInformation("Integration Event handled: {IntegrationEvent}", context.Message.GetType().Name);

        var webAdminUrl = cfg.GetValue<string>($"{AppDomainCfg.Section}:{AppDomainCfg.WebAdminUrl}");
        var integrationEvent = context.Message;
        var templateVariables = new Dictionary<string, object>
        {
            { TemplateVariables.ProductName, integrationEvent.Name },
            { TemplateVariables.PerformBy, integrationEvent.LastModifiedBy! }
        };

        var deliveryDto = new CreateDeliveryDto
        {
            EventId = integrationEvent.Id,
            TemplateKey = TemplateKey.ProductUpserted,
            ChannelType = ChannelType.Discord,
            To = [ChannelType.Discord.GetDescription()],
            TemplateVariables = templateVariables,
            Priority = DeliveryPriority.Medium,
            MaxAttempts = AppConstants.MaxAttempts,
            TargetUrl = $"/products/{integrationEvent.ProductId}"
        };

        var deliveryCommand = new CreateDeliveryCommand(deliveryDto, Actor.Worker(AppConstants.Service.Notification));

        await sender.Send(deliveryCommand, context.CancellationToken);

        var adminUsers = await keycloak.GetUsersByRoleAsync(AuthorizeRole.SystemAdmin, context.CancellationToken);

        if (!adminUsers.Any())
        {
            logger.LogWarning("No admin users found to notify for product upserted event: {ProductId}", integrationEvent.ProductId);
            return;
        }

        deliveryDto.To.Clear();
        deliveryDto.EventId = Guid.NewGuid().ToString();
        deliveryDto.ChannelType = ChannelType.Email;
        deliveryDto.To.AddRange(adminUsers.Select(x => x.Email!));

        var adminDeliveryEmailCommand = new CreateDeliveryCommand(deliveryDto, Actor.Worker(AppConstants.Service.Notification));
        await sender.Send(adminDeliveryEmailCommand, context.CancellationToken);

        deliveryDto.To.Clear();
        deliveryDto.EventId = Guid.NewGuid().ToString();
        deliveryDto.ChannelType = ChannelType.InApp;
        deliveryDto.To.AddRange(adminUsers.Select(x => x.Id!));

        var adminDeliveryInAppCommand = new CreateDeliveryCommand(deliveryDto, Actor.Worker(AppConstants.Service.Notification));
        await sender.Send(adminDeliveryInAppCommand, context.CancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Notification/Worker/Notification.Worker.Consumer/DependencyInjection.cs">
#region using

using BuildingBlocks.Logging;
using EventSourcing.MassTransit;
using System.Reflection;

#endregion

namespace Notification.Worker.Consumer;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddWorkerServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddSerilogLogging(cfg);
        services.AddMessageBroker(cfg, Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Notification/Worker/Notification.Worker.Consumer/Notification.Worker.Consumer.csproj">
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <PropertyGroup>
    <UserSecretsId>dotnet-Worker-6389e6be-04ba-4aab-bf03-b4113be1dbd1</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Notification.Application\Notification.Application.csproj" />
    <ProjectReference Include="..\..\Core\Notification.Infrastructure\Notification.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Notification/Worker/Notification.Worker.Consumer/Program.cs">
#region using

using Notification.Application;
using Notification.Infrastructure;
using Notification.Worker.Consumer;
using Notification.Worker.Consumer.BackgroundServices;

#endregion

var builder = Host.CreateApplicationBuilder(args);

builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddWorkerServices(builder.Configuration)
    .AddHostedService<NotificationBackgroundService>();

var host = builder.Build();
host.Run();
</file>

<file path="Services/Notification/Worker/Notification.Worker.Processor/DependencyInjection.cs">
#region using

using BuildingBlocks.Logging;
using EventSourcing.MassTransit;
using System.Reflection;

#endregion

namespace Notification.Worker.Processor;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddWorkerServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddSerilogLogging(cfg);
        services.AddMessageBroker(cfg, Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Notification/Worker/Notification.Worker.Processor/Notification.Worker.Processor.csproj">
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <PropertyGroup>
    <UserSecretsId>dotnet-Worker-6389e6be-04ba-4aab-bf03-b4113be1dbd1</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\..\Core\Notification.Application\Notification.Application.csproj" />
    <ProjectReference Include="..\..\Core\Notification.Infrastructure\Notification.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Notification/Worker/Notification.Worker.Processor/Program.cs">
#region using

using Notification.Application;
using Notification.Infrastructure;
using Notification.Worker.Processor;

#endregion

var builder = Host.CreateApplicationBuilder(args);

builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddWorkerServices(builder.Configuration)
    .AddHostedService<Worker>();

var host = builder.Build();
host.Run();
</file>

<file path="Services/Notification/Worker/Notification.Worker.Processor/Worker.cs">
#region using

using Notification.Application.Features.Delivery.Commands;
using Notification.Application.Features.Delivery.Queries;
using Common.Configurations;
using Common.ValueObjects;
using MediatR;

#endregion

namespace Notification.Worker.Processor;

public sealed class Worker(
    IServiceScopeFactory serviceScopeFactory,
    IConfiguration cfg,
    ILogger<Worker> logger) : BackgroundService
{
    private const int ProcessorFrequency = 1;

    #region Overide Methods

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            using var scope = serviceScopeFactory.CreateScope();
            var sender = scope.ServiceProvider.GetRequiredService<ISender>();

            var now = DateTimeOffset.UtcNow;
            var batchSize = cfg.GetValue<int>($"{WorkerCfg.Proccessor.Section}:{WorkerCfg.Proccessor.BatchSize}", 100);
            var dueDiliveries = await sender.Send(new GetDueDeliveriesQuery(now, batchSize), stoppingToken);

            foreach (var doc in dueDiliveries)
            {
                try
                {
                    var actor = Actor.Worker("notification");
                    await sender.Send(new ProcessDeliveryCommand(doc.Id, actor), stoppingToken);
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Unhandled error occurred while processing DeliveryId={DeliveryId}", doc.Id);
                }
            }

            await Task.Delay(TimeSpan.FromSeconds(ProcessorFrequency), stoppingToken);
        }
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Api/Constants/ApiRoutes.cs">
namespace Order.Api.Constants;

public sealed class ApiRoutes
{
    public static class Order
    {
        #region Constants

        public const string Tags = "Orders";

        private const string Base = "/orders";

        private const string BaseAdmin = "/admin/orders";

        public const string Create = $"{BaseAdmin}";

        public const string Update = $"{BaseAdmin}/{{orderId}}";

        public const string GetOrders = $"{BaseAdmin}";

        public const string GetAllOrders = $"{BaseAdmin}/all";

        public const string GetOrderById = $"{BaseAdmin}/{{orderId}}";

        public const string UpdateOrderStatus = $"{BaseAdmin}/{{orderId}}/status";

        public const string GetOrderByOrderNo = $"{Base}/by-order-no/{{orderNo}}";

        public const string GetOrdersByCurrentUser = $"{Base}/me";

        public const string GetAllMyOrders = $"{Base}/me/all";

        public const string GetMyOrderById = $"{Base}/me/{{orderId}}";

        #endregion
    }
}
</file>

<file path="Services/Order/Api/Order.Api/Endpoints/CreateOrder.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Microsoft.AspNetCore.Mvc;
using Order.Api.Constants;
using Order.Application.Features.Order.Commands;
using Order.Application.Dtos.Orders;

#endregion

namespace Order.Api.Endpoints;

public sealed class CreateOrder : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost(ApiRoutes.Order.Create, HandleCreateOrderAsync)
            .WithTags(ApiRoutes.Order.Tags)
            .WithName(nameof(CreateOrder))
            .Produces<ApiCreatedResponse<Guid>>(StatusCodes.Status201Created)
            .Produces(StatusCodes.Status401Unauthorized)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .ProducesProblem(StatusCodes.Status422UnprocessableEntity)
            .ProducesProblem(StatusCodes.Status500InternalServerError)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiCreatedResponse<Guid>> HandleCreateOrderAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromBody] CreateOrUpdateOrderDto dto)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new CreateOrderCommand(dto, Actor.User(currentUser.Email));
        var result = await sender.Send(command);

        return new ApiCreatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Api/Endpoints/GetAllMyOrders.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Order.Api.Constants;
using Order.Application.Features.Order.Queries;
using Order.Application.Models.Filters;
using Order.Application.Models.Results;

#endregion

namespace Order.Api.Endpoints;

public sealed class GetAllMyOrders : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Order.GetAllMyOrders, HandleGetAllMyOrdersAsync)
            .WithTags(ApiRoutes.Order.Tags)
            .WithName(nameof(GetAllMyOrders))
            .Produces<ApiGetResponse<GetAllMyOrdersResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetAllMyOrdersResult>> HandleGetAllMyOrdersAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [AsParameters] GetMyOrdersFilter filter)
    {
        var currentUser = httpContext.GetCurrentUser();
        var query = new GetAllMyOrdersQuery(filter, Actor.User(currentUser.Id));
        var result = await sender.Send(query);

        return new ApiGetResponse<GetAllMyOrdersResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Api/Endpoints/GetAllOrders.cs">
#region using

using Order.Api.Constants;
using Order.Application.Features.Order.Queries;
using Order.Application.Models.Filters;
using Order.Application.Models.Results;

#endregion

namespace Order.Api.Endpoints;

public sealed class GetAllOrders : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Order.GetAllOrders, HandleGetAllOrdersAsync)
            .WithTags(ApiRoutes.Order.Tags)
            .WithName(nameof(GetAllOrders))
            .Produces<ApiGetResponse<GetAllOrdersResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetAllOrdersResult>> HandleGetAllOrdersAsync(
        ISender sender,
        [AsParameters] GetAllOrdersFilter filter)
    {
        var query = new GetAllOrdersQuery(filter);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetAllOrdersResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Api/Endpoints/GetMyOrderById.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Order.Api.Constants;
using Order.Application.Features.Order.Queries;
using Order.Application.Models.Results;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Order.Api.Endpoints;

public sealed class GetMyOrderById : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Order.GetMyOrderById, HandleGetMyOrderByIdAsync)
            .WithTags(ApiRoutes.Order.Tags)
            .WithName(nameof(GetMyOrderById))
            .Produces<ApiGetResponse<GetMyOrderByIdResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetMyOrderByIdResult>> HandleGetMyOrderByIdAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromRoute] Guid orderId)
    {
        var currentUser = httpContext.GetCurrentUser();
        var query = new GetMyOrderByIdQuery(orderId, Actor.User(currentUser.Id));
        var result = await sender.Send(query);

        return new ApiGetResponse<GetMyOrderByIdResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Api/Endpoints/GetMyOrders.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Order.Api.Constants;
using Order.Application.Features.Order.Queries;
using Order.Application.Models.Filters;
using Order.Application.Models.Results;
using Common.Models;

#endregion

namespace Order.Api.Endpoints;

public sealed class GetMyOrders : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Order.GetOrdersByCurrentUser, HandleGetMyOrdersAsync)
            .WithTags(ApiRoutes.Order.Tags)
            .WithName(nameof(GetMyOrders))
            .Produces<ApiGetResponse<GetMyOrdersResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetMyOrdersResult>> HandleGetMyOrdersAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [AsParameters] GetMyOrdersFilter filter,
        [AsParameters] PaginationRequest paging)
    {
        var currentUser = httpContext.GetCurrentUser();
        var query = new GetMyOrdersQuery(filter, paging, Actor.User(currentUser.Id));
        var result = await sender.Send(query);

        return new ApiGetResponse<GetMyOrdersResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Api/Endpoints/GetOrderById.cs">
#region using

using Order.Api.Constants;
using Order.Application.Features.Order.Queries;
using Order.Application.Models.Results;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Order.Api.Endpoints;

public sealed class GetOrderById : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Order.GetOrderById, HandleGetOrderByIdAsync)
            .WithTags(ApiRoutes.Order.Tags)
            .WithName(nameof(GetOrderById))
            .Produces<ApiGetResponse<GetOrderByIdResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetOrderByIdResult>> HandleGetOrderByIdAsync(
        ISender sender,
        [FromRoute] Guid orderId)
    {
        var query = new GetOrderByIdQuery(orderId);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetOrderByIdResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Api/Endpoints/GetOrderByOrderNo.cs">
#region using

using Order.Api.Constants;
using Order.Application.Features.Order.Queries;
using Order.Application.Models.Results;
using Microsoft.AspNetCore.Mvc;

#endregion

namespace Order.Api.Endpoints;

public sealed class GetOrderByOrderNo : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Order.GetOrderByOrderNo, HandleGetOrderByOrderNoAsync)
            .WithTags(ApiRoutes.Order.Tags)
            .WithName(nameof(GetOrderByOrderNo))
            .Produces<ApiGetResponse<GetOrderByOrderNoResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetOrderByOrderNoResult>> HandleGetOrderByOrderNoAsync(
        ISender sender,
        [FromRoute] string orderNo)
    {
        var query = new GetOrderByOrderNoQuery(orderNo);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetOrderByOrderNoResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Api/Endpoints/GetOrders.cs">
#region using

using Common.Models;
using Order.Api.Constants;
using Order.Application.Features.Order.Queries;
using Order.Application.Models.Filters;
using Order.Application.Models.Results;

#endregion

namespace Order.Api.Endpoints;

public sealed class GetOrders : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Order.GetOrders, HandleGetOrdersAsync)
            .WithTags(ApiRoutes.Order.Tags)
            .WithName(nameof(GetOrders))
            .Produces<ApiGetResponse<GetOrdersResult>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<GetOrdersResult>> HandleGetOrdersAsync(
        ISender sender,
        [AsParameters] GetOrdersFilter filter,
        [AsParameters] PaginationRequest paging)
    {
        var query = new GetOrdersQuery(filter, paging);
        var result = await sender.Send(query);

        return new ApiGetResponse<GetOrdersResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Api/Endpoints/UpdateOrder.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Microsoft.AspNetCore.Mvc;
using Order.Api.Constants;
using Order.Application.Features.Order.Commands;
using Order.Application.Dtos.Orders;

#endregion

namespace Order.Api.Endpoints;

public class UpdateOrder : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPut(ApiRoutes.Order.Update, HandleUpdateOrderAsync)
            .WithTags(ApiRoutes.Order.Tags)
            .WithName(nameof(UpdateOrder))
            .Produces<ApiUpdatedResponse<Guid>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<Guid>> HandleUpdateOrderAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromRoute] Guid orderId,
        [FromBody] CreateOrUpdateOrderDto dto)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new UpdateOrderCommand(orderId, dto, Actor.User(currentUser.Email));
        var result = await sender.Send(command);

        return new ApiUpdatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Api/Endpoints/UpdateOrderStatus.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using Microsoft.AspNetCore.Mvc;
using Order.Api.Constants;
using Order.Api.Models;
using Order.Application.Features.Order.Commands;

#endregion

namespace Order.Api.Endpoints;

public sealed class UpdateOrderStatus : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPatch(ApiRoutes.Order.UpdateOrderStatus, HandleUpdateOrderStatusAsync)
            .WithTags(ApiRoutes.Order.Tags)
            .WithName(nameof(UpdateOrderStatus))
            .Produces<ApiUpdatedResponse<Guid>>(StatusCodes.Status200OK)
            .Produces(StatusCodes.Status401Unauthorized)
            .Produces(StatusCodes.Status403Forbidden)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiUpdatedResponse<Guid>> HandleUpdateOrderStatusAsync(
        ISender sender,
        IHttpContextAccessor httpContext,
        [FromRoute] Guid orderId,
        [FromBody] UpdateOrderStatusRequest request)
    {
        var currentUser = httpContext.GetCurrentUser();
        var command = new UpdateOrderStatusCommand(
            orderId,
            request.Status,
            request.Reason,
            Actor.User(currentUser.Email));
        var result = await sender.Send(command);

        return new ApiUpdatedResponse<Guid>(result);
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Api/Models/UpdateOrderStatusRequest.cs">
#region using

using Order.Domain.Enums;

#endregion

namespace Order.Api.Models;

public sealed class UpdateOrderStatusRequest
{
    #region Fields, Properties and Indexers

    public OrderStatus Status { get; set; }

    public string? Reason { get; set; }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Api/DependencyInjection.cs">
#region using

using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using BuildingBlocks.Swagger.Extensions;
using HealthChecks.UI.Client;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Common.Configurations;
using Common.Constants;
using BuildingBlocks.Authentication.Extensions;

#endregion

namespace Order.Api;

public static class DependencyInjection
{
    public static IServiceCollection AddApiServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services.AddCarter();

        // HealthChecks
        {
            var dbype = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DbType}"];
            var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];

            switch (dbype)
            {
                case DatabaseType.SqlServer:
                    services.AddHealthChecks()
                        .AddSqlServer(connectionString: conn!);
                    break;
                case DatabaseType.MySql:
                    services.AddHealthChecks()
                        .AddMySql(connectionString: conn!);
                    break;
                case DatabaseType.PostgreSql:
                    services.AddHealthChecks()
                        .AddNpgSql(connectionString: conn!);
                    break;
                //case "MONGO":
                //    services.AddHealthChecks()
                //        .AddMongoDb(connectionString: writeConn!, name: "wirte_db")
                //        .AddMongoDb(connectionString: readConn!, name: "read_db");
                //    break;
                default:
                    throw new Exception("Unsupported database type");
            }
        }

        services.AddHttpContextAccessor();
        services.AddAuthenticationAndAuthorization(cfg);
        services.AddSwaggerServices(cfg);

        return services;
    }

    public static WebApplication UseApi(this WebApplication app)
    {
        app.UseSerilogReqLogging();
        app.UsePrometheusEndpoint();
        app.MapCarter();
        app.UseExceptionHandler(options => { });
        app.UseHealthChecks("/health",
            new HealthCheckOptions
            {
                ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
            });

        app.UseAuthentication();
        app.UseAuthorization();
        app.UseSwaggerApi();

        app.MapGet("/", (IWebHostEnvironment env) => new ApiDefaultPathResponse
        {
            Service = "Order.Api",
            Status = "Running",
            Timestamp = DateTimeOffset.UtcNow,
            Environment = env.EnvironmentName,
            Endpoints = new Dictionary<string, string>
            {
                { "health", "/health" }
            },
            Message = "API is running..."
        });

        return app;
    }
}
</file>

<file path="Services/Order/Api/Order.Api/GlobalUsing.cs">
global using Carter;
global using MediatR;
global using Common.ValueObjects;
global using Common.Models.Reponses;
</file>

<file path="Services/Order/Api/Order.Api/Order.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <UserSecretsId>68beccec-977d-4711-a7f7-5d8d06e5c2e0</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="AspNetCore.HealthChecks.MongoDb" />
    <PackageReference Include="AspNetCore.HealthChecks.MySql" />
    <PackageReference Include="AspNetCore.HealthChecks.NpgSql" />
    <PackageReference Include="AspNetCore.HealthChecks.Redis" />
    <PackageReference Include="AspNetCore.HealthChecks.SqlServer" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" />
    <PackageReference Include="Carter" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Order.Application\Order.Application.csproj" />
    <ProjectReference Include="..\..\Core\Order.Infrastructure\Order.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Order/Api/Order.Api/Program.cs">
#region using

using Order.Api;
using Order.Application;
using Order.Infrastructure;

#endregion

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddApiServices(builder.Configuration);

var app = builder.Build();

// Configure the HTTP request pipeline.
app.UseApi();
app.UseInfrastructure();

app.Run();
</file>

<file path="Services/Order/Api/Order.Grpc/Interceptors/ApiKeyValidationInterceptor.cs">
#region using

using Common.Configurations;
using Common.Constants;
using Grpc.Core;
using Grpc.Core.Interceptors;

#endregion

namespace Order.Grpc.Interceptors;

public class ApiKeyValidationInterceptor(IConfiguration cfg) : Interceptor
{
    #region Methods

    public override async Task<TResponse> UnaryServerHandler<TRequest, TResponse>(
        TRequest request,
        ServerCallContext context,
        UnaryServerMethod<TRequest, TResponse> continuation)
    {
        var provided = context.RequestHeaders.FirstOrDefault(h => h.Key == ReqHeaderName.GrpcKey)?.Value;
        var grpcKey = cfg.GetValue<string>($"{AppConfigCfg.Section}:{AppConfigCfg.GrpcApiKey}");

        if (string.IsNullOrEmpty(provided) || !TimeConstantEquals(provided, grpcKey!))
        {
            throw new RpcException(new Status(StatusCode.Unauthenticated, MessageCode.Unauthorized));
        }

        return await continuation(request, context);
    }

    // Constant-time comparison to mitigate timing attacks (micro-optimization).
    private static bool TimeConstantEquals(string a, string b)
    {
        if (a.Length != b.Length) return false;
        var diff = 0;
        for (int i = 0; i < a.Length; i++)
            diff |= a[i] ^ b[i];
        return diff == 0;
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Grpc/Services/OrderGrpcService.cs">
#region using

using Google.Protobuf.WellKnownTypes;
using Grpc.Core;
using MediatR;
using Order.Application.Features.Order.Queries;
using Order.Application.Models.Filters;

#endregion

namespace Order.Grpc.Services;

public sealed class OrderGrpcService(ISender sender) : OrderGrpc.OrderGrpcBase
{
    #region Methods

    public override async Task<GetOrdersByMonthResponse> GetOrdersByMonth(GetOrdersByMonthRequest request, ServerCallContext context)
    {
        var query = new GetOrderByMonthQuery(request.Year, request.Month);
        var result = await sender.Send(query, context.CancellationToken);

        var response = new GetOrdersByMonthResponse();

        foreach (var orderDto in result.Items)
        {
            var order = new Order
            {
                Id = orderDto.Id.ToString(),
                TotalPrice = (double)orderDto.TotalPrice,
                FinalPrice = (double)orderDto.FinalPrice,
                CreatedOnUtc = Timestamp.FromDateTimeOffset(orderDto.CreatedOnUtc)
            };

            foreach (var orderItemDto in orderDto.OrderItems)
            {
                var orderItem = new OrderItem
                {
                    Quantity = orderItemDto.Quantity,
                    Product = new Product
                    {
                        Id = orderItemDto.Product.Id.ToString(),
                        Name = orderItemDto.Product.Name,
                        Price = (double)orderItemDto.Product.Price
                    }
                };

                order.OrderItems.Add(orderItem);
            }

            response.Orders.Add(order);
        }

        return response;
    }

    public override async Task<GetAllOrdersResponse> GetAllOrders(GetAllOrdersRequest request, ServerCallContext context)
    {
        var query = new GetAllOrdersQuery(new GetAllOrdersFilter());
        var result = await sender.Send(query, context.CancellationToken);

        var response = new GetAllOrdersResponse();

        foreach (var orderDto in result.Items)
        {
            var order = new Order
            {
                Id = orderDto.Id.ToString(),
                TotalPrice = (double)orderDto.TotalPrice,
                FinalPrice = (double)orderDto.FinalPrice,
                CreatedOnUtc = Timestamp.FromDateTimeOffset(orderDto.CreatedOnUtc)
            };

            foreach (var orderItemDto in orderDto.OrderItems)
            {
                var orderItem = new OrderItem
                {
                    Quantity = orderItemDto.Quantity,
                    Product = new Product
                    {
                        Id = orderItemDto.Product.Id.ToString(),
                        Name = orderItemDto.Product.Name,
                        Price = (double)orderItemDto.Product.Price
                    }
                };

                order.OrderItems.Add(orderItem);
            }

            response.Orders.Add(order);
        }

        return response;
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Grpc/DependencyInjection.cs">
#region using

using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using Order.Grpc.Interceptors;

#endregion

namespace Order.Grpc;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddGrpcServices(
       this IServiceCollection services,
       IConfiguration cfg)
    {
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services
            .AddGrpc(o =>
            {
                o.Interceptors.Add<ApiKeyValidationInterceptor>();
            })
            .AddJsonTranscoding();
        services.AddSingleton<ApiKeyValidationInterceptor>();

        return services;
    }

    #endregion
}
</file>

<file path="Services/Order/Api/Order.Grpc/Order.Grpc.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <ItemGroup>
    <Protobuf Include="..\..\..\..\Shared\Contracts\Order.Contract\Protos\order.proto" GrpcServices="Server" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="grpc.tools">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="microsoft.aspnetcore.grpc.jsontranscoding" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Contracts\Order.Contract\Order.Contract.csproj" />
    <ProjectReference Include="..\..\Core\Order.Application\Order.Application.csproj" />
    <ProjectReference Include="..\..\Core\Order.Infrastructure\Order.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Order/Api/Order.Grpc/Program.cs">
#region using

using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using Order.Application;
using Order.Grpc;
using Order.Grpc.Services;
using Order.Infrastructure;

#endregion

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddGrpcServices(builder.Configuration);

var app = builder.Build();

app.UseSerilogReqLogging();
app.UsePrometheusEndpoint();

app.MapGrpcService<OrderGrpcService>();
app.MapGet("/", () => "Order gRPC is running...");

app.Run();
</file>

<file path="Services/Order/Core/Order.Application/Constants/KeycloakUserAttributes.cs">
namespace Order.Application.Constants;

public sealed class KeycloakUserAttributes
{
    #region Constants

    public const string PhoneNumber = "phoneNumber";

    public const string FirstName = "firstName";

    public const string LastName = "lastName";

    public const string Password = "password";

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Constants/KeycloakUserEvent.cs">
namespace Order.Application.Constants;

public sealed class KeycloakUserEvent
{
    #region Constants

    public const string Created = "CREATED";

    public const string Updated = "UPDATED";

    public const string Deleted = "DELETED";

    public const string Login = "LOGIN";

    public const string Logout = "LOGOUT";

    public const string VerifyEmail = "VERIFY_EMAIL";

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Dtos/Abstractions/AuditableDto.cs">
namespace Order.Application.Dtos.Abstractions;

public abstract class AuditableDto : IAuditableDto
{
    #region Fields, Properties and Indexers

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}

public interface IAuditableDto : ICreationAuditDto, IModificationAuditDto { }
</file>

<file path="Services/Order/Core/Order.Application/Dtos/Abstractions/DtoId.cs">
namespace Order.Application.Dtos.Abstractions;

public class DtoId<T> : IDtoId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    #endregion
}

public interface IDtoId<T>
{
    T Id { get; init; }
}
</file>

<file path="Services/Order/Core/Order.Application/Dtos/Abstractions/EntityDto.cs">
namespace Order.Application.Dtos.Abstractions;

public abstract class EntityDto<T> : IDtoId<T>, IAuditableDto
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Dtos/Abstractions/ICreationAuditDto.cs">
namespace Order.Application.Dtos.Abstractions;

public interface ICreationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Dtos/Abstractions/IModificationAuditDto.cs">
namespace Order.Application.Dtos.Abstractions;

public interface IModificationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Order/Core/Order.Application/Dtos/Orders/CreateOrderItemDto.cs">
namespace Order.Application.Dtos.Orders;

public sealed class CreateOrderItemDto
{
    #region Fields, Properties and Indexers

    public Guid ProductId { get; set; }

    public int Quantity { get; set; }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Dtos/Orders/CreateOrUpdateOrderDto.cs">
#region using

using Order.Application.Dtos.ValueObjects;

#endregion

namespace Order.Application.Dtos.Orders;

public sealed class CreateOrUpdateOrderDto
{
    #region Fields, Properties and Indexers

    public Guid? BasketId { get; set; }

    public CustomerDto Customer { get; set; } = default!;

    public AddressDto ShippingAddress { get; set; } = default!;

    public List<CreateOrderItemDto> OrderItems { get; set; } = [];

    public string CouponCode { get; set; } = string.Empty;

    public string? Notes { get; set; }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Dtos/Orders/OrderDto.cs">
#region using

using Order.Application.Dtos.Abstractions;
using Order.Application.Dtos.ValueObjects;
using Order.Domain.Enums;

#endregion

namespace Order.Application.Dtos.Orders;

public class OrderDto : EntityDto<Guid>
{
    #region Fields, Properties and Indexers

    public string OrderNo { get; set; } = default!;

    public CustomerDto Customer { get; set; } = default!;

    public AddressDto ShippingAddress { get; set; } = default!;

    public List<OrderItemDto> OrderItems { get; set; } = new();

    public DiscountDto Discount { get; set; } = default!;

    public OrderStatus Status { get; set; } = default!;

    public string DisplayStatus { get; set; } = default!;

    public decimal TotalPrice { get; set; }

    public decimal FinalPrice { get; set; }

    public string? Notes { get; set; }

    public string? CancelReason { get; set; }

    public string? RefundReason { get; set; }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Dtos/Orders/OrderItemDto.cs">
using Order.Application.Dtos.ValueObjects;

namespace Order.Application.Dtos.Orders;

public class OrderItemDto
{
    #region Fields, Properties and Indexers

    public ProductDto Product { get; set; } = default!;

    public int Quantity { get; set; }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Dtos/ValueObjects/AddressDto.cs">
namespace Order.Application.Dtos.ValueObjects;

public class AddressDto
{
    #region Fields, Properties and Indexers

    public string AddressLine { get; set; } = default!;

    public string Subdivision { get; set; } = default!;

    public string City { get; set; } = default!;

    public string StateOrProvince { get; set; } = default!;

    public string Country { get; set; } = default!;

    public string PostalCode { get; set; } = default!;

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Dtos/ValueObjects/CustomerDto.cs">
namespace Order.Application.Dtos.ValueObjects;

public class CustomerDto
{
    #region Fields, Properties and Indexers

    public Guid? Id { get; set; }

    public string PhoneNumber { get; set; } = default!;

    public string Name { get; set; } = default!;

    public string Email { get; set; } = default!;

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Dtos/ValueObjects/DiscountDto.cs">
namespace Order.Application.Dtos.ValueObjects;

public class DiscountDto
{
    #region Fields, Properties and Indexers

    public string CouponCode { get; set; } = default!;

    public decimal DiscountAmount { get; set; }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Dtos/ValueObjects/ProductDto.cs">
#region using

using Order.Application.Dtos.Abstractions;

#endregion

namespace Order.Application.Dtos.ValueObjects;

public class ProductDto : DtoId<Guid>
{
    #region Fields, Properties and Indexers

    public string Name { get; set; } = default!;

    public string ImageUrl { get; set; } = default!;

    public decimal Price { get; set; } = default!;

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Exceptions/ApplicationException.cs">
namespace Order.Application.Exceptions;

public sealed class ApplicationException : Exception
{
    #region Ctors

    public ApplicationException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/Commands/CreateOrderCommand.cs">
#region using

using Order.Application.Dtos.Orders;
using Order.Domain.Abstractions;
using Order.Domain.Entities;
using Order.Domain.ValueObjects;
using Order.Application.Services;

#endregion

namespace Order.Application.Features.Order.Commands;

public sealed record CreateOrderCommand(CreateOrUpdateOrderDto Dto, Actor Actor) : ICommand<Guid>;

public sealed class CreateOrderCommandValidator : AbstractValidator<CreateOrderCommand>
{
    #region Ctors

    public CreateOrderCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Customer)
                    .NotNull()
                    .WithMessage(MessageCode.BadRequest)
                    .DependentRules(() =>
                    {
                        RuleFor(x => x.Dto.Customer.Name)
                            .NotEmpty()
                            .WithMessage(MessageCode.NameIsRequired);

                        RuleFor(x => x.Dto.Customer.Email)
                            .NotEmpty()
                            .WithMessage(MessageCode.EmailIsRequired)
                            .EmailAddress()
                            .WithMessage(MessageCode.InvalidEmailAddress);

                        RuleFor(x => x.Dto.Customer.PhoneNumber)
                            .NotEmpty()
                            .WithMessage(MessageCode.PhoneNumberIsRequired)
                            .IsValidPhoneNumber()
                            .WithMessage(MessageCode.InvalidPhoneNumber);
                    });

                RuleFor(x => x.Dto.ShippingAddress)
                    .NotNull()
                    .WithMessage(MessageCode.BadRequest)
                    .DependentRules(() =>
                    {
                        RuleFor(x => x.Dto.ShippingAddress.AddressLine)
                            .NotEmpty()
                            .WithMessage(MessageCode.AddressLineIsRequired);

                        RuleFor(x => x.Dto.ShippingAddress.Subdivision)
                            .NotEmpty()
                            .WithMessage(MessageCode.SubdivisionIsRequired);

                        RuleFor(x => x.Dto.ShippingAddress.City)
                            .NotEmpty()
                            .WithMessage(MessageCode.CityIsRequired);

                        RuleFor(x => x.Dto.ShippingAddress.StateOrProvince)
                            .NotEmpty()
                            .WithMessage(MessageCode.StateOrProvinceIsRequired);

                        RuleFor(x => x.Dto.ShippingAddress.Country)
                            .NotEmpty()
                            .WithMessage(MessageCode.CountryIsRequired);

                        RuleFor(x => x.Dto.ShippingAddress.PostalCode)
                            .NotEmpty()
                            .WithMessage(MessageCode.PostalCodeIsRequired);
                    });

                RuleFor(x => x.Dto.OrderItems)
                    .NotNull()
                    .WithMessage(MessageCode.BadRequest)
                    .Must(items => items != null && items.Count > 0)
                    .WithMessage(MessageCode.OrderItemsIsRequired)
                    .DependentRules(() =>
                    {
                        RuleForEach(x => x.Dto.OrderItems).ChildRules(item =>
                        {
                            item.RuleFor(i => i.ProductId)
                                .NotEmpty()
                                .WithMessage(MessageCode.ProductIdIsRequired);

                            item.RuleFor(i => i.Quantity)
                                .GreaterThan(0)
                                .WithMessage(MessageCode.QuantityCannotBeNegative);
                        });
                    });
            });

    }

    #endregion
}

public sealed class CreateOrderCommandHandler(IUnitOfWork unitOfWork, ICatalogGrpcService catalogGrpc, IDiscountGrpcService discountGrpc) : ICommandHandler<CreateOrderCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(CreateOrderCommand command, CancellationToken cancellationToken)
    {
        var dto = command.Dto;
        var orderId = Guid.NewGuid();
        var orderNo = OrderNo.Create();

        var customer = Customer.Of(
            dto.Customer.Id,
            dto.Customer.PhoneNumber,
            dto.Customer.Name,
            dto.Customer.Email);

        var shippingAddress = Address.Of(
            dto.ShippingAddress.AddressLine,
            dto.ShippingAddress.Subdivision,
            dto.ShippingAddress.City,
            dto.ShippingAddress.Country,
            dto.ShippingAddress.StateOrProvince,
            dto.ShippingAddress.PostalCode);

        var order = OrderEntity.Create(id: orderId,
            notes: dto.Notes,
            customer: customer,
            orderNo: orderNo,
            shippingAddress: shippingAddress,
            performedBy: command.Actor.ToString());
        var productIds = dto.OrderItems.Select(x => x.ProductId.ToString()).ToArray();

        var productsResponse = await catalogGrpc.GetAllAvailableProductsAsync(cancellationToken: cancellationToken);

        if (productsResponse == null || productsResponse.Items == null || productsResponse.Items.Count == 0)
        {
            throw new ClientValidationException(MessageCode.ProductsIsNotExistsOrNotInStock);
        }

        foreach (var item in dto.OrderItems)
        {
            var productInfo = productsResponse.Items.FirstOrDefault(x => x.Id == item.ProductId)
                ?? throw new ClientValidationException(MessageCode.ProductIsNotExistsOrNotInStock, item.ProductId);

            var product = Product.Of(
                productInfo.Id,
                productInfo.Name,
                productInfo.Price,
                productInfo.Thumbnail);

            order.AddOrderItem(product, item.Quantity);
        }

        decimal discountAmt = 0m;
        string couponCode = string.Empty;

        if (!string.IsNullOrWhiteSpace(dto.CouponCode))
        {

            decimal amount = 0m;

            foreach (var item in dto.OrderItems)
            {
                var productInfo = productsResponse.Items.FirstOrDefault(x => x.Id == item.ProductId)
                    ?? throw new ClientValidationException(MessageCode.ProductIsNotExists, item.ProductId);

                amount += (item.Quantity * productInfo.Price);
            }

            var discountResult = await discountGrpc.EvaluateCouponAsync(dto.CouponCode, amount)
                ?? throw new ClientValidationException(MessageCode.CouponCodeIsNotExistsOrExpired);

            discountAmt = discountResult.DiscountAmount;
            couponCode = discountResult.CouponCode;

            await discountGrpc.ApplyCouponAsync(dto.CouponCode, amount);
        }

        var discount = Discount.Of(couponCode, discountAmt);
        order.ApplyDiscount(discount);
        order.OrderCreated();

        await unitOfWork.Orders.AddAsync(order, cancellationToken);
        await unitOfWork.SaveChangesAsync(cancellationToken);

        return order.Id;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/Commands/UpdateOrderCommand.cs">
#region using

using Order.Application.Dtos.Orders;
using Order.Application.Services;
using Order.Domain.Abstractions;
using Order.Domain.Enums;
using Order.Domain.ValueObjects;

#endregion

namespace Order.Application.Features.Order.Commands;

public sealed record UpdateOrderCommand(Guid OrderId, CreateOrUpdateOrderDto Dto, Actor Actor) : ICommand<Guid>;

public sealed class UpdateOrderCommandValidator : AbstractValidator<UpdateOrderCommand>
{
    #region Ctors

    public UpdateOrderCommandValidator()
    {
        RuleFor(x => x.OrderId)
            .NotEmpty()
            .WithMessage(MessageCode.BadRequest);

        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Customer)
                    .NotNull()
                    .WithMessage(MessageCode.BadRequest)
                    .DependentRules(() =>
                    {
                        RuleFor(x => x.Dto.Customer.Name)
                            .NotEmpty()
                            .WithMessage(MessageCode.NameIsRequired);

                        RuleFor(x => x.Dto.Customer.Email)
                            .NotEmpty()
                            .WithMessage(MessageCode.EmailIsRequired)
                            .EmailAddress()
                            .WithMessage(MessageCode.InvalidEmailAddress);

                        RuleFor(x => x.Dto.Customer.PhoneNumber)
                            .NotEmpty()
                            .WithMessage(MessageCode.PhoneNumberIsRequired)
                            .IsValidPhoneNumber()
                            .WithMessage(MessageCode.InvalidPhoneNumber);
                    });

                RuleFor(x => x.Dto.ShippingAddress)
                    .NotNull()
                    .WithMessage(MessageCode.BadRequest)
                    .DependentRules(() =>
                    {
                        RuleFor(x => x.Dto.ShippingAddress.AddressLine)
                            .NotEmpty()
                            .WithMessage(MessageCode.AddressLineIsRequired);

                        RuleFor(x => x.Dto.ShippingAddress.Subdivision)
                            .NotEmpty()
                            .WithMessage(MessageCode.SubdivisionIsRequired);

                        RuleFor(x => x.Dto.ShippingAddress.City)
                            .NotEmpty()
                            .WithMessage(MessageCode.CityIsRequired);

                        RuleFor(x => x.Dto.ShippingAddress.StateOrProvince)
                            .NotEmpty()
                            .WithMessage(MessageCode.StateOrProvinceIsRequired);

                        RuleFor(x => x.Dto.ShippingAddress.Country)
                            .NotEmpty()
                            .WithMessage(MessageCode.CountryIsRequired);

                        RuleFor(x => x.Dto.ShippingAddress.PostalCode)
                            .NotEmpty()
                            .WithMessage(MessageCode.PostalCodeIsRequired);
                    });

                RuleFor(x => x.Dto.OrderItems)
                    .NotNull()
                    .WithMessage(MessageCode.BadRequest)
                    .Must(items => items != null && items.Count > 0)
                    .WithMessage(MessageCode.OrderItemsIsRequired)
                    .DependentRules(() =>
                    {
                        RuleForEach(x => x.Dto.OrderItems).ChildRules(item =>
                        {
                            item.RuleFor(i => i.ProductId)
                                .NotEmpty()
                                .WithMessage(MessageCode.ProductIdIsRequired);

                            item.RuleFor(i => i.Quantity)
                                .GreaterThan(0)
                                .WithMessage(MessageCode.QuantityCannotBeNegative);
                        });
                    });
            });

    }

    #endregion
}

public sealed class UpdateOrderCommandHandler(IUnitOfWork unitOfWork, ICatalogGrpcService catalogGrpc) : ICommandHandler<UpdateOrderCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(UpdateOrderCommand command, CancellationToken cancellationToken)
    {
        var existingOrder = await unitOfWork.Orders.GetByIdWithRelationshipAsync(command.OrderId, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound, command.OrderId);

        if (existingOrder.Status == OrderStatus.Delivered ||
            existingOrder.Status == OrderStatus.Canceled ||
            existingOrder.Status == OrderStatus.Refunded)
        {
            throw new ClientValidationException(MessageCode.OrderCannotBeUpdated);
        }

        var dto = command.Dto;
        var customer = Customer.Of(
            dto.Customer.Id,
            dto.Customer.PhoneNumber,
            dto.Customer.Name,
            dto.Customer.Email);
        var shippingAddress = Address.Of(
            dto.ShippingAddress.AddressLine,
            dto.ShippingAddress.Subdivision,
            dto.ShippingAddress.City,
            dto.ShippingAddress.Country,
            dto.ShippingAddress.StateOrProvince,
            dto.ShippingAddress.PostalCode);

        existingOrder.UpdateCustomerInfo(customer, command.Actor.ToString());
        existingOrder.UpdateShippingAddress(shippingAddress, command.Actor.ToString());

        var productIds = dto.OrderItems
            .Select(x => x.ProductId.ToString())
            .Distinct()
            .ToArray();

        var productsResponse = await catalogGrpc.GetProductsAsync(ids: productIds, cancellationToken: cancellationToken);

        if (productsResponse == null || productsResponse.Items == null || productsResponse.Items.Count == 0)
        {
            throw new ClientValidationException(MessageCode.ProductIsNotExists);
        }

        var validProducts = productsResponse.Items.ToDictionary(p => p.Id, p => p);
        var dtoProductIdSet = dto.OrderItems.Select(i => i.ProductId).ToHashSet();
        var toRemove = existingOrder.OrderItems
            .Where(oi => !validProducts.ContainsKey(oi.Product.Id) || !dtoProductIdSet.Contains(oi.Product.Id))
            .Select(oi => oi.Product.Id)
            .ToList();

        foreach (var productId in toRemove)
        {
            existingOrder.RemoveOrderItem(productId);
        }

        foreach (var item in dto.OrderItems)
        {
            var alreadyProcessed = existingOrder.OrderItems.Any(oi => oi.Product.Id == item.ProductId) &&
                                    dto.OrderItems.First(i => i.ProductId == item.ProductId) != item;
            if (alreadyProcessed) continue;

            if (!validProducts.TryGetValue(item.ProductId, out var productInfo))
            {
                continue;
            }

            var existingItem = existingOrder.OrderItems.FirstOrDefault(oi => oi.Product.Id == item.ProductId);
            if (existingItem == null)
            {
                var product = Product.Of(
                    productInfo.Id,
                    productInfo.Name,
                    productInfo.Price,
                    productInfo.Thumbnail);

                existingOrder.AddOrderItem(product, item.Quantity);
            }
            else if (existingItem.Quantity != item.Quantity)
            {
                existingOrder.RemoveOrderItem(item.ProductId);

                var product = Product.Of(
                    productInfo.Id,
                    productInfo.Name,
                    productInfo.Price,
                    productInfo.Thumbnail);

                existingOrder.AddOrderItem(product, item.Quantity);
            }
        }

        unitOfWork.Orders.Update(existingOrder);
        await unitOfWork.SaveChangesAsync(cancellationToken);

        return existingOrder.Id;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/Commands/UpdateOrderStatusCommand.cs">
#region using

using Order.Domain.Abstractions;
using Order.Domain.Enums;

#endregion

namespace Order.Application.Features.Order.Commands;

public sealed record UpdateOrderStatusCommand(
    Guid OrderId,
    OrderStatus Status,
    string? Reason,
    Actor Actor) : ICommand<Guid>;

public sealed class UpdateOrderStatusCommandValidator : AbstractValidator<UpdateOrderStatusCommand>
{
    #region Ctors

    public UpdateOrderStatusCommandValidator()
    {
        RuleFor(x => x.OrderId)
            .NotEmpty()
            .WithMessage(MessageCode.OrderIdIsRequired);

        RuleFor(x => x.Status)
            .Must(status => Enum.IsDefined(typeof(OrderStatus), status))
            .WithMessage(MessageCode.InvalidOrderStatus);

        When(x => x.Status == OrderStatus.Canceled, () =>
        {
            RuleFor(x => x.Reason)
                .NotEmpty()
                .WithMessage(MessageCode.CancelReasonIsRequired)
                .MaximumLength(255)
                .WithMessage(MessageCode.Max255Characters);
        });

        When(x => x.Status == OrderStatus.Refunded, () =>
        {
            RuleFor(x => x.Reason)
                .NotEmpty()
                .WithMessage(MessageCode.RefundReasonIsRequired)
                .MaximumLength(255)
                .WithMessage(MessageCode.Max255Characters);
        });
    }

    #endregion
}

public sealed class UpdateOrderStatusCommandHandler(IUnitOfWork unitOfWork)
    : ICommandHandler<UpdateOrderStatusCommand, Guid>
{
    #region Implementations

    public async Task<Guid> Handle(UpdateOrderStatusCommand command, CancellationToken cancellationToken)
    {
        var order = await unitOfWork.Orders.FirstOrDefaultAsync(x => x.Id == command.OrderId, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound, command.OrderId);

        if (order.Status == OrderStatus.Delivered ||
            order.Status == OrderStatus.Canceled ||
            order.Status == OrderStatus.Refunded)
        {
            throw new ClientValidationException(MessageCode.OrderStatusCannotBeUpdated);
        }

        if (order.Status == command.Status)
        {
            throw new ClientValidationException(MessageCode.OrderStatusSameAsCurrent);
        }

        var performedBy = command.Actor.ToString();

        switch (command.Status)
        {
            case OrderStatus.Canceled:
                if (string.IsNullOrWhiteSpace(command.Reason))
                {
                    throw new ClientValidationException(MessageCode.CancelReasonIsRequired);
                }
                order.CancelOrder(command.Reason!, performedBy);
                break;

            case OrderStatus.Refunded:
                if (string.IsNullOrWhiteSpace(command.Reason))
                {
                    throw new ClientValidationException(MessageCode.RefundReasonIsRequired);
                }
                order.RefundOrder(command.Reason!, performedBy);
                break;

            case OrderStatus.Delivered:
                order.OrderDelivered(performedBy);
                break;

            default:
                order.UpdateStatus(command.Status, performedBy);
                break;
        }

        unitOfWork.Orders.Update(order);
        await unitOfWork.SaveChangesAsync(cancellationToken);

        return order.Id;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/EventHandlers/Domain/OrderCancelledDomainEventHandler.cs">
#region using

using EventSourcing.Events.Orders;
using MediatR;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using Order.Domain.Abstractions;
using Order.Domain.Entities;
using Order.Domain.Events;

#endregion

namespace Order.Application.Features.Order.EventHandlers.Domain;

public sealed class OrderCancelledDomainEventHandler(
    IUnitOfWork unitOfWork,
    ILogger<OrderCancelledDomainEventHandler> logger) : INotificationHandler<OrderCancelledDomainEvent>
{
    #region Implementations

    public async Task Handle(OrderCancelledDomainEvent @event, CancellationToken cancellationToken)
    {
        logger.LogInformation("Domain Event handled: {DomainEvent}", @event.GetType().Name);

        await PushToOutboxAsync(@event, cancellationToken);
    }

    #endregion

    #region Methods

    private async Task PushToOutboxAsync(OrderCancelledDomainEvent @event, CancellationToken cancellationToken)
    {
        var reason = string.IsNullOrEmpty(@event.Order.RefundReason) ? @event.Order.CancelReason : @event.Order.RefundReason;
        var message = new OrderCancelledIntegrationEvent()
        {
            Id = Guid.NewGuid().ToString(),
            OrderId = @event.Order.Id,
            OrderNo = @event.Order.OrderNo.ToString(),
            Reason = reason!,
            OrderItems = @event.Order.OrderItems.Select(oi => new OrderItemIntegrationEvent
            {
                ProductId = oi.Product.Id,
                Quantity = oi.Quantity,
                UnitPrice = oi.Product.Price,
                LineTotal = oi.LineTotal
            }).ToList(),
        };
        var outboxMessage = OutboxMessageEntity.Create(
            id: Guid.NewGuid(),
            eventType: message.EventType!,
            content: JsonConvert.SerializeObject(message),
            occurredOnUtc: DateTimeOffset.UtcNow);

        await unitOfWork.OutboxMessages.AddAsync(outboxMessage, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/EventHandlers/Domain/OrderCreatedDomainEventHandler.cs">
#region using

using EventSourcing.Events.Orders;
using MediatR;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using Order.Domain.Abstractions;
using Order.Domain.Entities;
using Order.Domain.Events;

#endregion

namespace Order.Application.Features.Order.EventHandlers.Domain;

public sealed class OrderCreatedDomainEventHandler(
    IUnitOfWork unitOfWork,
    ILogger<OrderCreatedDomainEventHandler> logger) : INotificationHandler<OrderCreatedDomainEvent>
{
    #region Implementations

    public async Task Handle(OrderCreatedDomainEvent @event, CancellationToken cancellationToken)
    {
        logger.LogInformation(
            "Domain Event handled: {DomainEvent} for OrderId: {OrderId}, OrderNo: {OrderNo}",
            @event.GetType().Name, @event.Order.Id, @event.Order.OrderNo);

        await PushToOutboxAsync(@event, cancellationToken);
    }

    #endregion

    #region Methods

    private async Task PushToOutboxAsync(OrderCreatedDomainEvent @event, CancellationToken cancellationToken)
    {
        var message = new OrderCreatedIntegrationEvent()
        {
            Id = Guid.NewGuid().ToString(),
            OrderId = @event.Order.Id,
            OrderNo = @event.Order.OrderNo.ToString(),
            TotalPrice = @event.Order.TotalPrice,
            FinalPrice = @event.Order.FinalPrice,
            OrderItems = @event.Order.OrderItems.Select(oi => new OrderItemIntegrationEvent
            {
                ProductId = oi.Product.Id,
                Quantity = oi.Quantity,
                UnitPrice = oi.Product.Price,
                LineTotal = oi.LineTotal
            }).ToList(),
        };

        var outboxMessageId = Guid.NewGuid();
        var outboxMessage = OutboxMessageEntity.Create(
            id: outboxMessageId,
            eventType: message.EventType!,
            content: JsonConvert.SerializeObject(message),
            occurredOnUtc: DateTimeOffset.UtcNow);

        await unitOfWork.OutboxMessages.AddAsync(outboxMessage, cancellationToken);

        logger.LogInformation(
            "Created outbox message {OutboxMessageId} for OrderId: {OrderId}, OrderNo: {OrderNo}",
            outboxMessageId, @event.Order.Id, @event.Order.OrderNo);
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/EventHandlers/Domain/OrderDeliveredDomainEventHandler.cs">
#region using

using EventSourcing.Events.Orders;
using MediatR;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using Order.Domain.Abstractions;
using Order.Domain.Entities;
using Order.Domain.Events;

#endregion

namespace Order.Application.Features.Order.EventHandlers.Domain;

public sealed class OrderDeliveredDomainEventHandler(
    IUnitOfWork unitOfWork,
    ILogger<OrderDeliveredDomainEventHandler> logger) : INotificationHandler<OrderDeliveredDomainEvent>
{
    #region Implementations

    public async Task Handle(OrderDeliveredDomainEvent @event, CancellationToken cancellationToken)
    {
        logger.LogInformation("Domain Event handled: {DomainEvent}", @event.GetType().Name);

        await PushToOutboxAsync(@event, cancellationToken);
    }

    #endregion

    #region Methods

    private async Task PushToOutboxAsync(OrderDeliveredDomainEvent @event, CancellationToken cancellationToken)
    {
        var reason = string.IsNullOrEmpty(@event.Order.RefundReason) ? @event.Order.CancelReason : @event.Order.RefundReason;
        var message = new OrderDeliveredIntegrationEvent()
        {
            Id = Guid.NewGuid().ToString(),
            OrderId = @event.Order.Id,
            OrderNo = @event.Order.OrderNo.ToString(),
            Reason = reason!,
            OrderItems = @event.Order.OrderItems.Select(oi => new OrderItemIntegrationEvent
            {
                ProductId = oi.Product.Id,
                Quantity = oi.Quantity,
                UnitPrice = oi.Product.Price,
                LineTotal = oi.LineTotal
            }).ToList(),
        };
        var outboxMessage = OutboxMessageEntity.Create(
            id: Guid.NewGuid(),
            eventType: message.EventType!,
            content: JsonConvert.SerializeObject(message),
            occurredOnUtc: DateTimeOffset.UtcNow);

        await unitOfWork.OutboxMessages.AddAsync(outboxMessage, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/Queries/GetAllMyOrdersQuery.cs">
#region using

using AutoMapper;
using Order.Domain.Abstractions;
using Order.Application.Dtos.Orders;
using Order.Application.Models.Filters;
using Order.Application.Models.Results;

#endregion

namespace Order.Application.Features.Order.Queries;

public sealed record GetAllMyOrdersQuery(
    GetMyOrdersFilter Filter,
    Actor Actor) : IQuery<GetAllMyOrdersResult>;

public sealed class GetAllMyOrdersQueryHandler(IUnitOfWork unitOfWork, IMapper mapper)
    : IQueryHandler<GetAllMyOrdersQuery, GetAllMyOrdersResult>
{
    #region Implementations

    public async Task<GetAllMyOrdersResult> Handle(GetAllMyOrdersQuery query, CancellationToken cancellationToken)
    {
        var filter = query.Filter;
        var actor = query.Actor;

        var orders = await unitOfWork.Orders
            .SearchWithRelationshipAsync(x =>
                x.Customer.Id == Guid.Parse(actor.ToString()) &&
                (filter.SearchText.IsNullOrWhiteSpace() || x.OrderNo.Value.ToLower().Contains(filter.SearchText!)) &&
                (!filter.FromDate.HasValue || x.CreatedOnUtc >= filter.FromDate.Value) &&
                (!filter.ToDate.HasValue || x.CreatedOnUtc <= filter.ToDate.Value),
                cancellationToken);

        var items = mapper.Map<List<OrderDto>>(orders);
        var response = new GetAllMyOrdersResult(items);

        return response;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/Queries/GetAllOrdersQuery.cs">
#region using

using AutoMapper;
using Order.Domain.Abstractions;
using Order.Application.Dtos.Orders;
using Order.Application.Models.Filters;
using Order.Application.Models.Results;

#endregion

namespace Order.Application.Features.Order.Queries;

public sealed record GetAllOrdersQuery(GetAllOrdersFilter Filter) : IQuery<GetAllOrdersResult>;

public sealed class GetAllOrdersQueryHandler(IUnitOfWork unitOfWork, IMapper mapper)
    : IQueryHandler<GetAllOrdersQuery, GetAllOrdersResult>
{
    #region Implementations

    public async Task<GetAllOrdersResult> Handle(GetAllOrdersQuery query, CancellationToken cancellationToken)
    {
        var filter = query.Filter;

        var orders = await unitOfWork.Orders
            .SearchWithRelationshipAsync(x =>
                (filter.Ids == null || filter.Ids.Length > 0 || filter.Ids.Contains(x.Id)) &&
                (!filter.CustomerId.HasValue || x.Customer.Id == filter.CustomerId.Value) &&
                (!filter.Status.HasValue || x.Status == filter.Status.Value) &&
                (filter.SearchText.IsNullOrWhiteSpace() || x.OrderNo.Value.ToLower().Contains(filter.SearchText!)) &&
                (!filter.FromDate.HasValue || x.CreatedOnUtc >= filter.FromDate.Value) &&
                (!filter.ToDate.HasValue || x.CreatedOnUtc <= filter.ToDate.Value),
                cancellationToken);

        var items = mapper.Map<List<OrderDto>>(orders);
        var response = new GetAllOrdersResult(items);

        return response;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/Queries/GetMyOrderByIdQuery.cs">
#region using

using AutoMapper;
using Order.Domain.Abstractions;
using Order.Application.Dtos.Orders;
using Order.Application.Models.Results;

#endregion

namespace Order.Application.Features.Order.Queries;

public sealed record GetMyOrderByIdQuery(
    Guid OrderId,
    Actor Actor) : IQuery<GetMyOrderByIdResult>;

public sealed class GetMyOrderByIdQueryHandler(IUnitOfWork unitOfWork, IMapper mapper)
    : IQueryHandler<GetMyOrderByIdQuery, GetMyOrderByIdResult>
{
    #region Implementations

    public async Task<GetMyOrderByIdResult> Handle(GetMyOrderByIdQuery query, CancellationToken cancellationToken)
    {
        var actor = query.Actor;

        var order = await unitOfWork.Orders
            .FirstOrDefaultAsync(x => x.Id == query.OrderId && x.Customer.Id == Guid.Parse(actor.ToString()), cancellationToken)
            ?? throw new NotFoundException(MessageCode.OrderNotFound);

        var orderDto = mapper.Map<OrderDto>(order);
        var response = new GetMyOrderByIdResult(orderDto);

        return response;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/Queries/GetMyOrdersQuery.cs">
#region using

using AutoMapper;
using Order.Domain.Abstractions;
using Order.Application.Dtos.Orders;
using Order.Application.Models.Filters;
using Order.Application.Models.Results;

#endregion

namespace Order.Application.Features.Order.Queries;

public sealed record GetMyOrdersQuery(
    GetMyOrdersFilter Filter,
    PaginationRequest Paging,
    Actor Actor) : IQuery<GetMyOrdersResult>;

public sealed class GetMyOrdersQueryHandler(IUnitOfWork unitOfWork, IMapper mapper)
    : IQueryHandler<GetMyOrdersQuery, GetMyOrdersResult>
{
    #region Implementations

    public async Task<GetMyOrdersResult> Handle(GetMyOrdersQuery query, CancellationToken cancellationToken)
    {
        var filter = query.Filter;
        var paging = query.Paging;
        var actor = query.Actor;

        // Apply all filters in the predicate expression
        var orders = await unitOfWork.Orders
            .SearchWithRelationshipAsync(x =>
                x.Customer.Id == Guid.Parse(actor.ToString()) &&
                (filter.SearchText.IsNullOrWhiteSpace() || x.OrderNo.Value.ToLower().Contains(filter.SearchText.Trim().ToLower())) &&
                (!filter.FromDate.HasValue || x.CreatedOnUtc >= filter.FromDate.Value) &&
                (!filter.ToDate.HasValue || x.CreatedOnUtc <= filter.ToDate.Value),
                paging,
                cancellationToken);

        var totalCount = orders.Count;
        var items = mapper.Map<List<OrderDto>>(orders);
        var response = new GetMyOrdersResult(items, totalCount, paging);

        return response;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/Queries/GetOrderByIdQuery.cs">
#region using

using AutoMapper;
using Order.Domain.Abstractions;
using Order.Application.Dtos.Orders;
using Order.Application.Models.Results;

#endregion

namespace Order.Application.Features.Order.Queries;

public sealed record GetOrderByIdQuery(Guid OrderId) : IQuery<GetOrderByIdResult>;

public sealed class GetOrderByIdQueryHandler(IUnitOfWork unitOfWork, IMapper mapper)
    : IQueryHandler<GetOrderByIdQuery, GetOrderByIdResult>
{
    #region Implementations

    public async Task<GetOrderByIdResult> Handle(GetOrderByIdQuery query, CancellationToken cancellationToken)
    {
        var order = await unitOfWork.Orders
            .GetByIdWithRelationshipAsync(query.OrderId, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound, query.OrderId);

        var orderDto = mapper.Map<OrderDto>(order);
        var response = new GetOrderByIdResult(orderDto);

        return response;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/Queries/GetOrderByMonthQuery.cs">
#region using

using AutoMapper;
using Order.Domain.Abstractions;
using Order.Application.Dtos.Orders;
using Order.Application.Models.Results;

#endregion

namespace Order.Application.Features.Order.Queries;

public sealed record GetOrderByMonthQuery(int Year, int Month) : IQuery<GetOrderByMonthResult>;

public sealed class GetOrderByMonthQueryHandler(IUnitOfWork unitOfWork, IMapper mapper)
    : IQueryHandler<GetOrderByMonthQuery, GetOrderByMonthResult>
{
    #region Implementations

    public async Task<GetOrderByMonthResult> Handle(GetOrderByMonthQuery query, CancellationToken cancellationToken)
    {
        // Fetch orders for the specified month using repository
        var orders = await unitOfWork.Orders
            .SearchWithRelationshipAsync(
                x => x.CreatedOnUtc.Year == query.Year &&
                     x.CreatedOnUtc.Month == query.Month &&
                     x.Status == Domain.Enums.OrderStatus.Delivered,
                cancellationToken);

        // Group orders by day
        var ordersByDay = orders
            .GroupBy(x => x.CreatedOnUtc.Day)
            .ToDictionary(g => g.Key, g => g.ToList());

        // Get total days in the queried month
        var daysInMonth = DateTime.DaysInMonth(query.Year, query.Month);

        // Create result for all days in the month
        var allOrderDtos = new List<OrderDto>();

        for (int day = 1; day <= daysInMonth; day++)
        {
            if (ordersByDay.TryGetValue(day, out var dayOrders))
            {
                // If there are orders for this day, map them
                var orderDtos = mapper.Map<List<OrderDto>>(dayOrders);
                allOrderDtos.AddRange(orderDtos);
            }
            else
            {
                // If no orders for this day, add an empty OrderDto with the date
                var emptyOrder = new OrderDto
                {
                    Id = Guid.Empty,
                    CreatedOnUtc = new DateTimeOffset(query.Year, query.Month, day, 0, 0, 0, TimeSpan.Zero),
                    TotalPrice = 0,
                    FinalPrice = 0,
                    OrderItems = new List<OrderItemDto>()
                };
                allOrderDtos.Add(emptyOrder);
            }
        }

        var response = new GetOrderByMonthResult(allOrderDtos);

        return response;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/Queries/GetOrderByOrderNoQuery.cs">
#region using

using AutoMapper;
using Order.Domain.Abstractions;
using Order.Application.Dtos.Orders;
using Order.Application.Models.Results;

#endregion

namespace Order.Application.Features.Order.Queries;

public sealed record GetOrderByOrderNoQuery(string OrderNo) : IQuery<GetOrderByOrderNoResult>;

public sealed class GetOrderByOrderNoQueryHandler(IUnitOfWork unitOfWork, IMapper mapper)
    : IQueryHandler<GetOrderByOrderNoQuery, GetOrderByOrderNoResult>
{
    #region Implementations

    public async Task<GetOrderByOrderNoResult> Handle(GetOrderByOrderNoQuery query, CancellationToken cancellationToken)
    {
        var order = await unitOfWork.Orders
            .GetByOrderNoAsync(query.OrderNo, cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound, query.OrderNo);

        var orderDto = mapper.Map<OrderDto>(order);
        var response = new GetOrderByOrderNoResult(orderDto);

        return response;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Features/Order/Queries/GetOrdersQuery.cs">
#region using

using AutoMapper;
using Order.Domain.Abstractions;
using Order.Application.Dtos.Orders;
using Order.Application.Models.Filters;
using Order.Application.Models.Results;
using Order.Domain.Entities;
using System.Linq.Expressions;

#endregion

namespace Order.Application.Features.Order.Queries;

public sealed record GetOrdersQuery(
    GetOrdersFilter Filter,
    PaginationRequest Paging) : IQuery<GetOrdersResult>;

public sealed class GetOrdersQueryHandler(IUnitOfWork unitOfWork, IMapper mapper)
    : IQueryHandler<GetOrdersQuery, GetOrdersResult>
{
    #region Implementations

    public async Task<GetOrdersResult> Handle(GetOrdersQuery query, CancellationToken cancellationToken)
    {
        var filter = query.Filter;
        var paging = query.Paging;
        var predicate = BuildFilterPredicate(filter);

        var orders = await unitOfWork.Orders
            .SearchWithRelationshipAsync(predicate, paging, cancellationToken);

        var totalCount = await unitOfWork.Orders.CountAsync(predicate, cancellationToken);

        var items = mapper.Map<List<OrderDto>>(orders);
        var response = new GetOrdersResult(items, totalCount, paging);

        return response;
    }

    #endregion

    #region Helper Methods

    private static Expression<Func<OrderEntity, bool>> BuildFilterPredicate(GetOrdersFilter filter)
    {
        return x =>
            (filter.Ids == null || filter.Ids.Length == 0 || filter.Ids.Contains(x.Id)) &&
            (!filter.CustomerId.HasValue || x.Customer.Id == filter.CustomerId.Value) &&
            (!filter.Status.HasValue || x.Status == filter.Status.Value) &&
            (filter.SearchText.IsNullOrWhiteSpace() || x.OrderNo.Value.ToLower().Contains(filter.SearchText.Trim().ToLower())) &&
            (!filter.FromDate.HasValue || x.CreatedOnUtc >= filter.FromDate.Value) &&
            (!filter.ToDate.HasValue || x.CreatedOnUtc <= filter.ToDate.Value);
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Mappings/OrderMappingProfile.cs">
#region using

using AutoMapper;
using Order.Application.Dtos.Orders;
using Order.Application.Dtos.ValueObjects;
using Order.Domain.Entities;
using Order.Domain.ValueObjects;

#endregion

namespace Order.Application.Mappings;

public sealed class OrderMappingProfile : Profile
{
    #region Ctors

    public OrderMappingProfile()
    {
        CreateValueObjectMappings();
        CreateEntityMappings();
        CreateDtoMappings();
    }

    #endregion

    #region Methods

    private void CreateValueObjectMappings()
    {
        // Customer mappings
        CreateMap<Customer, CustomerDto>()
            .ReverseMap();

        // Address mappings
        CreateMap<Address, AddressDto>()
            .ReverseMap();

        // Discount mappings
        CreateMap<Discount, DiscountDto>()
            .ReverseMap();

        // Product mappings
        CreateMap<Product, ProductDto>()
            .ReverseMap();
    }

    private void CreateEntityMappings()
    {
        // OrderEntity -> OrderDto
        CreateMap<OrderEntity, OrderDto>()
            .ForMember(dest => dest.OrderNo, opt => opt.MapFrom(src => src.OrderNo.Value))
            .ForMember(dest => dest.DisplayStatus, opt => opt.MapFrom(src => src.Status.GetDescription()));

        // OrderItemEntity -> OrderItemDto
        CreateMap<OrderItemEntity, OrderItemDto>();
    }

    private void CreateDtoMappings()
    {
        // CreateOrUpdateOrderDto -> OrderEntity
        CreateMap<CreateOrUpdateOrderDto, OrderEntity>()
            .ForMember(dest => dest.Id, opt => opt.Ignore())
            .ForMember(dest => dest.OrderNo, opt => opt.Ignore())
            .ForMember(dest => dest.Status, opt => opt.Ignore())
            .ForMember(dest => dest.OrderItems, opt => opt.Ignore())
            .ForMember(dest => dest.Discount, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedOnUtc, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedBy, opt => opt.Ignore())
            .ForMember(dest => dest.LastModifiedOnUtc, opt => opt.Ignore())
            .ForMember(dest => dest.LastModifiedBy, opt => opt.Ignore())
            .ForMember(dest => dest.Customer, opt => opt.MapFrom(src => src.Customer))
            .ForMember(dest => dest.ShippingAddress, opt => opt.MapFrom(src => src.ShippingAddress));

        // CreateOrderItemDto -> Product
        CreateMap<CreateOrderItemDto, Product>()
            .ForMember(dest => dest.Id, opt => opt.MapFrom(src => src.ProductId))
            .ForMember(dest => dest.Name, opt => opt.Ignore())
            .ForMember(dest => dest.ImageUrl, opt => opt.Ignore())
            .ForMember(dest => dest.Price, opt => opt.Ignore());
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Filters/GetAllOrdersFilter.cs">
#region using

using Order.Domain.Enums;

#endregion

namespace Order.Application.Models.Filters;

public class GetAllOrdersFilter
{
    #region Fields, Properties and Indexers

    public string? SearchText { get; set; }

    public Guid[]? Ids { get; set; }

    public Guid? CustomerId { get; set; }

    public OrderStatus? Status { get; set; }

    public DateTime? FromDate { get; set; }

    public DateTime? ToDate { get; set; }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Filters/GetInventoryItemsFilter.cs">
namespace Order.Application.Models.Filters;

public sealed record class GetInventoryItemsFilter(string? SearchText);
</file>

<file path="Services/Order/Core/Order.Application/Models/Filters/GetMyOrdersFilter.cs">
namespace Order.Application.Models.Filters;

public class GetMyOrdersFilter
{
    #region Fields, Properties and Indexers

    public string? SearchText { get; set; }

    public DateTime? FromDate { get; set; }

    public DateTime? ToDate { get; set; }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Filters/GetOrdersFilter.cs">
#region using

using Order.Domain.Enums;

#endregion

namespace Order.Application.Models.Filters;

public class GetOrdersFilter
{
    #region Fields, Properties and Indexers

    public string? SearchText { get; set; }

    public Guid[]? Ids { get; set; }

    public Guid? CustomerId { get; set; }

    public OrderStatus? Status { get; set; }

    public DateTime? FromDate { get; set; }

    public DateTime? ToDate { get; set; }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Responses/Externals/GetAllProductsResponse.cs">
namespace Order.Application.Models.Responses.Externals;

public class GetAllProductsResponse
{
    #region Fields, Properties and Indexers

    public List<ProductReponse>? Items { get; set; }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Responses/Externals/ProductReponse.cs">
namespace Order.Application.Models.Responses.Externals;

public class ProductReponse
{
    #region Fields, Properties and Indexers

    public Guid Id { get; init; } = default!;

    public string Name { get; init; } = default!;

    public decimal Price { get; init; }

    public string Thumbnail { get; init; } = default!;

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Responses/Internals/ApplyCouponResponse.cs">
namespace Order.Application.Models.Responses.Internals;

public sealed class ApplyCouponResponse
{
    #region Fields, Properties and Indexers

    public string CouponCode { get; init; } = string.Empty;

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Responses/Internals/EvaluateCouponResponse.cs">
namespace Order.Application.Models.Responses.Internals;

public sealed class EvaluateCouponResponse
{
    #region Fields, Properties and Indexers

    public decimal OriginalAmount { get; init; }

    public decimal DiscountAmount { get; init; }

    public decimal FinalAmount { get; init; }

    public string CouponCode { get; init; } = string.Empty;

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Responses/KeycloakAccessTokenResponse.cs">
#region using

using System.Text.Json.Serialization;

#endregion

namespace Order.Application.Models.Responses;

public sealed class KeycloakAccessTokenResponse
{
    #region Fields, Properties and Indexers

    [JsonPropertyName("access_token")]
    public string? AccessToken { get; set; }

    [JsonPropertyName("expires_in")]
    public int ExpiresIn { get; set; }

    [JsonPropertyName("refresh_expires_in")]
    public int RefreshExpiresIn { get; set; }

    [JsonPropertyName("token_type")]
    public string? TokenType { get; set; }

    [JsonPropertyName("id_token")]
    public string? IdToken { get; set; }

    [JsonPropertyName("not-before-policy")]
    public int NotBeforePolicy { get; set; }

    [JsonPropertyName("scope")]
    public string? Scope { get; set; }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Results/GetAllMyOrdersResult.cs">
#region using

using Order.Application.Dtos.Orders;

#endregion

namespace Order.Application.Models.Results;

public sealed class GetAllMyOrdersResult
{
    #region Fields, Properties and Indexers

    public List<OrderDto> Items { get; init; }

    #endregion

    #region Ctors

    public GetAllMyOrdersResult(List<OrderDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Results/GetAllOrdersResult.cs">
#region using

using Order.Application.Dtos.Orders;

#endregion

namespace Order.Application.Models.Results;

public sealed class GetAllOrdersResult
{
    #region Fields, Properties and Indexers

    public List<OrderDto> Items { get; init; }

    #endregion

    #region Ctors

    public GetAllOrdersResult(List<OrderDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Results/GetMyOrderByIdResult.cs">
#region using

using Order.Application.Dtos.Orders;

#endregion

namespace Order.Application.Models.Results;

public sealed class GetMyOrderByIdResult
{
    #region Fields, Properties and Indexers

    public OrderDto Order { get; init; }

    #endregion

    #region Ctors

    public GetMyOrderByIdResult(OrderDto order)
    {
        Order = order;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Results/GetMyOrdersResult.cs">
#region using

using Order.Application.Dtos.Orders;

#endregion

namespace Order.Application.Models.Results;

public sealed class GetMyOrdersResult
{
    #region Fields, Properties and Indexers

    public List<OrderDto> Items { get; init; }

    public PagingResult Paging { get; init; }

    #endregion

    #region Ctors

    public GetMyOrdersResult(
        List<OrderDto> items,
        long totalItems,
        PaginationRequest pagination)
    {
        Items = items;
        Paging = PagingResult.Of(totalItems, pagination);
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Results/GetOrderByIdResult.cs">
#region using

using Order.Application.Dtos.Orders;

#endregion

namespace Order.Application.Models.Results;

public sealed class GetOrderByIdResult
{
    #region Fields, Properties and Indexers

    public OrderDto Order { get; init; }

    #endregion

    #region Ctors

    public GetOrderByIdResult(OrderDto order)
    {
        Order = order;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Results/GetOrderByMonthResult.cs">
#region using

using Order.Application.Dtos.Orders;

#endregion

namespace Order.Application.Models.Results;

public sealed class GetOrderByMonthResult
{
    #region Fields, Properties and Indexers

    public List<OrderDto> Items { get; init; }

    #endregion

    #region Ctors

    public GetOrderByMonthResult(List<OrderDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Results/GetOrderByOrderNoResult.cs">
#region using

using Order.Application.Dtos.Orders;

#endregion

namespace Order.Application.Models.Results;

public sealed class GetOrderByOrderNoResult
{
    #region Fields, Properties and Indexers

    public OrderDto Order { get; init; }

    #endregion

    #region Ctors

    public GetOrderByOrderNoResult(OrderDto order)
    {
        Order = order;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Models/Results/GetOrdersResult.cs">
#region using

using Order.Application.Dtos.Orders;

#endregion

namespace Order.Application.Models.Results;

public sealed class GetOrdersResult
{
    #region Fields, Properties and Indexers

    public List<OrderDto> Items { get; init; }

    public PagingResult Paging { get; init; }

    #endregion

    #region Ctors

    public GetOrdersResult(
        List<OrderDto> items,
        long totalCount,
        PaginationRequest pagination)
    {
        Items = items;
        Paging = PagingResult.Of(totalCount, pagination);
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Services/ICatalogGrpcService.cs">
#region using

using Order.Application.Models.Responses.Externals;

#endregion

namespace Order.Application.Services;

public interface ICatalogGrpcService
{
    #region Methods

    Task<ProductReponse?> GetProductByIdAsync(string productId, CancellationToken cancellationToken = default);

    Task<GetAllProductsResponse?> GetProductsAsync(string[]? ids = null, string searchText = "", CancellationToken cancellationToken = default);

    Task<GetAllProductsResponse?> GetAllAvailableProductsAsync(string[]? ids = null, string searchText = "", CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/Services/IDiscountGrpcService.cs">
#region using

using Order.Application.Models.Responses.Internals;

#endregion

namespace Order.Application.Services;

public interface IDiscountGrpcService
{
    #region Methods

    Task<ApplyCouponResponse?> ApplyCouponAsync(string code, decimal amount, CancellationToken cancellationToken = default);

    Task<EvaluateCouponResponse?> EvaluateCouponAsync(string code, decimal amount, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/ApplicationMarker.cs">
namespace Order.Application;

public sealed class ApplicationMarker { }
</file>

<file path="Services/Order/Core/Order.Application/DependencyInjection.cs">
#region using

using BuildingBlocks.Behaviors;
using BuildingBlocks.Exceptions.Handler;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.FeatureManagement;
using System.Reflection;

#endregion

namespace Order.Application;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddApplicationServices(this IServiceCollection services)
    {
        services.AddExceptionHandler<CustomExceptionHandler>();
        services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
        services.AddMediatR(config =>
        {
            config.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
            config.AddOpenBehavior(typeof(ValidationBehavior<,>));
            config.AddOpenBehavior(typeof(LoggingBehavior<,>));
        });

        services.AddFeatureManagement();
        services.AddAutoMapper(Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Application/GlobalUsing.cs">
global using BuildingBlocks.CQRS;
global using FluentValidation;
global using Common.Constants;
global using Common.Extensions;
global using Common.Models;
global using BuildingBlocks.Pagination;
global using BuildingBlocks.Exceptions;
global using BuildingBlocks.Validators;
global using Common.ValueObjects;
</file>

<file path="Services/Order/Core/Order.Application/Order.Application.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="AutoMapper" />
    <PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" />
    <PackageReference Include="Scrutor" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\..\Core\Order.Domain\Order.Domain.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Order/Core/Order.Domain/Abstractions/Aggregate.cs">
namespace Order.Domain.Abstractions;

public abstract class Aggregate<TId> : Entity<TId>, IAggregate<TId>
{
    #region Fields, Properties and Indexers

    private readonly List<IDomainEvent> _domainEvents = new();

    #endregion

    #region Implementations

    public IReadOnlyList<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    public void AddDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }

    public IDomainEvent[] ClearDomainEvents()
    {
        IDomainEvent[] dequeuedEvents = _domainEvents.ToArray();

        _domainEvents.Clear();

        return dequeuedEvents;
    }

    #endregion

}
</file>

<file path="Services/Order/Core/Order.Domain/Abstractions/Entity.cs">
namespace Order.Domain.Abstractions;

public abstract class Entity<T> : IEntityId<T>, IAuditable
{
    #region Fields, Properties and Indexers

    public T Id { get; set; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Order/Core/Order.Domain/Abstractions/EntityId.cs">
namespace Order.Domain.Abstractions;

public abstract class EntityId<T> : IEntityId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; set; } = default!;

    #endregion

}
</file>

<file path="Services/Order/Core/Order.Domain/Abstractions/IAggregate.cs">
namespace Order.Domain.Abstractions;

public interface IAggregate<T> : IAggregate, IEntityId<T>
{
}

public interface IAggregate : ICreationAuditable, IModificationAuditable
{
    #region Fields, Properties and Indexers

    IReadOnlyList<IDomainEvent> DomainEvents { get; }

    IDomainEvent[] ClearDomainEvents();

    #endregion

}
</file>

<file path="Services/Order/Core/Order.Domain/Abstractions/IAuditable.cs">
namespace Order.Domain.Abstractions;

public interface IAuditable : ICreationAuditable, IModificationAuditable { }
</file>

<file path="Services/Order/Core/Order.Domain/Abstractions/ICreationAuditable.cs">
namespace Order.Domain.Abstractions;

public interface ICreationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Order/Core/Order.Domain/Abstractions/IDbTransaction.cs">
namespace Order.Domain.Abstractions;

public interface IDbTransaction : IDisposable, IAsyncDisposable
{
    #region Methods

    Task CommitAsync(CancellationToken cancellationToken = default);

    Task RollbackAsync(CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/Abstractions/IDomainEvent.cs">
#region using

using MediatR;

#endregion

namespace Order.Domain.Abstractions;

public interface IDomainEvent : INotification
{
    #region Fields, Properties and Indexers

    Guid EventId => Guid.NewGuid();

    public DateTimeOffset OccurredOn => DateTime.Now;

    public string EventType => GetType()?.AssemblyQualifiedName ?? string.Empty;

    #endregion

}
</file>

<file path="Services/Order/Core/Order.Domain/Abstractions/IEntityId.cs">
namespace Order.Domain.Abstractions;

public interface IEntityId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; set; }

    #endregion

}
</file>

<file path="Services/Order/Core/Order.Domain/Abstractions/IModificationAuditable.cs">
namespace Order.Domain.Abstractions;

public interface IModificationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Order/Core/Order.Domain/Abstractions/IUnitOfWork.cs">
#region using

using Order.Domain.Repositories;

#endregion

namespace Order.Domain.Abstractions;

public interface IUnitOfWork
{
    #region Fields, Properties and Indexers

    IOrderRepository Orders { get; }

    IOrderItemRepository OrderItems { get; }

    IInboxMessageRepository InboxMessages { get; }

    IOutboxMessageRepository OutboxMessages { get; }

    #endregion

    #region Methods

    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);

    Task<IDbTransaction> BeginTransactionAsync(CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/Entities/InboxMessageEntity.cs">
#region using

using Order.Domain.Abstractions;

#endregion

namespace Order.Domain.Entities;

public sealed class InboxMessageEntity : EntityId<Guid>
{
    #region Fields, Properties and Indexers

    public string? EventType { get; set; }

    public string? Content { get; set; }

    public DateTimeOffset ReceivedOnUtc { get; set; }

    public DateTimeOffset? ProcessedOnUtc { get; set; }

    public string? LastErrorMessage { get; set; }

    public int AttemptCount { get; set; }

    public int MaxAttempts { get; set; }

    public DateTimeOffset? NextAttemptOnUtc { get; set; }

    #endregion

    #region Factories

    public static InboxMessageEntity Create(Guid id, string eventType, string content, DateTimeOffset receivedOnUtc)
    {
        return new InboxMessageEntity()
        {
            Id = id,
            EventType = eventType,
            Content = content,
            ReceivedOnUtc = receivedOnUtc,
            MaxAttempts = AppConstants.MaxAttempts,
            AttemptCount = 0
        };
    }

    #endregion

    #region Methods

    public void CompleteProcessing(DateTimeOffset processedOnUtc, string? lastErrorMessage = null)
    {
        ProcessedOnUtc = processedOnUtc;
        LastErrorMessage = lastErrorMessage;
        NextAttemptOnUtc = null;
    }

    public void SetRetryProperties(int attemptCount, int maxAttempts, DateTimeOffset? nextAttemptOnUtc, string? lastErrorMessage)
    {
        AttemptCount = attemptCount;
        MaxAttempts = maxAttempts;
        NextAttemptOnUtc = nextAttemptOnUtc;
        LastErrorMessage = lastErrorMessage;
    }

    public void RecordFailedAttempt(string errorMessage, DateTimeOffset currentTime)
    {
        IncreaseAttemptCount();

        if (AttemptCount >= MaxAttempts)
        {
            LastErrorMessage = $"Max attempts ({MaxAttempts}) exceeded. Last error: {errorMessage}";
            NextAttemptOnUtc = null;
        }
        else
        {
            // Calculate exponential backoff with jitter
            var baseDelay = TimeSpan.FromSeconds(Math.Pow(2, AttemptCount - 1));
            var maxDelay = TimeSpan.FromMinutes(5);
            var jitter = TimeSpan.FromMilliseconds(Random.Shared.Next(0, 1000));
            var delay = TimeSpan.FromTicks(Math.Min(baseDelay.Ticks, maxDelay.Ticks)) + jitter;

            NextAttemptOnUtc = currentTime + delay;
            LastErrorMessage = errorMessage;
        }
    }

    public void IncreaseAttemptCount()
    {
        AttemptCount++;
    }

    public bool CanRetry(DateTimeOffset currentTime)
    {
        return AttemptCount < MaxAttempts &&
               (NextAttemptOnUtc == null || currentTime >= NextAttemptOnUtc.Value);
    }

    public bool IsPermanentlyFailed()
    {
        return AttemptCount >= MaxAttempts;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/Entities/OrderEntity.cs">
#region using

using Order.Domain.Abstractions;
using Order.Domain.Enums;
using Order.Domain.Events;
using Order.Domain.ValueObjects;

#endregion

namespace Order.Domain.Entities;

public sealed class OrderEntity : Aggregate<Guid>
{
    #region Fields, Properties and Indexers

    private readonly List<OrderItemEntity> _orderItems = new();

    public IReadOnlyList<OrderItemEntity> OrderItems => _orderItems.AsReadOnly();

    public Customer Customer { get; set; } = default!;

    public OrderNo OrderNo { get; set; } = default!;

    public Address ShippingAddress { get; set; } = default!;

    //public Address BillingAddress { get; set; } = default!;

    public OrderStatus Status { get; set; } = OrderStatus.Pending;

    public Discount Discount { get; set; } = default!;

    public string? Notes { get; set; }

    public string? CancelReason { get; set; }

    public string? RefundReason { get; set; }

    public decimal TotalPrice
    {
        get => OrderItems.Sum(x => x.LineTotal);
        private set { }
    }

    public decimal FinalPrice
    {
        get
        {
            var discountAmount = Discount?.DiscountAmount ?? 0m;
            return Math.Max(0, OrderItems.Sum(x => x.LineTotal) - discountAmount);
        }
        private set { }
    }

    #endregion

    #region Factories

    public static OrderEntity Create(Guid id,
        Customer customer,
        OrderNo orderNo,
        Address shippingAddress,
        string? notes,
        string performedBy)
    {
        var order = new OrderEntity
        {
            Id = id,
            Customer = customer,
            OrderNo = orderNo,
            ShippingAddress = shippingAddress,
            Status = OrderStatus.Pending,
            Notes = notes,
            CreatedBy = performedBy,
            LastModifiedBy = performedBy
        };

        //order.AddDomainEvent(new OrderCreatedEvent(order));

        return order;
    }

    #endregion

    #region Methods

    public void UpdateShippingAddress(Address shippingAddress, string performBy)
    {
        ShippingAddress = shippingAddress;
        LastModifiedBy = performBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
        //AddDomainEvent(new OrderUpdatedEvent(this));
    }

    public void UpdateCustomerInfo(Customer customer, string performBy)
    {
        Customer = customer;
        LastModifiedBy = performBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
        //AddDomainEvent(new OrderUpdatedEvent(this));
    }

    public void AddOrderItem(Product product, int quantity)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(quantity);

        var orderItemId = Guid.NewGuid();
        var orderItem = OrderItemEntity.Create(orderItemId, Id, product, quantity, CreatedBy!);
        _orderItems.Add(orderItem);
    }

    public void RemoveOrderItem(Guid productId)
    {
        var orderItem = _orderItems.FirstOrDefault(x => x.Product.Id == productId);
        if (orderItem is not null)
        {
            _orderItems.Remove(orderItem);
        }
    }

    public void ApplyDiscount(Discount discount)
    {
        Discount = discount;
    }

    public void UpdateStatus(OrderStatus status, string performBy)
    {
        if (!Enum.IsDefined(typeof(OrderStatus), status))
        {
            throw new ArgumentException(MessageCode.InvalidOrderStatus, nameof(status));
        }

        Status = status;
        LastModifiedBy = performBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    public void CancelOrder(string reason, string performBy)
    {
        UpdateStatus(OrderStatus.Canceled, performBy);

        CancelReason = reason;
        LastModifiedBy = performBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;

        AddDomainEvent(new OrderCancelledDomainEvent(this));
    }

    public void RefundOrder(string reason, string performBy)
    {
        UpdateStatus(OrderStatus.Refunded, performBy);

        RefundReason = reason;
        LastModifiedBy = performBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;

        AddDomainEvent(new OrderCancelledDomainEvent(this));
    }

    public void OrderCreated()
    {
        AddDomainEvent(new OrderCreatedDomainEvent(this));
    }

    public void OrderDelivered(string performBy)
    {
        UpdateStatus(OrderStatus.Delivered, performBy!);
        AddDomainEvent(new OrderDeliveredDomainEvent(this));
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/Entities/OrderItemEntity.cs">
#region using

using Order.Domain.Abstractions;
using Order.Domain.ValueObjects;

#endregion

namespace Order.Domain.Entities;

public sealed class OrderItemEntity : Entity<Guid>
{
    #region Fields, Properties and Indexers

    public Guid OrderId { get; set; } = default!;

    public Product Product { get; set; } = default!;

    public int Quantity { get; set; } = default!;

    public decimal LineTotal
    {
        get => Product.Price * Quantity;
        private set { }
    }

    #endregion

    #region Factories

    public static OrderItemEntity Create(Guid id, Guid orderId, Product product, int quantity, string performedBy)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(quantity);

        var orderItem = new OrderItemEntity
        {
            Id = id,
            OrderId = orderId,
            Product = product,
            Quantity = quantity,
            CreatedBy = performedBy,
            LastModifiedBy = performedBy
        };

        return orderItem;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/Entities/OutboxMessageEntity.cs">
#region using

using Order.Domain.Abstractions;

#endregion

namespace Order.Domain.Entities;

public sealed class OutboxMessageEntity : EntityId<Guid>
{
    #region Fields, Properties and Indexers

    public string? EventType { get; set; }

    public string? Content { get; set; }

    public DateTimeOffset OccurredOnUtc { get; set; }

    public DateTimeOffset? ProcessedOnUtc { get; set; }

    public string? LastErrorMessage { get; set; }

    public int AttemptCount { get; set; }

    public int MaxAttempts { get; set; }

    public DateTimeOffset? NextAttemptOnUtc { get; set; }

    #endregion

    #region Factories

    public static OutboxMessageEntity Create(Guid id, string eventType, string content, DateTimeOffset occurredOnUtc)
    {
        return new OutboxMessageEntity()
        {
            Id = id,
            EventType = eventType,
            Content = content,
            OccurredOnUtc = occurredOnUtc,
            MaxAttempts = AppConstants.MaxAttempts,
            AttemptCount = 0
        };
    }

    #endregion

    #region Methods

    public void CompleteProcessing(DateTimeOffset processedOnUtc, string? lastErrorMessage = null)
    {
        ProcessedOnUtc = processedOnUtc;
        LastErrorMessage = lastErrorMessage;
        NextAttemptOnUtc = null;
    }

    public void SetRetryProperties(int attemptCount, int maxAttempts, DateTimeOffset? nextAttemptOnUtc, string? lastErrorMessage)
    {
        AttemptCount = attemptCount;
        MaxAttempts = maxAttempts;
        NextAttemptOnUtc = nextAttemptOnUtc;
        LastErrorMessage = lastErrorMessage;
    }

    public void RecordFailedAttempt(string errorMessage, DateTimeOffset currentTime)
    {
        IncreaseAttemptCount();

        if (AttemptCount >= MaxAttempts)
        {
            LastErrorMessage = $"Max attempts ({MaxAttempts}) exceeded. Last error: {errorMessage}";
            NextAttemptOnUtc = null;
        }
        else
        {
            // Calculate exponential backoff with jitter
            var baseDelay = TimeSpan.FromSeconds(Math.Pow(2, AttemptCount - 1));
            var maxDelay = TimeSpan.FromMinutes(5);
            var jitter = TimeSpan.FromMilliseconds(Random.Shared.Next(0, 1000));
            var delay = TimeSpan.FromTicks(Math.Min(baseDelay.Ticks, maxDelay.Ticks)) + jitter;

            NextAttemptOnUtc = currentTime + delay;
            LastErrorMessage = errorMessage;
        }
    }

    public void IncreaseAttemptCount()
    {
        AttemptCount++;
    }

    public bool CanRetry(DateTimeOffset currentTime)
    {
        return AttemptCount < MaxAttempts &&
               (NextAttemptOnUtc == null || currentTime >= NextAttemptOnUtc.Value);
    }

    public bool IsPermanentlyFailed()
    {
        return AttemptCount >= MaxAttempts;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/Enums/OrderStatus.cs">
#region using

using System.ComponentModel;

#endregion

namespace Order.Domain.Enums;

public enum OrderStatus
{
    #region Fields, Properties and Indexers

    [Description("Pending")]
    Pending = 1,

    [Description("Confirmed")]
    Confirmed = 2,

    [Description("Processing")]
    Processing = 3,

    [Description("Shipped")]
    Shipped = 4,

    [Description("Delivered")]
    Delivered = 5,

    [Description("Canceled")]
    Canceled = 6,

    [Description("Refunded")]
    Refunded = 7

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/Events/OrderCancelledDomainEvent.cs">
#region using

using Order.Domain.Abstractions;
using Order.Domain.Entities;

#endregion

namespace Order.Domain.Events;

public sealed record OrderCancelledDomainEvent(OrderEntity Order) : IDomainEvent;
</file>

<file path="Services/Order/Core/Order.Domain/Events/OrderCreatedDomainEvent.cs">
#region using

using Order.Domain.Abstractions;
using Order.Domain.Entities;

#endregion

namespace Order.Domain.Events;

public sealed record OrderCreatedDomainEvent(OrderEntity Order) : IDomainEvent;
</file>

<file path="Services/Order/Core/Order.Domain/Events/OrderDeliveredDomainEvent.cs">
#region using

using Order.Domain.Abstractions;
using Order.Domain.Entities;

#endregion

namespace Order.Domain.Events;

public sealed record OrderDeliveredDomainEvent(OrderEntity Order) : IDomainEvent;
</file>

<file path="Services/Order/Core/Order.Domain/Exceptions/DomainException.cs">
namespace Order.Domain.Exceptions;

public sealed class DomainException : Exception
{
    public DomainException(string message) : base(message)
    {
    }
}
</file>

<file path="Services/Order/Core/Order.Domain/Repositories/IInboxMessageRepository.cs">
#region using

using Order.Domain.Entities;

#endregion

namespace Order.Domain.Repositories;

public interface IInboxMessageRepository : IRepository<InboxMessageEntity>
{
    #region Methods

    Task<InboxMessageEntity?> GetByMessageIdAsync(Guid messageId, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/Repositories/IOrderItemRepository.cs">
#region using

using Order.Domain.Entities;

#endregion

namespace Order.Domain.Repositories;

public interface IOrderItemRepository : IRepository<OrderItemEntity>
{
    #region Methods

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/Repositories/IOrderRepository.cs">
#region using

using Order.Domain.Entities;
using System.Linq.Expressions;

#endregion

namespace Order.Domain.Repositories;

public interface IOrderRepository : IRepository<OrderEntity>
{
    #region Methods

    Task<OrderEntity?> GetByIdWithRelationshipAsync(Guid id, CancellationToken cancellationToken = default);

    Task<List<OrderEntity>> GetByCustomerWithRelationshipAsync(Guid customerId, CancellationToken cancellationToken = default);

    Task<OrderEntity?> GetByOrderNoAsync(string orderNo, CancellationToken cancellationToken = default);

    Task<List<OrderEntity>> SearchWithRelationshipAsync(
        Expression<Func<OrderEntity, bool>> predicate,
        PaginationRequest pagination,
        CancellationToken cancellationToken = default);

    Task<List<OrderEntity>> SearchWithRelationshipAsync(Expression<Func<OrderEntity, bool>> predicate, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/Repositories/IOutboxMessageRepository.cs">
#region using

using Order.Domain.Entities;

#endregion

namespace Order.Domain.Repositories;

public interface IOutboxMessageRepository : IRepository<OutboxMessageEntity>
{
    #region Methods

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/Repositories/IRepository.cs">
#region using

using System.Linq.Expressions;

#endregion

namespace Order.Domain.Repositories;

public interface IRepository<T> where T : class
{
    #region Methods

    Task<T?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);

    Task<T?> FirstOrDefaultAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

    Task<T?> SingleOrDefaultAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

    Task<IReadOnlyList<T>> GetAllAsync(CancellationToken cancellationToken = default);

    Task<IReadOnlyList<T>> FindAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

    Task<long> CountAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

    Task<long> CountAsync(CancellationToken cancellationToken = default);

    Task<bool> AnyAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default);

    Task AddAsync(T entity, CancellationToken cancellationToken = default);

    Task AddRangeAsync(IEnumerable<T> entities, CancellationToken cancellationToken = default);

    void Update(T entity);

    void UpdateRange(IEnumerable<T> entities);

    void Remove(T entity);

    void RemoveRange(IEnumerable<T> entities);

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/ValueObjects/Address.cs">
namespace Order.Domain.ValueObjects;

public class Address
{
    #region Fields, Properties and Indexers

    public string AddressLine { get; set; } = default!;

    public string Subdivision { get; set; } = default!; // Ward / County

    public string City { get; set; } = default!;

    public string StateOrProvince { get; set; } = default!;

    public string Country { get; set; } = default!;

    public string PostalCode { get; set; } = default!;

    #endregion

    #region Ctors

    private Address(string addressLine, string subdivision, string city, string country, string stateOrProvince, string postalCode)
    {
        AddressLine = addressLine;
        Subdivision = subdivision;
        City = city;
        Country = country;
        StateOrProvince = stateOrProvince;
        PostalCode = postalCode;
    }

    #endregion

    #region Methods

    public static Address Of(
        string addressLine,
        string subdivision,
        string city,
        string country,
        string stateOrProvince,
        string postalCode)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(addressLine);
        ArgumentException.ThrowIfNullOrWhiteSpace(subdivision);
        ArgumentException.ThrowIfNullOrWhiteSpace(city);
        ArgumentException.ThrowIfNullOrWhiteSpace(country);
        ArgumentException.ThrowIfNullOrWhiteSpace(stateOrProvince);
        ArgumentException.ThrowIfNullOrWhiteSpace(postalCode);

        return new Address(addressLine, subdivision, city, country, stateOrProvince, postalCode);
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/ValueObjects/Customer.cs">
namespace Order.Domain.ValueObjects;

public class Customer
{
    #region Fields, Properties and Indexers

    public Guid? Id { get; set; }

    public string PhoneNumber { get; set; } = default!;

    public string Name { get; set; } = default!;

    public string Email { get; set; } = default!;

    #endregion

    #region Ctors

    protected Customer()
    {
    }

    #endregion

    #region Methods

    public static Customer Of(Guid? id, string phoneNumber, string name, string email)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(phoneNumber);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);
        ArgumentException.ThrowIfNullOrWhiteSpace(email);

        return new Customer
        {
            Id = id,
            PhoneNumber = phoneNumber,
            Name = name,
            Email = email
        };
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/ValueObjects/Discount.cs">
namespace Order.Domain.ValueObjects;

public class Discount
{
    #region Fields, Properties and Indexers

    public string CouponCode { get; set; }

    public decimal DiscountAmount { get; set; }

    #endregion

    #region Ctors

    private Discount(string couponCode, decimal discountAmount)
    {
        CouponCode = couponCode;
        DiscountAmount = discountAmount;
    }

    #endregion

    #region Methods

    public static Discount Of(string couponCode, decimal discountAmount)
    {
        return new Discount(couponCode, discountAmount);
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/ValueObjects/OrderNo.cs">
namespace Order.Domain.ValueObjects;

public class OrderNo
{
    #region Fields, Properties and Indexers

    public string Value { get; }

    #endregion

    #region Ctors

    private OrderNo(string value) => Value = value;

    #endregion

    #region Methods

    public static OrderNo Create()
    {
        var dateString = DateTimeOffset.Now.ToString("yyyyMMdd");
        var sequenceString = Guid.NewGuid().ToString().Split("-").First().ToUpper();
        var orderNumber = $"ORD-{dateString}-{sequenceString}";
        return new OrderNo(orderNumber);
    }

    public override string ToString() => Value;

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Domain/ValueObjects/Product.cs">
namespace Order.Domain.ValueObjects;

public class Product
{
    #region Fields, Properties and Indexers

    public Guid Id { get; set; } = default!;

    public string Name { get; set; } = default!;

    public string ImageUrl { get; set; } = default!;

    public decimal Price { get; set; } = default!;

    #endregion

    #region Ctors

    private Product() { }

    #endregion

    #region Methods

    public static Product Of(Guid id, string name, decimal price, string imageUrl)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new Product()
        {
            Id = id,
            Name = name,
            Price = price,
            ImageUrl = imageUrl
        };
    }

    #endregion

}
</file>

<file path="Services/Order/Core/Order.Domain/GlobalUsing.cs">
global using Common.Constants;
global using Common.Models;
</file>

<file path="Services/Order/Core/Order.Domain/Order.Domain.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="MediatR" />
    <PackageReference Include="Newtonsoft.Json" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Configurations/InboxMessageConfiguration.cs">
#region using

using Order.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

#endregion

namespace Order.Infrastructure.Data.Configurations;

public sealed class InboxMessageConfiguration : IEntityTypeConfiguration<InboxMessageEntity>
{
    #region Implementations

    public void Configure(EntityTypeBuilder<InboxMessageEntity> builder)
    {
        builder.ToTable("inbox_messages");

        builder.HasKey(x => x.Id);

        builder.Property(x => x.Id)
            .HasColumnName("id");

        builder.Property(x => x.EventType)
            .HasColumnName("event_type")
            .IsRequired();

        builder.Property(x => x.Content)
            .HasColumnName("content")
            .IsRequired();

        builder.Property(x => x.ReceivedOnUtc)
            .HasColumnName("received_on_utc")
            .IsRequired();

        builder.Property(x => x.ProcessedOnUtc)
            .HasColumnName("processed_on_utc");

        builder.Property(x => x.LastErrorMessage)
            .HasColumnName("last_error_message");

        builder.Property(x => x.AttemptCount)
            .HasColumnName("attempt_count")
            .HasDefaultValue(0)
            .IsRequired();

        builder.Property(x => x.MaxAttempts)
            .HasColumnName("max_attempts")
            .HasDefaultValue(3)
            .IsRequired();

        builder.Property(x => x.NextAttemptOnUtc)
            .HasColumnName("next_attempt_on_utc");

        builder.HasIndex(x => new { x.EventType });
        builder.HasIndex(x => new { x.ReceivedOnUtc });
        builder.HasIndex(x => new { x.ProcessedOnUtc });
        builder.HasIndex(x => new { x.NextAttemptOnUtc, x.ProcessedOnUtc, x.AttemptCount });
        builder.HasIndex(x => new { x.ProcessedOnUtc, x.AttemptCount, x.MaxAttempts });

    }

    #endregion

}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Configurations/OrderEntityConfiguration.cs">
#region using

using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Order.Domain.Entities;

#endregion

namespace Order.Infrastructure.Data.Configurations;

public sealed class OrderEntityConfiguration : IEntityTypeConfiguration<OrderEntity>
{
    #region Implementations

    public void Configure(EntityTypeBuilder<OrderEntity> builder)
    {
        builder.ToTable("orders");

        builder.HasKey(x => x.Id);

        builder.Property(x => x.Id)
            .HasColumnName("id");

        builder.Property(x => x.Status)
            .HasColumnName("status")
            .HasConversion<int>()
            .IsRequired();

        builder.Property(x => x.CancelReason)
            .HasColumnName("cancel_reason")
            .HasMaxLength(255);

        builder.Property(x => x.RefundReason)
            .HasColumnName("refund_reason")
            .HasMaxLength(255);

        builder.Property(x => x.CreatedOnUtc)
            .HasColumnName("created_on_utc")
            .IsRequired();

        builder.Property(x => x.CreatedBy)
            .HasColumnName("created_by")
            .HasMaxLength(50)
            .IsRequired();

        builder.Property(x => x.LastModifiedOnUtc)
            .HasColumnName("last_modified_on_utc");

        builder.Property(x => x.LastModifiedBy)
            .HasColumnName("last_modified_by")
            .HasMaxLength(50);

        // Configure Customer value object
        builder.ComplexProperty(
            o => o.Customer, b =>
            {
                b.Property(c => c.Id)
                   .HasColumnName("customer_id");

                b.Property(c => c.PhoneNumber)
                    .HasColumnName("customer_phone_number")
                    .HasMaxLength(50)
                    .IsRequired();

                b.Property(c => c.Name)
                    .HasColumnName("customer_name")
                    .HasMaxLength(255)
                    .IsRequired();

                b.Property(c => c.Email)
                    .HasColumnName("customer_email")
                    .HasMaxLength(255)
                    .IsRequired();
            });

        // Configure OrderNo value object
        builder.ComplexProperty(
            o => o.OrderNo, b =>
            {
                b.Property(on => on.Value)
                    .HasColumnName("order_no")
                    .HasMaxLength(100)
                    .IsRequired();
            });

        // Configure ShippingAddress value object
        builder.ComplexProperty(
            o => o.ShippingAddress, b =>
            {
                b.Property(a => a.AddressLine)
                    .HasColumnName("shipping_address_line")
                    .HasMaxLength(500)
                    .IsRequired();

                b.Property(a => a.Subdivision)
                    .HasColumnName("shipping_subdivision")
                    .HasMaxLength(100)
                    .IsRequired();

                b.Property(a => a.City)
                    .HasColumnName("shipping_city")
                    .HasMaxLength(100)
                    .IsRequired();

                b.Property(a => a.StateOrProvince)
                    .HasColumnName("shipping_state_or_province")
                    .HasMaxLength(100)
                    .IsRequired();

                b.Property(a => a.Country)
                    .HasColumnName("shipping_country")
                    .HasMaxLength(100)
                    .IsRequired();

                b.Property(a => a.PostalCode)
                    .HasColumnName("shipping_postal_code")
                    .HasMaxLength(20)
                    .IsRequired();
            });

        // Configure Discount value object
        builder.ComplexProperty(
            o => o.Discount, b =>
            {
                b.Property(a => a.CouponCode)
                    .HasColumnName("coupon_code")
                    .HasDefaultValue("")
                    .HasMaxLength(100);

                b.Property(a => a.DiscountAmount)
                    .HasColumnName("discount_amount")
                    .HasDefaultValue(0);
            });

        builder.Ignore(x => x.TotalPrice);
        builder.Ignore(x => x.FinalPrice);

        // Configure relationship with OrderItems
        builder.HasMany(o => o.OrderItems)
            .WithOne()
            .HasForeignKey(oi => oi.OrderId)
            .OnDelete(DeleteBehavior.Cascade);

        // Configure navigation property
        builder.Navigation(o => o.OrderItems)
            .UsePropertyAccessMode(PropertyAccessMode.Field);
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Configurations/OrderItemEntityConfiguration.cs">
#region using

using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Order.Domain.Entities;

#endregion

namespace Order.Infrastructure.Data.Configurations;

public sealed class OrderItemEntityConfiguration : IEntityTypeConfiguration<OrderItemEntity>
{
    #region Implementations

    public void Configure(EntityTypeBuilder<OrderItemEntity> builder)
    {
        builder.ToTable("order_items");

        builder.HasKey(x => x.Id);

        builder.Property(x => x.Id)
            .HasColumnName("id");

        builder.Property(x => x.OrderId)
            .HasColumnName("order_id")
            .IsRequired();

        builder.Property(x => x.Quantity)
            .HasColumnName("quantity")
            .IsRequired();

        builder.Property(x => x.CreatedOnUtc)
            .HasColumnName("created_on_utc")
            .IsRequired();

        builder.Property(x => x.CreatedBy)
            .HasColumnName("created_by")
            .HasMaxLength(50)
            .IsRequired();

        builder.Property(x => x.LastModifiedOnUtc)
            .HasColumnName("last_modified_on_utc");

        builder.Property(x => x.LastModifiedBy)
            .HasColumnName("last_modified_by")
            .HasMaxLength(50);

        // Configure Product value object
        builder.ComplexProperty(
            oi => oi.Product, b =>
            {
                b.Property(p => p.Id)
                    .HasColumnName("product_id")
                    .IsRequired();

                b.Property(p => p.Name)
                    .HasColumnName("product_name")
                    .HasMaxLength(255)
                    .IsRequired();

                b.Property(p => p.ImageUrl)
                    .HasColumnName("product_image_url")
                    .HasMaxLength(500);

                b.Property(p => p.Price)
                    .HasColumnName("product_price")
                    .IsRequired();
            });
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Configurations/OutboxMessageConfiguration.cs">
#region using

using Order.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

#endregion

namespace Order.Infrastructure.Data.Configurations;

public sealed class OutboxMessageConfiguration : IEntityTypeConfiguration<OutboxMessageEntity>
{
    #region Implementations

    public void Configure(EntityTypeBuilder<OutboxMessageEntity> builder)
    {
        builder.ToTable("outbox_messages");

        builder.HasKey(x => x.Id);

        builder.Property(x => x.Id)
            .HasColumnName("id");

        builder.Property(x => x.EventType)
            .HasColumnName("event_type")
            .IsRequired();

        builder.Property(x => x.Content)
            .HasColumnName("content")
            .IsRequired();

        builder.Property(x => x.OccurredOnUtc)
            .HasColumnName("occurred_on_utc")
            .IsRequired();

        builder.Property(x => x.ProcessedOnUtc)
            .HasColumnName("processed_on_utc");

        builder.Property(x => x.LastErrorMessage)
            .HasColumnName("last_error_message");

        builder.Property(x => x.AttemptCount)
            .HasColumnName("attempt_count")
            .HasDefaultValue(0)
            .IsRequired();

        builder.Property(x => x.MaxAttempts)
            .HasColumnName("max_attempts")
            .HasDefaultValue(3)
            .IsRequired();

        builder.Property(x => x.NextAttemptOnUtc)
            .HasColumnName("next_attempt_on_utc");

        builder.HasIndex(x => new { x.EventType });
        builder.HasIndex(x => new { x.OccurredOnUtc });
        builder.HasIndex(x => new { x.ProcessedOnUtc });
        builder.HasIndex(x => new { x.NextAttemptOnUtc, x.ProcessedOnUtc, x.AttemptCount });
        builder.HasIndex(x => new { x.ProcessedOnUtc, x.AttemptCount, x.MaxAttempts });

    }

    #endregion

}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Extensions/AuditableEntityInterceptorExtensions.cs">
#region using

using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore;

#endregion

namespace Order.Infrastructure.Data.Extensions;

public static class AuditableEntityInterceptorExtensions
{
    #region Methods

    /// <summary>
    /// Checks if an entity has changed complex properties (value objects in EF Core 8+)
    /// </summary>
    public static bool HasChangedComplexProperties(this EntityEntry entry) =>
        entry.ComplexProperties.Any(cp => cp.IsModified);

    /// <summary>
    /// Legacy method for backward compatibility - checks for both owned entities and complex properties
    /// </summary>
    public static bool HasChangedOwnedEntities(this EntityEntry entry) =>
        // Check for owned entities (legacy approach)
        entry.References.Any(r =>
            r.TargetEntry != null &&
            r.TargetEntry.Metadata.IsOwned() &&
            (r.TargetEntry.State == EntityState.Added || r.TargetEntry.State == EntityState.Modified)) ||
        // Check for complex properties (EF Core 8+ approach)
        entry.ComplexProperties.Any(cp => cp.IsModified);

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Extensions/DatabaseExtentions.cs">
#region using

using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;

#endregion

namespace Order.Infrastructure.Data.Extensions;

public static class DatabaseExtentions
{
    #region Methods

    public static async Task InitialiseDatabaseAsync(this WebApplication app)
    {
        using var scope = app.Services.CreateScope();
        var dbContext = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();

        await SeedDataAsync(dbContext);
    }

    private static async Task SeedDataAsync(ApplicationDbContext dbContext)
    {
        await Task.CompletedTask;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Interceptors/AuditableEntityInterceptor.cs">
#region using

using Order.Domain.Abstractions;
using Order.Infrastructure.Data.Extensions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;

#endregion

namespace Order.Infrastructure.Data.Interceptors;

public sealed class AuditableEntityInterceptor : SaveChangesInterceptor
{
    #region Override Methods

    public override InterceptionResult<int> SavingChanges(DbContextEventData eventData, InterceptionResult<int> result)
    {
        UpdateEntities(eventData.Context);
        return base.SavingChanges(eventData, result);
    }

    public override ValueTask<InterceptionResult<int>> SavingChangesAsync(DbContextEventData eventData,
        InterceptionResult<int> result,
        CancellationToken cancellationToken = default)
    {
        UpdateEntities(eventData.Context);
        return base.SavingChangesAsync(eventData, result, cancellationToken);
    }

    #endregion

    #region Methods

    public static void UpdateEntities(DbContext? context)
    {
        if (context == null) return;

        foreach (var entry in context.ChangeTracker.Entries<IAuditable>())
        {
            if (entry.State == EntityState.Added)
            {
                // For new entities, set both created and modified timestamps
                entry.Entity.CreatedOnUtc = DateTimeOffset.UtcNow;
                entry.Entity.LastModifiedOnUtc = DateTimeOffset.UtcNow;
            }
            else if (entry.State == EntityState.Modified || entry.HasChangedOwnedEntities())
            {
                // For existing entities, only update the modified timestamp
                entry.Entity.LastModifiedOnUtc = DateTimeOffset.UtcNow;
            }
        }
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Interceptors/DispatchDomainEventsInterceptor.cs">
#region using

using MediatR;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Order.Domain.Abstractions;

#endregion

namespace Order.Infrastructure.Data.Interceptors;

public class DispatchDomainEventsInterceptor(IMediator mediator) : SaveChangesInterceptor
{
    public override InterceptionResult<int> SavingChanges(DbContextEventData eventData, InterceptionResult<int> result)
    {
        DispatchDomainEvents(eventData.Context).GetAwaiter().GetResult();
        return base.SavingChanges(eventData, result);
    }

    public override async ValueTask<InterceptionResult<int>> SavingChangesAsync(
        DbContextEventData eventData,
        InterceptionResult<int> result,
        CancellationToken cancellationToken = default)
    {
        await DispatchDomainEvents(eventData.Context);
        return await base.SavingChangesAsync(eventData, result, cancellationToken);
    }

    public async Task DispatchDomainEvents(DbContext? context)
    {
        if (context == null) return;

        var aggregates = context.ChangeTracker
            .Entries<IAggregate>()
            .Where(a => a.Entity.DomainEvents.Any())
            .Select(a => a.Entity);

        var domainEvents = aggregates
            .SelectMany(a => a.DomainEvents)
            .ToList();

        aggregates.ToList().ForEach(a => a.ClearDomainEvents());

        foreach (var domainEvent in domainEvents)
            await mediator.Publish(domainEvent);
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Migrations/20251119100113_init_database.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Order.Infrastructure.Data.Migrations
{
    /// <inheritdoc />
    public partial class init_database : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "orders",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uniqueidentifier", nullable: false),
                    status = table.Column<int>(type: "int", nullable: false),
                    customer_email = table.Column<string>(type: "nvarchar(255)", maxLength: 255, nullable: false),
                    customer_id = table.Column<Guid>(type: "uniqueidentifier", nullable: true),
                    customer_name = table.Column<string>(type: "nvarchar(255)", maxLength: 255, nullable: false),
                    customer_phone_number = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: false),
                    coupon_code = table.Column<string>(type: "nvarchar(100)", maxLength: 100, nullable: false, defaultValue: ""),
                    discount_amount = table.Column<decimal>(type: "decimal(18,2)", nullable: false, defaultValue: 0m),
                    order_no = table.Column<string>(type: "nvarchar(100)", maxLength: 100, nullable: false),
                    shipping_address_line = table.Column<string>(type: "nvarchar(500)", maxLength: 500, nullable: false),
                    shipping_country = table.Column<string>(type: "nvarchar(100)", maxLength: 100, nullable: false),
                    shipping_email = table.Column<string>(type: "nvarchar(255)", maxLength: 255, nullable: true),
                    shipping_name = table.Column<string>(type: "nvarchar(100)", maxLength: 100, nullable: false),
                    shipping_state = table.Column<string>(type: "nvarchar(100)", maxLength: 100, nullable: false),
                    shipping_zip_code = table.Column<string>(type: "nvarchar(20)", maxLength: 20, nullable: false),
                    created_on_utc = table.Column<DateTimeOffset>(type: "datetimeoffset", nullable: false),
                    created_by = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: false),
                    last_modified_on_utc = table.Column<DateTimeOffset>(type: "datetimeoffset", nullable: true),
                    last_modified_by = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_orders", x => x.id);
                });

            migrationBuilder.CreateTable(
                name: "outbox_messages",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uniqueidentifier", nullable: false),
                    event_type = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    content = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    occurred_on_utc = table.Column<DateTimeOffset>(type: "datetimeoffset", nullable: false),
                    processed_on_utc = table.Column<DateTimeOffset>(type: "datetimeoffset", nullable: true),
                    last_error_message = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    claimed_on_utc = table.Column<DateTimeOffset>(type: "datetimeoffset", nullable: true),
                    attempt_count = table.Column<int>(type: "int", nullable: false, defaultValue: 0),
                    max_attempts = table.Column<int>(type: "int", nullable: false, defaultValue: 3),
                    next_attempt_on_utc = table.Column<DateTimeOffset>(type: "datetimeoffset", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_outbox_messages", x => x.id);
                });

            migrationBuilder.CreateTable(
                name: "order_items",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uniqueidentifier", nullable: false),
                    order_id = table.Column<Guid>(type: "uniqueidentifier", nullable: false),
                    quantity = table.Column<int>(type: "int", nullable: false),
                    LineTotal = table.Column<decimal>(type: "decimal(18,2)", nullable: false),
                    product_id = table.Column<Guid>(type: "uniqueidentifier", nullable: false),
                    product_image_url = table.Column<string>(type: "nvarchar(500)", maxLength: 500, nullable: false),
                    product_name = table.Column<string>(type: "nvarchar(255)", maxLength: 255, nullable: false),
                    product_price = table.Column<decimal>(type: "decimal(18,2)", nullable: false),
                    created_on_utc = table.Column<DateTimeOffset>(type: "datetimeoffset", nullable: false),
                    created_by = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: false),
                    last_modified_on_utc = table.Column<DateTimeOffset>(type: "datetimeoffset", nullable: true),
                    last_modified_by = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_order_items", x => x.id);
                    table.ForeignKey(
                        name: "FK_order_items_orders_order_id",
                        column: x => x.order_id,
                        principalTable: "orders",
                        principalColumn: "id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateIndex(
                name: "IX_order_items_order_id",
                table: "order_items",
                column: "order_id");

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_claimed_on_utc",
                table: "outbox_messages",
                column: "claimed_on_utc");

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_event_type",
                table: "outbox_messages",
                column: "event_type");

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_next_attempt_on_utc_processed_on_utc_attempt_count",
                table: "outbox_messages",
                columns: new[] { "next_attempt_on_utc", "processed_on_utc", "attempt_count" });

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_occurred_on_utc",
                table: "outbox_messages",
                column: "occurred_on_utc");

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_processed_on_utc",
                table: "outbox_messages",
                column: "processed_on_utc");

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_processed_on_utc_attempt_count_max_attempts",
                table: "outbox_messages",
                columns: new[] { "processed_on_utc", "attempt_count", "max_attempts" });

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_processed_on_utc_claimed_on_utc",
                table: "outbox_messages",
                columns: new[] { "processed_on_utc", "claimed_on_utc" });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "order_items");

            migrationBuilder.DropTable(
                name: "outbox_messages");

            migrationBuilder.DropTable(
                name: "orders");
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Migrations/20251119100113_init_database.Designer.cs">
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Order.Infrastructure.Data;

#nullable disable

namespace Order.Infrastructure.Data.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    [Migration("20251119100113_init_database")]
    partial class init_database
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.6")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<int>("Status")
                        .HasColumnType("int")
                        .HasColumnName("status");

                    b.ComplexProperty<Dictionary<string, object>>("Customer", "Order.Domain.Entities.OrderEntity.Customer#Customer", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Email")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_email");

                            b1.Property<Guid?>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("customer_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_name");

                            b1.Property<string>("PhoneNumber")
                                .IsRequired()
                                .HasMaxLength(50)
                                .HasColumnType("nvarchar(50)")
                                .HasColumnName("customer_phone_number");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("Discount", "Order.Domain.Entities.OrderEntity.Discount#Discount", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("CouponCode")
                                .IsRequired()
                                .ValueGeneratedOnAdd()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasDefaultValue("")
                                .HasColumnName("coupon_code");

                            b1.Property<decimal>("DiscountAmount")
                                .ValueGeneratedOnAdd()
                                .HasColumnType("decimal(18,2)")
                                .HasDefaultValue(0m)
                                .HasColumnName("discount_amount");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("OrderNo", "Order.Domain.Entities.OrderEntity.OrderNo#OrderNo", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Value")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("order_no");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("ShippingAddress", "Order.Domain.Entities.OrderEntity.ShippingAddress#Address", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("AddressLine")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("shipping_address_line");

                            b1.Property<string>("Country")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_country");

                            b1.Property<string>("EmailAddress")
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("shipping_email");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_name");

                            b1.Property<string>("State")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_state");

                            b1.Property<string>("ZipCode")
                                .IsRequired()
                                .HasMaxLength(20)
                                .HasColumnType("nvarchar(20)")
                                .HasColumnName("shipping_zip_code");
                        });

                    b.HasKey("Id");

                    b.ToTable("orders", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<decimal>("LineTotal")
                        .HasColumnType("decimal(18,2)");

                    b.Property<Guid>("OrderId")
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("order_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Order.Domain.Entities.OrderItemEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("product_id");

                            b1.Property<string>("ImageUrl")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("product_image_url");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("product_name");

                            b1.Property<decimal>("Price")
                                .HasColumnType("decimal(18,2)")
                                .HasColumnName("product_price");
                        });

                    b.HasKey("Id");

                    b.HasIndex("OrderId");

                    b.ToTable("order_items", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OutboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<int>("AttemptCount")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(0)
                        .HasColumnName("attempt_count");

                    b.Property<DateTimeOffset?>("ClaimedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("claimed_on_utc");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("last_error_message");

                    b.Property<int>("MaxAttempts")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(3)
                        .HasColumnName("max_attempts");

                    b.Property<DateTimeOffset?>("NextAttemptOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("next_attempt_on_utc");

                    b.Property<DateTimeOffset>("OccurredOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("occurred_on_utc");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("processed_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("ClaimedOnUtc");

                    b.HasIndex("EventType");

                    b.HasIndex("OccurredOnUtc");

                    b.HasIndex("ProcessedOnUtc");

                    b.HasIndex("ProcessedOnUtc", "ClaimedOnUtc");

                    b.HasIndex("NextAttemptOnUtc", "ProcessedOnUtc", "AttemptCount");

                    b.HasIndex("ProcessedOnUtc", "AttemptCount", "MaxAttempts");

                    b.ToTable("outbox_messages", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.HasOne("Order.Domain.Entities.OrderEntity", null)
                        .WithMany("OrderItems")
                        .HasForeignKey("OrderId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Navigation("OrderItems");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Migrations/20251211081244_add_reason_fields.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Order.Infrastructure.Data.Migrations
{
    /// <inheritdoc />
    public partial class add_reason_fields : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<string>(
                name: "Notes",
                table: "orders",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddColumn<string>(
                name: "cancel_reason",
                table: "orders",
                type: "nvarchar(255)",
                maxLength: 255,
                nullable: true);

            migrationBuilder.AddColumn<string>(
                name: "refund_reason",
                table: "orders",
                type: "nvarchar(255)",
                maxLength: 255,
                nullable: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "Notes",
                table: "orders");

            migrationBuilder.DropColumn(
                name: "cancel_reason",
                table: "orders");

            migrationBuilder.DropColumn(
                name: "refund_reason",
                table: "orders");
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Migrations/20251211081244_add_reason_fields.Designer.cs">
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Order.Infrastructure.Data;

#nullable disable

namespace Order.Infrastructure.Data.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    [Migration("20251211081244_add_reason_fields")]
    partial class add_reason_fields
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.6")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CancelReason")
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)")
                        .HasColumnName("cancel_reason");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("RefundReason")
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)")
                        .HasColumnName("refund_reason");

                    b.Property<int>("Status")
                        .HasColumnType("int")
                        .HasColumnName("status");

                    b.ComplexProperty<Dictionary<string, object>>("Customer", "Order.Domain.Entities.OrderEntity.Customer#Customer", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Email")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_email");

                            b1.Property<Guid?>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("customer_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_name");

                            b1.Property<string>("PhoneNumber")
                                .IsRequired()
                                .HasMaxLength(50)
                                .HasColumnType("nvarchar(50)")
                                .HasColumnName("customer_phone_number");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("Discount", "Order.Domain.Entities.OrderEntity.Discount#Discount", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("CouponCode")
                                .IsRequired()
                                .ValueGeneratedOnAdd()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasDefaultValue("")
                                .HasColumnName("coupon_code");

                            b1.Property<decimal>("DiscountAmount")
                                .ValueGeneratedOnAdd()
                                .HasColumnType("decimal(18,2)")
                                .HasDefaultValue(0m)
                                .HasColumnName("discount_amount");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("OrderNo", "Order.Domain.Entities.OrderEntity.OrderNo#OrderNo", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Value")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("order_no");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("ShippingAddress", "Order.Domain.Entities.OrderEntity.ShippingAddress#Address", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("AddressLine")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("shipping_address_line");

                            b1.Property<string>("Country")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_country");

                            b1.Property<string>("EmailAddress")
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("shipping_email");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_name");

                            b1.Property<string>("State")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_state");

                            b1.Property<string>("ZipCode")
                                .IsRequired()
                                .HasMaxLength(20)
                                .HasColumnType("nvarchar(20)")
                                .HasColumnName("shipping_zip_code");
                        });

                    b.HasKey("Id");

                    b.ToTable("orders", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<decimal>("LineTotal")
                        .HasColumnType("decimal(18,2)");

                    b.Property<Guid>("OrderId")
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("order_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Order.Domain.Entities.OrderItemEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("product_id");

                            b1.Property<string>("ImageUrl")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("product_image_url");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("product_name");

                            b1.Property<decimal>("Price")
                                .HasColumnType("decimal(18,2)")
                                .HasColumnName("product_price");
                        });

                    b.HasKey("Id");

                    b.HasIndex("OrderId");

                    b.ToTable("order_items", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OutboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<int>("AttemptCount")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(0)
                        .HasColumnName("attempt_count");

                    b.Property<DateTimeOffset?>("ClaimedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("claimed_on_utc");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("last_error_message");

                    b.Property<int>("MaxAttempts")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(3)
                        .HasColumnName("max_attempts");

                    b.Property<DateTimeOffset?>("NextAttemptOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("next_attempt_on_utc");

                    b.Property<DateTimeOffset>("OccurredOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("occurred_on_utc");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("processed_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("ClaimedOnUtc");

                    b.HasIndex("EventType");

                    b.HasIndex("OccurredOnUtc");

                    b.HasIndex("ProcessedOnUtc");

                    b.HasIndex("ProcessedOnUtc", "ClaimedOnUtc");

                    b.HasIndex("NextAttemptOnUtc", "ProcessedOnUtc", "AttemptCount");

                    b.HasIndex("ProcessedOnUtc", "AttemptCount", "MaxAttempts");

                    b.ToTable("outbox_messages", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.HasOne("Order.Domain.Entities.OrderEntity", null)
                        .WithMany("OrderItems")
                        .HasForeignKey("OrderId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Navigation("OrderItems");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Migrations/20251227060709_update_address.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Order.Infrastructure.Data.Migrations
{
    /// <inheritdoc />
    public partial class update_address : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "shipping_email",
                table: "orders");

            migrationBuilder.RenameColumn(
                name: "shipping_name",
                table: "orders",
                newName: "shipping_ward");

            migrationBuilder.AddColumn<string>(
                name: "shipping_city",
                table: "orders",
                type: "nvarchar(100)",
                maxLength: 100,
                nullable: false,
                defaultValue: "");

            migrationBuilder.AddColumn<string>(
                name: "shipping_district",
                table: "orders",
                type: "nvarchar(100)",
                maxLength: 100,
                nullable: false,
                defaultValue: "");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "shipping_city",
                table: "orders");

            migrationBuilder.DropColumn(
                name: "shipping_district",
                table: "orders");

            migrationBuilder.RenameColumn(
                name: "shipping_ward",
                table: "orders",
                newName: "shipping_name");

            migrationBuilder.AddColumn<string>(
                name: "shipping_email",
                table: "orders",
                type: "nvarchar(255)",
                maxLength: 255,
                nullable: true);
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Migrations/20251227060709_update_address.Designer.cs">
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Order.Infrastructure.Data;

#nullable disable

namespace Order.Infrastructure.Data.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    [Migration("20251227060709_update_address")]
    partial class update_address
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.6")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CancelReason")
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)")
                        .HasColumnName("cancel_reason");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("RefundReason")
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)")
                        .HasColumnName("refund_reason");

                    b.Property<int>("Status")
                        .HasColumnType("int")
                        .HasColumnName("status");

                    b.ComplexProperty<Dictionary<string, object>>("Customer", "Order.Domain.Entities.OrderEntity.Customer#Customer", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Email")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_email");

                            b1.Property<Guid?>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("customer_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_name");

                            b1.Property<string>("PhoneNumber")
                                .IsRequired()
                                .HasMaxLength(50)
                                .HasColumnType("nvarchar(50)")
                                .HasColumnName("customer_phone_number");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("Discount", "Order.Domain.Entities.OrderEntity.Discount#Discount", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("CouponCode")
                                .IsRequired()
                                .ValueGeneratedOnAdd()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasDefaultValue("")
                                .HasColumnName("coupon_code");

                            b1.Property<decimal>("DiscountAmount")
                                .ValueGeneratedOnAdd()
                                .HasColumnType("decimal(18,2)")
                                .HasDefaultValue(0m)
                                .HasColumnName("discount_amount");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("OrderNo", "Order.Domain.Entities.OrderEntity.OrderNo#OrderNo", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Value")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("order_no");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("ShippingAddress", "Order.Domain.Entities.OrderEntity.ShippingAddress#Address", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("AddressLine")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("shipping_address_line");

                            b1.Property<string>("City")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_city");

                            b1.Property<string>("Country")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_country");

                            b1.Property<string>("District")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_district");

                            b1.Property<string>("State")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_state");

                            b1.Property<string>("Ward")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_ward");

                            b1.Property<string>("ZipCode")
                                .IsRequired()
                                .HasMaxLength(20)
                                .HasColumnType("nvarchar(20)")
                                .HasColumnName("shipping_zip_code");
                        });

                    b.HasKey("Id");

                    b.ToTable("orders", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<decimal>("LineTotal")
                        .HasColumnType("decimal(18,2)");

                    b.Property<Guid>("OrderId")
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("order_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Order.Domain.Entities.OrderItemEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("product_id");

                            b1.Property<string>("ImageUrl")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("product_image_url");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("product_name");

                            b1.Property<decimal>("Price")
                                .HasColumnType("decimal(18,2)")
                                .HasColumnName("product_price");
                        });

                    b.HasKey("Id");

                    b.HasIndex("OrderId");

                    b.ToTable("order_items", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OutboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<int>("AttemptCount")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(0)
                        .HasColumnName("attempt_count");

                    b.Property<DateTimeOffset?>("ClaimedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("claimed_on_utc");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("last_error_message");

                    b.Property<int>("MaxAttempts")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(3)
                        .HasColumnName("max_attempts");

                    b.Property<DateTimeOffset?>("NextAttemptOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("next_attempt_on_utc");

                    b.Property<DateTimeOffset>("OccurredOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("occurred_on_utc");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("processed_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("ClaimedOnUtc");

                    b.HasIndex("EventType");

                    b.HasIndex("OccurredOnUtc");

                    b.HasIndex("ProcessedOnUtc");

                    b.HasIndex("ProcessedOnUtc", "ClaimedOnUtc");

                    b.HasIndex("NextAttemptOnUtc", "ProcessedOnUtc", "AttemptCount");

                    b.HasIndex("ProcessedOnUtc", "AttemptCount", "MaxAttempts");

                    b.ToTable("outbox_messages", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.HasOne("Order.Domain.Entities.OrderEntity", null)
                        .WithMany("OrderItems")
                        .HasForeignKey("OrderId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Navigation("OrderItems");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Migrations/20251227065035_update_order_address.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Order.Infrastructure.Data.Migrations
{
    /// <inheritdoc />
    public partial class update_order_address : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "shipping_district",
                table: "orders");

            migrationBuilder.RenameColumn(
                name: "shipping_zip_code",
                table: "orders",
                newName: "shipping_postal_code");

            migrationBuilder.RenameColumn(
                name: "shipping_ward",
                table: "orders",
                newName: "shipping_subdivision");

            migrationBuilder.RenameColumn(
                name: "shipping_state",
                table: "orders",
                newName: "shipping_state_or_province");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.RenameColumn(
                name: "shipping_subdivision",
                table: "orders",
                newName: "shipping_ward");

            migrationBuilder.RenameColumn(
                name: "shipping_state_or_province",
                table: "orders",
                newName: "shipping_state");

            migrationBuilder.RenameColumn(
                name: "shipping_postal_code",
                table: "orders",
                newName: "shipping_zip_code");

            migrationBuilder.AddColumn<string>(
                name: "shipping_district",
                table: "orders",
                type: "nvarchar(100)",
                maxLength: 100,
                nullable: false,
                defaultValue: "");
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Migrations/20251227065035_update_order_address.Designer.cs">
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Order.Infrastructure.Data;

#nullable disable

namespace Order.Infrastructure.Data.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    [Migration("20251227065035_update_order_address")]
    partial class update_order_address
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.6")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CancelReason")
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)")
                        .HasColumnName("cancel_reason");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("RefundReason")
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)")
                        .HasColumnName("refund_reason");

                    b.Property<int>("Status")
                        .HasColumnType("int")
                        .HasColumnName("status");

                    b.ComplexProperty<Dictionary<string, object>>("Customer", "Order.Domain.Entities.OrderEntity.Customer#Customer", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Email")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_email");

                            b1.Property<Guid?>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("customer_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_name");

                            b1.Property<string>("PhoneNumber")
                                .IsRequired()
                                .HasMaxLength(50)
                                .HasColumnType("nvarchar(50)")
                                .HasColumnName("customer_phone_number");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("Discount", "Order.Domain.Entities.OrderEntity.Discount#Discount", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("CouponCode")
                                .IsRequired()
                                .ValueGeneratedOnAdd()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasDefaultValue("")
                                .HasColumnName("coupon_code");

                            b1.Property<decimal>("DiscountAmount")
                                .ValueGeneratedOnAdd()
                                .HasColumnType("decimal(18,2)")
                                .HasDefaultValue(0m)
                                .HasColumnName("discount_amount");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("OrderNo", "Order.Domain.Entities.OrderEntity.OrderNo#OrderNo", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Value")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("order_no");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("ShippingAddress", "Order.Domain.Entities.OrderEntity.ShippingAddress#Address", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("AddressLine")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("shipping_address_line");

                            b1.Property<string>("City")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_city");

                            b1.Property<string>("Country")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_country");

                            b1.Property<string>("PostalCode")
                                .IsRequired()
                                .HasMaxLength(20)
                                .HasColumnType("nvarchar(20)")
                                .HasColumnName("shipping_postal_code");

                            b1.Property<string>("StateOrProvince")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_state_or_province");

                            b1.Property<string>("Subdivision")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_subdivision");
                        });

                    b.HasKey("Id");

                    b.ToTable("orders", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<decimal>("LineTotal")
                        .HasColumnType("decimal(18,2)");

                    b.Property<Guid>("OrderId")
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("order_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Order.Domain.Entities.OrderItemEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("product_id");

                            b1.Property<string>("ImageUrl")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("product_image_url");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("product_name");

                            b1.Property<decimal>("Price")
                                .HasColumnType("decimal(18,2)")
                                .HasColumnName("product_price");
                        });

                    b.HasKey("Id");

                    b.HasIndex("OrderId");

                    b.ToTable("order_items", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OutboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<int>("AttemptCount")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(0)
                        .HasColumnName("attempt_count");

                    b.Property<DateTimeOffset?>("ClaimedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("claimed_on_utc");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("last_error_message");

                    b.Property<int>("MaxAttempts")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(3)
                        .HasColumnName("max_attempts");

                    b.Property<DateTimeOffset?>("NextAttemptOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("next_attempt_on_utc");

                    b.Property<DateTimeOffset>("OccurredOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("occurred_on_utc");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("processed_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("ClaimedOnUtc");

                    b.HasIndex("EventType");

                    b.HasIndex("OccurredOnUtc");

                    b.HasIndex("ProcessedOnUtc");

                    b.HasIndex("ProcessedOnUtc", "ClaimedOnUtc");

                    b.HasIndex("NextAttemptOnUtc", "ProcessedOnUtc", "AttemptCount");

                    b.HasIndex("ProcessedOnUtc", "AttemptCount", "MaxAttempts");

                    b.ToTable("outbox_messages", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.HasOne("Order.Domain.Entities.OrderEntity", null)
                        .WithMany("OrderItems")
                        .HasForeignKey("OrderId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Navigation("OrderItems");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Migrations/20251229085353_update_outbox_msg.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Order.Infrastructure.Data.Migrations
{
    /// <inheritdoc />
    public partial class update_outbox_msg : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropIndex(
                name: "IX_outbox_messages_claimed_on_utc",
                table: "outbox_messages");

            migrationBuilder.DropIndex(
                name: "IX_outbox_messages_processed_on_utc_claimed_on_utc",
                table: "outbox_messages");

            migrationBuilder.DropColumn(
                name: "claimed_on_utc",
                table: "outbox_messages");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<DateTimeOffset>(
                name: "claimed_on_utc",
                table: "outbox_messages",
                type: "datetimeoffset",
                nullable: true);

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_claimed_on_utc",
                table: "outbox_messages",
                column: "claimed_on_utc");

            migrationBuilder.CreateIndex(
                name: "IX_outbox_messages_processed_on_utc_claimed_on_utc",
                table: "outbox_messages",
                columns: new[] { "processed_on_utc", "claimed_on_utc" });
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Migrations/20251229085353_update_outbox_msg.Designer.cs">
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Order.Infrastructure.Data;

#nullable disable

namespace Order.Infrastructure.Data.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    [Migration("20251229085353_update_outbox_msg")]
    partial class update_outbox_msg
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.6")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CancelReason")
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)")
                        .HasColumnName("cancel_reason");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("RefundReason")
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)")
                        .HasColumnName("refund_reason");

                    b.Property<int>("Status")
                        .HasColumnType("int")
                        .HasColumnName("status");

                    b.ComplexProperty<Dictionary<string, object>>("Customer", "Order.Domain.Entities.OrderEntity.Customer#Customer", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Email")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_email");

                            b1.Property<Guid?>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("customer_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_name");

                            b1.Property<string>("PhoneNumber")
                                .IsRequired()
                                .HasMaxLength(50)
                                .HasColumnType("nvarchar(50)")
                                .HasColumnName("customer_phone_number");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("Discount", "Order.Domain.Entities.OrderEntity.Discount#Discount", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("CouponCode")
                                .IsRequired()
                                .ValueGeneratedOnAdd()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasDefaultValue("")
                                .HasColumnName("coupon_code");

                            b1.Property<decimal>("DiscountAmount")
                                .ValueGeneratedOnAdd()
                                .HasColumnType("decimal(18,2)")
                                .HasDefaultValue(0m)
                                .HasColumnName("discount_amount");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("OrderNo", "Order.Domain.Entities.OrderEntity.OrderNo#OrderNo", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Value")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("order_no");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("ShippingAddress", "Order.Domain.Entities.OrderEntity.ShippingAddress#Address", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("AddressLine")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("shipping_address_line");

                            b1.Property<string>("City")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_city");

                            b1.Property<string>("Country")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_country");

                            b1.Property<string>("PostalCode")
                                .IsRequired()
                                .HasMaxLength(20)
                                .HasColumnType("nvarchar(20)")
                                .HasColumnName("shipping_postal_code");

                            b1.Property<string>("StateOrProvince")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_state_or_province");

                            b1.Property<string>("Subdivision")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_subdivision");
                        });

                    b.HasKey("Id");

                    b.ToTable("orders", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<decimal>("LineTotal")
                        .HasColumnType("decimal(18,2)");

                    b.Property<Guid>("OrderId")
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("order_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Order.Domain.Entities.OrderItemEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("product_id");

                            b1.Property<string>("ImageUrl")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("product_image_url");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("product_name");

                            b1.Property<decimal>("Price")
                                .HasColumnType("decimal(18,2)")
                                .HasColumnName("product_price");
                        });

                    b.HasKey("Id");

                    b.HasIndex("OrderId");

                    b.ToTable("order_items", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OutboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<int>("AttemptCount")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(0)
                        .HasColumnName("attempt_count");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("last_error_message");

                    b.Property<int>("MaxAttempts")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(3)
                        .HasColumnName("max_attempts");

                    b.Property<DateTimeOffset?>("NextAttemptOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("next_attempt_on_utc");

                    b.Property<DateTimeOffset>("OccurredOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("occurred_on_utc");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("processed_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("EventType");

                    b.HasIndex("OccurredOnUtc");

                    b.HasIndex("ProcessedOnUtc");

                    b.HasIndex("NextAttemptOnUtc", "ProcessedOnUtc", "AttemptCount");

                    b.HasIndex("ProcessedOnUtc", "AttemptCount", "MaxAttempts");

                    b.ToTable("outbox_messages", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.HasOne("Order.Domain.Entities.OrderEntity", null)
                        .WithMany("OrderItems")
                        .HasForeignKey("OrderId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Navigation("OrderItems");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Migrations/20260106125029_add_inbox.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Order.Infrastructure.Data.Migrations
{
    /// <inheritdoc />
    public partial class add_inbox : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "inbox_messages",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uniqueidentifier", nullable: false),
                    event_type = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    content = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    received_on_utc = table.Column<DateTimeOffset>(type: "datetimeoffset", nullable: false),
                    processed_on_utc = table.Column<DateTimeOffset>(type: "datetimeoffset", nullable: true),
                    last_error_message = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    attempt_count = table.Column<int>(type: "int", nullable: false, defaultValue: 0),
                    max_attempts = table.Column<int>(type: "int", nullable: false, defaultValue: 3),
                    next_attempt_on_utc = table.Column<DateTimeOffset>(type: "datetimeoffset", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_inbox_messages", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "IX_inbox_messages_event_type",
                table: "inbox_messages",
                column: "event_type");

            migrationBuilder.CreateIndex(
                name: "IX_inbox_messages_next_attempt_on_utc_processed_on_utc_attempt_count",
                table: "inbox_messages",
                columns: new[] { "next_attempt_on_utc", "processed_on_utc", "attempt_count" });

            migrationBuilder.CreateIndex(
                name: "IX_inbox_messages_processed_on_utc",
                table: "inbox_messages",
                column: "processed_on_utc");

            migrationBuilder.CreateIndex(
                name: "IX_inbox_messages_processed_on_utc_attempt_count_max_attempts",
                table: "inbox_messages",
                columns: new[] { "processed_on_utc", "attempt_count", "max_attempts" });

            migrationBuilder.CreateIndex(
                name: "IX_inbox_messages_received_on_utc",
                table: "inbox_messages",
                column: "received_on_utc");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "inbox_messages");
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Migrations/20260106125029_add_inbox.Designer.cs">
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Order.Infrastructure.Data;

#nullable disable

namespace Order.Infrastructure.Data.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    [Migration("20260106125029_add_inbox")]
    partial class add_inbox
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.6")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("Order.Domain.Entities.InboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<int>("AttemptCount")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(0)
                        .HasColumnName("attempt_count");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("last_error_message");

                    b.Property<int>("MaxAttempts")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(3)
                        .HasColumnName("max_attempts");

                    b.Property<DateTimeOffset?>("NextAttemptOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("next_attempt_on_utc");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("processed_on_utc");

                    b.Property<DateTimeOffset>("ReceivedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("received_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("EventType");

                    b.HasIndex("ProcessedOnUtc");

                    b.HasIndex("ReceivedOnUtc");

                    b.HasIndex("NextAttemptOnUtc", "ProcessedOnUtc", "AttemptCount");

                    b.HasIndex("ProcessedOnUtc", "AttemptCount", "MaxAttempts");

                    b.ToTable("inbox_messages", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CancelReason")
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)")
                        .HasColumnName("cancel_reason");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("RefundReason")
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)")
                        .HasColumnName("refund_reason");

                    b.Property<int>("Status")
                        .HasColumnType("int")
                        .HasColumnName("status");

                    b.ComplexProperty<Dictionary<string, object>>("Customer", "Order.Domain.Entities.OrderEntity.Customer#Customer", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Email")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_email");

                            b1.Property<Guid?>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("customer_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_name");

                            b1.Property<string>("PhoneNumber")
                                .IsRequired()
                                .HasMaxLength(50)
                                .HasColumnType("nvarchar(50)")
                                .HasColumnName("customer_phone_number");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("Discount", "Order.Domain.Entities.OrderEntity.Discount#Discount", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("CouponCode")
                                .IsRequired()
                                .ValueGeneratedOnAdd()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasDefaultValue("")
                                .HasColumnName("coupon_code");

                            b1.Property<decimal>("DiscountAmount")
                                .ValueGeneratedOnAdd()
                                .HasColumnType("decimal(18,2)")
                                .HasDefaultValue(0m)
                                .HasColumnName("discount_amount");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("OrderNo", "Order.Domain.Entities.OrderEntity.OrderNo#OrderNo", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Value")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("order_no");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("ShippingAddress", "Order.Domain.Entities.OrderEntity.ShippingAddress#Address", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("AddressLine")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("shipping_address_line");

                            b1.Property<string>("City")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_city");

                            b1.Property<string>("Country")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_country");

                            b1.Property<string>("PostalCode")
                                .IsRequired()
                                .HasMaxLength(20)
                                .HasColumnType("nvarchar(20)")
                                .HasColumnName("shipping_postal_code");

                            b1.Property<string>("StateOrProvince")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_state_or_province");

                            b1.Property<string>("Subdivision")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_subdivision");
                        });

                    b.HasKey("Id");

                    b.ToTable("orders", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<decimal>("LineTotal")
                        .HasColumnType("decimal(18,2)");

                    b.Property<Guid>("OrderId")
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("order_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Order.Domain.Entities.OrderItemEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("product_id");

                            b1.Property<string>("ImageUrl")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("product_image_url");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("product_name");

                            b1.Property<decimal>("Price")
                                .HasColumnType("decimal(18,2)")
                                .HasColumnName("product_price");
                        });

                    b.HasKey("Id");

                    b.HasIndex("OrderId");

                    b.ToTable("order_items", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OutboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<int>("AttemptCount")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(0)
                        .HasColumnName("attempt_count");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("last_error_message");

                    b.Property<int>("MaxAttempts")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(3)
                        .HasColumnName("max_attempts");

                    b.Property<DateTimeOffset?>("NextAttemptOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("next_attempt_on_utc");

                    b.Property<DateTimeOffset>("OccurredOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("occurred_on_utc");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("processed_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("EventType");

                    b.HasIndex("OccurredOnUtc");

                    b.HasIndex("ProcessedOnUtc");

                    b.HasIndex("NextAttemptOnUtc", "ProcessedOnUtc", "AttemptCount");

                    b.HasIndex("ProcessedOnUtc", "AttemptCount", "MaxAttempts");

                    b.ToTable("outbox_messages", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.HasOne("Order.Domain.Entities.OrderEntity", null)
                        .WithMany("OrderItems")
                        .HasForeignKey("OrderId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Navigation("OrderItems");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/Migrations/ApplicationDbContextModelSnapshot.cs">
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Order.Infrastructure.Data;

#nullable disable

namespace Order.Infrastructure.Data.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    partial class ApplicationDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.6")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("Order.Domain.Entities.InboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<int>("AttemptCount")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(0)
                        .HasColumnName("attempt_count");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("last_error_message");

                    b.Property<int>("MaxAttempts")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(3)
                        .HasColumnName("max_attempts");

                    b.Property<DateTimeOffset?>("NextAttemptOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("next_attempt_on_utc");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("processed_on_utc");

                    b.Property<DateTimeOffset>("ReceivedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("received_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("EventType");

                    b.HasIndex("ProcessedOnUtc");

                    b.HasIndex("ReceivedOnUtc");

                    b.HasIndex("NextAttemptOnUtc", "ProcessedOnUtc", "AttemptCount");

                    b.HasIndex("ProcessedOnUtc", "AttemptCount", "MaxAttempts");

                    b.ToTable("inbox_messages", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CancelReason")
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)")
                        .HasColumnName("cancel_reason");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<string>("Notes")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("RefundReason")
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)")
                        .HasColumnName("refund_reason");

                    b.Property<int>("Status")
                        .HasColumnType("int")
                        .HasColumnName("status");

                    b.ComplexProperty<Dictionary<string, object>>("Customer", "Order.Domain.Entities.OrderEntity.Customer#Customer", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Email")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_email");

                            b1.Property<Guid?>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("customer_id");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("customer_name");

                            b1.Property<string>("PhoneNumber")
                                .IsRequired()
                                .HasMaxLength(50)
                                .HasColumnType("nvarchar(50)")
                                .HasColumnName("customer_phone_number");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("Discount", "Order.Domain.Entities.OrderEntity.Discount#Discount", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("CouponCode")
                                .IsRequired()
                                .ValueGeneratedOnAdd()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasDefaultValue("")
                                .HasColumnName("coupon_code");

                            b1.Property<decimal>("DiscountAmount")
                                .ValueGeneratedOnAdd()
                                .HasColumnType("decimal(18,2)")
                                .HasDefaultValue(0m)
                                .HasColumnName("discount_amount");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("OrderNo", "Order.Domain.Entities.OrderEntity.OrderNo#OrderNo", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("Value")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("order_no");
                        });

                    b.ComplexProperty<Dictionary<string, object>>("ShippingAddress", "Order.Domain.Entities.OrderEntity.ShippingAddress#Address", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<string>("AddressLine")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("shipping_address_line");

                            b1.Property<string>("City")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_city");

                            b1.Property<string>("Country")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_country");

                            b1.Property<string>("PostalCode")
                                .IsRequired()
                                .HasMaxLength(20)
                                .HasColumnType("nvarchar(20)")
                                .HasColumnName("shipping_postal_code");

                            b1.Property<string>("StateOrProvince")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_state_or_province");

                            b1.Property<string>("Subdivision")
                                .IsRequired()
                                .HasMaxLength(100)
                                .HasColumnType("nvarchar(100)")
                                .HasColumnName("shipping_subdivision");
                        });

                    b.HasKey("Id");

                    b.ToTable("orders", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("created_by");

                    b.Property<DateTimeOffset>("CreatedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("created_on_utc");

                    b.Property<string>("LastModifiedBy")
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)")
                        .HasColumnName("last_modified_by");

                    b.Property<DateTimeOffset?>("LastModifiedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("last_modified_on_utc");

                    b.Property<decimal>("LineTotal")
                        .HasColumnType("decimal(18,2)");

                    b.Property<Guid>("OrderId")
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("order_id");

                    b.Property<int>("Quantity")
                        .HasColumnType("int")
                        .HasColumnName("quantity");

                    b.ComplexProperty<Dictionary<string, object>>("Product", "Order.Domain.Entities.OrderItemEntity.Product#Product", b1 =>
                        {
                            b1.IsRequired();

                            b1.Property<Guid>("Id")
                                .HasColumnType("uniqueidentifier")
                                .HasColumnName("product_id");

                            b1.Property<string>("ImageUrl")
                                .IsRequired()
                                .HasMaxLength(500)
                                .HasColumnType("nvarchar(500)")
                                .HasColumnName("product_image_url");

                            b1.Property<string>("Name")
                                .IsRequired()
                                .HasMaxLength(255)
                                .HasColumnType("nvarchar(255)")
                                .HasColumnName("product_name");

                            b1.Property<decimal>("Price")
                                .HasColumnType("decimal(18,2)")
                                .HasColumnName("product_price");
                        });

                    b.HasKey("Id");

                    b.HasIndex("OrderId");

                    b.ToTable("order_items", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OutboxMessageEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier")
                        .HasColumnName("id");

                    b.Property<int>("AttemptCount")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(0)
                        .HasColumnName("attempt_count");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("content");

                    b.Property<string>("EventType")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)")
                        .HasColumnName("event_type");

                    b.Property<string>("LastErrorMessage")
                        .HasColumnType("nvarchar(max)")
                        .HasColumnName("last_error_message");

                    b.Property<int>("MaxAttempts")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int")
                        .HasDefaultValue(3)
                        .HasColumnName("max_attempts");

                    b.Property<DateTimeOffset?>("NextAttemptOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("next_attempt_on_utc");

                    b.Property<DateTimeOffset>("OccurredOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("occurred_on_utc");

                    b.Property<DateTimeOffset?>("ProcessedOnUtc")
                        .HasColumnType("datetimeoffset")
                        .HasColumnName("processed_on_utc");

                    b.HasKey("Id");

                    b.HasIndex("EventType");

                    b.HasIndex("OccurredOnUtc");

                    b.HasIndex("ProcessedOnUtc");

                    b.HasIndex("NextAttemptOnUtc", "ProcessedOnUtc", "AttemptCount");

                    b.HasIndex("ProcessedOnUtc", "AttemptCount", "MaxAttempts");

                    b.ToTable("outbox_messages", (string)null);
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderItemEntity", b =>
                {
                    b.HasOne("Order.Domain.Entities.OrderEntity", null)
                        .WithMany("OrderItems")
                        .HasForeignKey("OrderId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Order.Domain.Entities.OrderEntity", b =>
                {
                    b.Navigation("OrderItems");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Data/ApplicationDbContext.cs">
#region using

using Microsoft.EntityFrameworkCore;
using System.Reflection;
using Order.Domain.Entities;

#endregion

namespace Order.Infrastructure.Data;

public sealed class ApplicationDbContext : DbContext
{
    #region Ctors

    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options) { }

    #endregion

    #region Implementations

    public DbSet<OrderEntity> Orders => Set<OrderEntity>();

    public DbSet<OrderItemEntity> OrderItems => Set<OrderItemEntity>();

    public DbSet<OutboxMessageEntity> OutboxMessages => Set<OutboxMessageEntity>();

    public DbSet<InboxMessageEntity> InboxMessages => Set<InboxMessageEntity>();


    #endregion

    #region Override Methods

    protected override void OnModelCreating(ModelBuilder builder)
    {
        builder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());
        base.OnModelCreating(builder);
    }

    #endregion

}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Exceptions/InfrastructureException.cs">
namespace Order.Infrastructure.Exceptions;

public sealed class InfrastructureException : Exception
{
    #region Ctors

    public InfrastructureException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/GrpcClients/Extensions/GrpcClientExtension.cs">
#region using

using Catalog.Grpc;
using Discount.Grpc;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Order.Infrastructure.GrpcClients.Interceptors;

#endregion

namespace Order.Infrastructure.GrpcClients.Extensions;

public static class GrpcClientExtension
{
    #region Methods

    public static IServiceCollection AddGrpcClients(this IServiceCollection services, IConfiguration cfg)
    {
        // Catalog Grpc
        var catalogServiceUrl = cfg.GetValue<string>($"{GrpcClientCfg.Catalog.Section}:{GrpcClientCfg.Catalog.Url}")
            ?? throw new InvalidOperationException("Catalog service URL is not configured.");

        services.AddGrpcClient<CatalogGrpc.CatalogGrpcClient>(options =>
        {
            options.Address = new Uri(catalogServiceUrl);
        })
        .AddInterceptor<GrpcApiKeyInterceptor>()
        .ConfigurePrimaryHttpMessageHandler(() =>
        {
            return new HttpClientHandler
            {
                ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
            };
        });

        // Discount Grpc
        var discountServiceUrl = cfg.GetValue<string>($"{GrpcClientCfg.Discount.Section}:{GrpcClientCfg.Discount.Url}")
            ?? throw new InvalidOperationException("Discount service URL is not configured.");

        services.AddGrpcClient<DiscountGrpc.DiscountGrpcClient>(options =>
        {
            options.Address = new Uri(discountServiceUrl);
        })
        .AddInterceptor<GrpcApiKeyInterceptor>()
        .ConfigurePrimaryHttpMessageHandler(() =>
        {
            return new HttpClientHandler
            {
                ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
            };
        });

        services.AddSingleton<GrpcApiKeyInterceptor>();

        return services;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/GrpcClients/Interceptors/GrpcApiKeyInterceptor.cs">
#region using

using Grpc.Core;
using Grpc.Core.Interceptors;
using Microsoft.Extensions.Configuration;

#endregion

namespace Order.Infrastructure.GrpcClients.Interceptors;

public sealed class GrpcApiKeyInterceptor(IConfiguration cfg) : Interceptor
{
    #region Methods

    public override AsyncUnaryCall<TResponse> AsyncUnaryCall<TRequest, TResponse>(
        TRequest request,
        ClientInterceptorContext<TRequest, TResponse> context,
        AsyncUnaryCallContinuation<TRequest, TResponse> continuation)
    {
        var grpcKey = cfg.GetValue<string>($"{GrpcClientCfg.Catalog.Section}:{GrpcClientCfg.Catalog.ApiKey}")
            ?? throw new InvalidOperationException("gRPC Key is not configured.");
        var headers = context.Options.Headers ?? [];
        if (!headers.Any(h => h.Key.Equals(ReqHeaderName.GrpcKey, StringComparison.OrdinalIgnoreCase)))
        {
            headers.Add(ReqHeaderName.GrpcKey, grpcKey);
        }

        var newOptions = context.Options.WithHeaders(headers);
        var newContext = new ClientInterceptorContext<TRequest, TResponse>(
            context.Method,
            context.Host,
            newOptions);

        return base.AsyncUnaryCall(request, newContext, continuation);
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Repositories/InboxMessageRepository.cs">
#region using

using Microsoft.EntityFrameworkCore;
using Order.Domain.Entities;
using Order.Domain.Repositories;
using Order.Infrastructure.Data;

#endregion

namespace Order.Infrastructure.Repositories;

public class InboxMessageRepository(ApplicationDbContext context) : Repository<InboxMessageEntity>(context), IInboxMessageRepository
{
    #region Implementations

    public async Task<InboxMessageEntity?> GetByMessageIdAsync(Guid messageId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .FirstOrDefaultAsync(x => x.Id == messageId, cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Repositories/OrderItemRepository.cs">
#region using

using Order.Domain.Entities;
using Order.Domain.Repositories;
using Order.Infrastructure.Data;

#endregion

namespace Order.Infrastructure.Repositories;

public class OrderItemRepository(ApplicationDbContext context) : Repository<OrderItemEntity>(context), IOrderItemRepository
{
    #region Implementations

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Repositories/OrderRepository.cs">
#region using

using BuildingBlocks.Pagination.Extensions;
using Common.Models;
using Microsoft.EntityFrameworkCore;
using Order.Domain.Entities;
using Order.Domain.Repositories;
using Order.Infrastructure.Data;
using System.Linq.Expressions;

#endregion

namespace Order.Infrastructure.Repositories;

public class OrderRepository(ApplicationDbContext context) : Repository<OrderEntity>(context), IOrderRepository
{
    #region Implementations

    public async Task<OrderEntity?> GetByIdWithRelationshipAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(x => x.OrderItems)
            .Include(x => x.Customer)
            .FirstOrDefaultAsync(x => x.Id == id, cancellationToken);
    }

    public async Task<List<OrderEntity>> GetByCustomerWithRelationshipAsync(Guid customerId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(x => x.OrderItems)
            .Where(x => x.Customer.Id == customerId)
            .OrderByDescending(x => x.CreatedOnUtc)
            .ToListAsync(cancellationToken);
    }

    public async Task<OrderEntity?> GetByOrderNoAsync(string orderNo, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(x => x.OrderItems)
            .FirstOrDefaultAsync(x => x.OrderNo.Value == orderNo, cancellationToken);
    }

    public async Task<List<OrderEntity>> SearchWithRelationshipAsync(
        Expression<Func<OrderEntity, bool>> predicate,
        PaginationRequest pagination,
        CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(x => x.OrderItems)
            .Where(predicate)
            .OrderByDescending(x => x.CreatedOnUtc)
            .WithPaging(pagination)
            .ToListAsync(cancellationToken);
    }

    public async Task<List<OrderEntity>> SearchWithRelationshipAsync(Expression<Func<OrderEntity, bool>> predicate,
        CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(x => x.OrderItems)
            .Where(predicate)
            .OrderByDescending(x => x.CreatedOnUtc)
            .ToListAsync(cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Repositories/OutboxMessageRepository.cs">
#region using

using Order.Domain.Entities;
using Order.Domain.Repositories;
using Order.Infrastructure.Data;

#endregion

namespace Order.Infrastructure.Repositories;

public class OutboxMessageRepository(ApplicationDbContext context) : Repository<OutboxMessageEntity>(context), IOutboxMessageRepository
{
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Repositories/Repository.cs">
#region using

using Microsoft.EntityFrameworkCore;
using Order.Domain.Repositories;
using Order.Infrastructure.Data;
using System.Linq.Expressions;

#endregion

namespace Order.Infrastructure.Repositories;

public class Repository<T>(ApplicationDbContext context) : IRepository<T> where T : class
{
    #region Fields

    protected readonly ApplicationDbContext _context = context;

    protected readonly DbSet<T> _dbSet = context.Set<T>();

    #endregion

    #region Implementations

    public virtual async Task<T?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _dbSet.FindAsync([id], cancellationToken);
    }

    public virtual async Task<T?> FirstOrDefaultAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .FirstOrDefaultAsync(predicate, cancellationToken);
    }

    public virtual async Task<T?> SingleOrDefaultAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .SingleOrDefaultAsync(predicate, cancellationToken);
    }

    public virtual async Task<IReadOnlyList<T>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .ToListAsync(cancellationToken);
    }

    public virtual async Task<IReadOnlyList<T>> FindAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(predicate)
            .ToListAsync(cancellationToken);
    }

    public virtual async Task<long> CountAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .CountAsync(cancellationToken);
    }

    public virtual async Task<long> CountAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(predicate)
            .CountAsync(cancellationToken);
    }

    public virtual async Task<bool> AnyAsync(Expression<Func<T, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .AnyAsync(predicate, cancellationToken);
    }

    public virtual async Task AddAsync(T entity, CancellationToken cancellationToken = default)
    {
        await _dbSet.AddAsync(entity, cancellationToken);
    }

    public virtual async Task AddRangeAsync(IEnumerable<T> entities, CancellationToken cancellationToken = default)
    {
        await _dbSet.AddRangeAsync(entities, cancellationToken);
    }

    public virtual void Update(T entity)
    {
        _dbSet.Update(entity);
    }

    public virtual void UpdateRange(IEnumerable<T> entities)
    {
        _dbSet.UpdateRange(entities);
    }

    public virtual void Remove(T entity)
    {
        _dbSet.Remove(entity);
    }

    public virtual void RemoveRange(IEnumerable<T> entities)
    {
        _dbSet.RemoveRange(entities);
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Services/CatalogGrpcService.cs">
#region using

using Catalog.Grpc;
using Microsoft.Extensions.Logging;
using Order.Application.Models.Responses.Externals;
using Order.Application.Services;

#endregion

namespace Order.Infrastructure.Services;

public sealed class CatalogGrpcService(CatalogGrpc.CatalogGrpcClient grpcClient, ILogger<CatalogGrpcService> logger) : ICatalogGrpcService
{
    #region Methods

    public async Task<ProductReponse?> GetProductByIdAsync(string productId, CancellationToken cancellationToken = default)
    {
        try
        {
            var result = await grpcClient.GetProductByIdAsync(
                new GetProductByIdRequest { Id = productId },
                cancellationToken: cancellationToken);

            var product = result.Product;

            return new ProductReponse()
            {
                Id = Guid.Parse(product.Id),
                Price = (decimal)product.Price,
                Name = product.Name
            };
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex, "Failed to get product by ID {ProductId} from Catalog Grpc service", productId);
            return null;
        }
    }

    public async Task<GetAllProductsResponse?> GetProductsAsync(string[]? ids = null, string searchText = "", CancellationToken cancellationToken = default)
    {
        try
        {
            var request = new GetProductsRequest { SearchText = searchText };
            if (ids is not null && ids.Length > 0)
                request.Ids.AddRange(ids);

            var result = await grpcClient.GetProductsAsync(request, cancellationToken: cancellationToken);

            var response = new GetAllProductsResponse
            {
                Items = result.Products
                    .Select(p => new ProductReponse
                    {
                        Id = Guid.Parse(p.Id),
                        Name = p.Name,
                        Price = (decimal)p.Price,
                        Thumbnail = p.Thumbnail
                    })
                    .ToList()
            };

            return response;
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex, "Failed to get products from Catalog Grpc service");
            return null;
        }
    }

    public async Task<GetAllProductsResponse?> GetAllAvailableProductsAsync(string[]? ids = null, string searchText = "", CancellationToken cancellationToken = default)
    {
        try
        {
            var request = new GetAllAvailableProductsRequest { SearchText = searchText };

            if (ids is not null && ids.Length > 0)
                request.Ids.AddRange(ids);

            var result = await grpcClient.GetAllAvailableProductsAsync(request, cancellationToken: cancellationToken);

            var response = new GetAllProductsResponse
            {
                Items = result.Products
                    .Select(p => new ProductReponse
                    {
                        Id = Guid.Parse(p.Id),
                        Name = p.Name,
                        Price = (decimal)p.Price,
                        Thumbnail = p.Thumbnail
                    })
                    .ToList()
            };

            return response;
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex, "Failed to get all available products from Catalog Grpc service");
            return null;
        }
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/Services/DiscountGrpcService.cs">
#region using

using Discount.Grpc;
using Microsoft.Extensions.Logging;
using Order.Application.Services;

#endregion

namespace Order.Infrastructure.Services;

public sealed class DiscountGrpcService(DiscountGrpc.DiscountGrpcClient grpcClient, ILogger<DiscountGrpcService> logger) : IDiscountGrpcService
{
    public async Task<Application.Models.Responses.Internals.ApplyCouponResponse?> ApplyCouponAsync(string code, decimal amount, CancellationToken cancellationToken = default)
    {
        try
        {
            var request = new ApplyCouponRequest { Amount = (double)amount, Code = code };

            var result = await grpcClient.ApplyCouponAsync(
                request,
                cancellationToken: cancellationToken);

            return new Application.Models.Responses.Internals.ApplyCouponResponse()
            {
                CouponCode = result.CouponCode
            };
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex, "Failed to apply coupon {CouponCode} from Discount Grpc service", code);
            return null;
        }
    }

    public async Task<Application.Models.Responses.Internals.EvaluateCouponResponse?> EvaluateCouponAsync(string code, decimal amount, CancellationToken cancellationToken = default)
    {
        try
        {
            var request = new EvaluateCouponRequest { Amount = (double)amount, Code = code };

            var result = await grpcClient.EvaluateCouponAsync(
                request,
                cancellationToken: cancellationToken);

            return new Application.Models.Responses.Internals.EvaluateCouponResponse()
            {
                CouponCode = result.CouponCode,
                DiscountAmount = (decimal)result.DiscountAmount,
                FinalAmount = (decimal)result.FinalAmount,
                OriginalAmount = (decimal)result.OriginalAmount,
            };
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex, "Failed to evaluate coupon {CouponCode} from Discount Grpc service", code);
            return null;
        }
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/UnitOfWork/DbTransactionAdapter.cs">
#region using

using Microsoft.EntityFrameworkCore.Storage;
using Order.Domain.Abstractions;

#endregion

namespace Order.Infrastructure.UnitOfWork;

internal class DbTransactionAdapter(IDbContextTransaction transaction) : IDbTransaction
{
    #region Implementations

    public async Task CommitAsync(CancellationToken cancellationToken = default)
    {
        await transaction.CommitAsync(cancellationToken);
    }

    public async Task RollbackAsync(CancellationToken cancellationToken = default)
    {
        await transaction.RollbackAsync(cancellationToken);
    }

    public void Dispose()
    {
        transaction.Dispose();
    }

    public async ValueTask DisposeAsync()
    {
        await transaction.DisposeAsync();
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/UnitOfWork/UnitOfWork.cs">
#region using

using Order.Domain.Abstractions;
using Order.Domain.Repositories;
using Order.Infrastructure.Data;

#endregion

namespace Order.Infrastructure.UnitOfWork;

public class UnitOfWork(
    IOrderRepository orders,
    IOrderItemRepository orderItems,
    IInboxMessageRepository inbox,
    IOutboxMessageRepository outbox,
    ApplicationDbContext context) : IUnitOfWork
{
    public IOrderRepository Orders { get; } = orders;
    public IOrderItemRepository OrderItems { get; } = orderItems;
    public IInboxMessageRepository InboxMessages { get; } = inbox;
    public IOutboxMessageRepository OutboxMessages { get; } = outbox;

    public Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
        => context.SaveChangesAsync(cancellationToken);

    public async Task<IDbTransaction> BeginTransactionAsync(CancellationToken cancellationToken = default)
    {
        var tx = await context.Database.BeginTransactionAsync(cancellationToken);
        return new DbTransactionAdapter(tx);
    }
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/DependencyInjection.cs">
#region using

using Microsoft.AspNetCore.Builder;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Order.Infrastructure.Data;
using Order.Infrastructure.Data.Extensions;
using Order.Infrastructure.Data.Interceptors;
using Order.Infrastructure.GrpcClients.Extensions;

#endregion

namespace Order.Infrastructure;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddInfrastructureServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Service")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithScopedLifetime());

        // DbContext
        {
            var dbType = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DbType}"];
            services.AddScoped<ISaveChangesInterceptor, AuditableEntityInterceptor>();
            services.AddScoped<ISaveChangesInterceptor, DispatchDomainEventsInterceptor>();
            services.AddDbContext<ApplicationDbContext>((sp, options) =>
            {
                var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];
                options.AddInterceptors(sp.GetServices<ISaveChangesInterceptor>());

                switch (dbType)
                {
                    case DatabaseType.SqlServer:
                        options.UseSqlServer(conn);
                        break;
                    case DatabaseType.MySql:
                        options.UseMySQL(conn!);
                        break;
                    case DatabaseType.PostgreSql:
                        options.UseNpgsql(conn);
                        break;
                    default:
                        throw new Exception("Unsupported database type");
                }
            });
        }

        // Repository & Unit of Work
        {
            services.Scan(s => s
                .FromAssemblyOf<InfrastructureMarker>()
                .AddClasses(c => c.Where(t => t.Name.EndsWith("Repository")))
                .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
                .AsImplementedInterfaces()
                .WithScopedLifetime());

            services.AddScoped<Domain.Abstractions.IUnitOfWork, UnitOfWork.UnitOfWork>();
        }

        services.AddGrpcClients(cfg);

        return services;
    }

    public static WebApplication UseInfrastructure(this WebApplication app)
    {
        app.InitialiseDatabaseAsync().Wait();

        return app;
    }

    #endregion
}
</file>

<file path="Services/Order/Core/Order.Infrastructure/GlobalUsing.cs">
global using Common.Configurations;
global using Common.Constants;
</file>

<file path="Services/Order/Core/Order.Infrastructure/InfrastructureMarker.cs">
namespace Order.Infrastructure;

public sealed class InfrastructureMarker { }
</file>

<file path="Services/Order/Core/Order.Infrastructure/Order.Infrastructure.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <Protobuf Include="..\..\..\..\Shared\Contracts\Catalog.Contract\Protos\catalog.proto" GrpcServices="Client" />
    <Protobuf Include="..\..\..\..\Shared\Contracts\Discount.Contract\Protos\discount.proto" GrpcServices="Client" />
  </ItemGroup>
  
  <ItemGroup>
    <PackageReference Include="Aspire.Npgsql.EntityFrameworkCore.PostgreSQL" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="MySql.EntityFrameworkCore" />
    <PackageReference Include="Polly" />
    <PackageReference Include="Polly.Extensions.Http" />
    <PackageReference Include="Refit.HttpClientFactory" />
    <PackageReference Include="Scrutor" />
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="Google.Protobuf" />
    <PackageReference Include="Grpc.Net.Client" />
    <PackageReference Include="Grpc.Tools">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Order.Application\Order.Application.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Data\Migrations\" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Order/Worker/Order.Woker.Outbox/Abstractions/IDatabaseProvider.cs">
#region using

using Order.Worker.Outbox.Models;
using Order.Worker.Outbox.Structs;

#endregion

namespace Order.Worker.Outbox.Abstractions;

public interface IDatabaseProvider
{
    #region Methods

    Task<List<OutboxMessage>> GetUnprocessedMessagesAsync(string connectionString, int batchSize, CancellationToken cancellationToken = default);

    Task UpdateProcessedMessagesAsync(string connectionString, IEnumerable<OutboxUpdate> updates, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Order/Worker/Order.Woker.Outbox/BackgroundServices/OutboxBackgroundService.cs">
#region using

using Common.Configurations;
using Order.Worker.Outbox.Processors;

#endregion

namespace Order.Worker.Outbox.BackgroundServices;

internal class OutboxBackgroundService : BackgroundService
{
    #region Fields, Properties and Indexers

    private readonly int _processorFrequency;

    private readonly int _maxParallelism;

    private int _totalIterations = 0;

    private int _totalProcessedMessage = 0;

    private readonly IServiceScopeFactory _serviceScopeFactory;

    private readonly ILogger<OutboxBackgroundService> _logger;

    #endregion

    #region Ctors

    public OutboxBackgroundService(
        IServiceScopeFactory serviceScopeFactory,
        IConfiguration cfg,
        ILogger<OutboxBackgroundService> logger)
    {
        _processorFrequency = cfg.GetValue<int>($"{WorkerCfg.Outbox.Section}:{WorkerCfg.Outbox.ProcessorFrequency}", 5);
        _maxParallelism = cfg.GetValue<int>($"{WorkerCfg.Outbox.Section}:{WorkerCfg.Outbox.MaxParallelism}", 5);
        _serviceScopeFactory = serviceScopeFactory;
        _logger = logger;
    }

    #endregion

    #region Methods

    protected override async Task ExecuteAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Outbox processor started");

        var parallelOptions = new ParallelOptions
        {
            MaxDegreeOfParallelism = _maxParallelism,
            CancellationToken = cancellationToken
        };

        try
        {
            await Parallel.ForEachAsync(
                Enumerable.Range(0, _maxParallelism),
                parallelOptions,
                async (_, token) =>
                {
                    await ProcessOutboxMessages(token);
                });
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Outbox processor operation cancelled");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred while processing outbox messages");
        }
    }

    private async Task ProcessOutboxMessages(CancellationToken cancellationToken)
    {
        using var scope = _serviceScopeFactory.CreateScope();
        var outboxProcessor = scope.ServiceProvider.GetRequiredService<OutboxProcessor>();

        while (true)
        {
            int processedMessages = await outboxProcessor.ExecuteAsync(cancellationToken);
            var totalProcessedMessages = Interlocked.Add(ref _totalProcessedMessage, processedMessages);

            // Only log if there were messages processed or every 100 iterations
            var iterationCount = Interlocked.Increment(ref _totalIterations);
            if (processedMessages > 0 || iterationCount % 100 == 0)
            {
                _logger.LogInformation("Iteration {IterationCount}: Processed {ProcessedMessages} messages. Total: {TotalProcessedMessages}",
                    iterationCount, processedMessages, totalProcessedMessages);
            }

            await Task.Delay(TimeSpan.FromSeconds(_processorFrequency), cancellationToken);
        }
    }

    #endregion
}
</file>

<file path="Services/Order/Worker/Order.Woker.Outbox/Factories/DatabaseProviderFactory.cs">
#region using

using Common.Constants;
using Order.Worker.Outbox.Abstractions;
using Order.Worker.Outbox.Providers;

#endregion

namespace Order.Worker.Outbox.Factories;

public static class DatabaseProviderFactory
{
    #region Methods

    public static IDatabaseProvider CreateProvider(string dbType)
    {
        return dbType.ToUpperInvariant() switch
        {
            DatabaseType.MySql => new MySqlDatabaseProvider(),
            DatabaseType.PostgreSql => new PostgreSqlDatabaseProvider(),
            DatabaseType.SqlServer => new SqlServerDatabaseProvider(),
            _ => throw new NotSupportedException($"Unsupported database type: {dbType}. Supported types: {DatabaseType.MySql}, {DatabaseType.PostgreSql}, {DatabaseType.SqlServer}")
        };
    }

    #endregion
}
</file>

<file path="Services/Order/Worker/Order.Woker.Outbox/Models/OutboxMessage.cs">
namespace Order.Worker.Outbox.Models;

public sealed record OutboxMessage
{
    #region Fields, Properties and Indexers

    public Guid Id { get; init; }

    public string Type { get; init; } = default!;

    public string Content { get; init; } = default!;

    public int AttemptCount { get; init; }

    public int MaxAttempts { get; init; }

    public DateTimeOffset? NextAttemptOnUtc { get; init; }

    public string? LastErrorMessage { get; init; }

    #endregion
}
</file>

<file path="Services/Order/Worker/Order.Woker.Outbox/Processors/OutboxProcessor.cs">
#region using

using Common.Configurations;
using Order.Worker.Outbox.Abstractions;
using Order.Worker.Outbox.Factories;
using Order.Worker.Outbox.Structs;
using MassTransit;
using System.Collections.Concurrent;
using System.Text.Json;

#endregion

namespace Order.Worker.Outbox.Processors;

internal sealed class OutboxProcessor
{
    #region Fields, Properties and Indexers

    private readonly int _batchSize;

    private readonly string _connectionString;

    private readonly IDatabaseProvider _databaseProvider;

    private static readonly ConcurrentDictionary<string, Type> TypeCache = new();

    private readonly IPublishEndpoint _publish;

    private readonly ILogger<OutboxProcessor> _logger;

    #endregion

    #region Ctors

    public OutboxProcessor(
        IConfiguration cfg,
        IPublishEndpoint publish,
        ILogger<OutboxProcessor> logger)
    {
        _connectionString = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"]!;
        _batchSize = cfg.GetValue<int>($"{WorkerCfg.Outbox.Section}:{WorkerCfg.Outbox.BatchSize}", 1000);
        _databaseProvider = DatabaseProviderFactory.CreateProvider(cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DbType}"]!);
        _publish = publish;
        _logger = logger;
    }

    #endregion

    #region Methods

    public async Task<int> ExecuteAsync(CancellationToken cancellationToken = default)
    {
        var messages = await _databaseProvider.GetUnprocessedMessagesAsync(_connectionString, _batchSize, cancellationToken);

        if (messages.Count == 0)
            return 0;

        var updateQueue = new ConcurrentQueue<OutboxUpdate>();

        var publishTasks = messages
            .Select(message => PublishMessageAsync(message, updateQueue, cancellationToken))
            .ToList();

        await Task.WhenAll(publishTasks);

        if (!updateQueue.IsEmpty)
        {
            await _databaseProvider.UpdateProcessedMessagesAsync(_connectionString, updateQueue, cancellationToken);
        }

        return messages.Count;
    }

    private async Task PublishMessageAsync(
        Models.OutboxMessage message,
        ConcurrentQueue<OutboxUpdate> updateQueue,
        CancellationToken cancellationToken)
    {
        try
        {
            var messageType = GetOrAddMessageType(message.Type);
            var deserializedMessage = JsonSerializer.Deserialize(message.Content, messageType)!;

            await _publish.Publish(deserializedMessage, cancellationToken);

            updateQueue.Enqueue(new OutboxUpdate(
                message.Id,
                DateTimeOffset.UtcNow,
                null,
                message.AttemptCount + 1,
                null));
        }
        catch (Exception ex)
        {
            var currentTime = DateTimeOffset.UtcNow;
            var attemptCount = message.AttemptCount + 1;

            if (attemptCount >= message.MaxAttempts)
            {
                updateQueue.Enqueue(new OutboxUpdate(
                    message.Id,
                    currentTime,
                    $"Max attempts ({message.MaxAttempts}) exceeded. Last error: {ex}",
                    attemptCount,
                    null));

                _logger.LogError(ex, "Permanently failed to publish outbox message {Id} after {AttemptCount} attempts",
                    message.Id, attemptCount);
            }
            else
            {
                var baseDelay = TimeSpan.FromSeconds(Math.Pow(2, attemptCount - 1));
                var maxDelay = TimeSpan.FromMinutes(5);
                var jitter = TimeSpan.FromMilliseconds(Random.Shared.Next(0, 1000));
                var delay = TimeSpan.FromTicks(Math.Min(baseDelay.Ticks, maxDelay.Ticks)) + jitter;
                var nextAttemptOnUtc = currentTime + delay;

                updateQueue.Enqueue(new OutboxUpdate(
                    message.Id,
                    currentTime,
                    ex.ToString(),
                    attemptCount,
                    nextAttemptOnUtc));

                _logger.LogWarning(ex, "Failed to publish outbox message {Id} (attempt {AttemptCount}/{MaxAttempts}), will retry at {NextAttemptOnUtc}",
                    message.Id, attemptCount, message.MaxAttempts, nextAttemptOnUtc);
            }
        }
    }

    private static Type GetOrAddMessageType(string typename)
    {
        return TypeCache.GetOrAdd(typename, name => Type.GetType(name)!);
    }

    #endregion
}
</file>

<file path="Services/Order/Worker/Order.Woker.Outbox/Providers/MySqlDatabaseProvider.cs">
#region using

using Dapper;
using Order.Worker.Outbox.Abstractions;
using Order.Worker.Outbox.Models;
using Order.Worker.Outbox.Structs;
using MySql.Data.MySqlClient;

#endregion

namespace Order.Worker.Outbox.Providers;

public sealed class MySqlDatabaseProvider : IDatabaseProvider
{
    #region Implementations

    public async Task<List<OutboxMessage>> GetUnprocessedMessagesAsync(
        string connectionString,
        int batchSize,
        CancellationToken cancellationToken = default)
    {
        await using var connection = new MySqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var transaction = await connection.BeginTransactionAsync(cancellationToken);

        var messages = await connection.QueryAsync<OutboxMessage>(
            """
            SELECT 
                id AS Id,
                event_type AS Type,
                content AS Content,
                attempt_count AS AttemptCount,
                max_attempts AS MaxAttempts,
                next_attempt_on_utc AS NextAttemptOnUtc,
                last_error_message AS LastErrorMessage
            FROM outbox_messages 
            WHERE processed_on_utc IS NULL 
              AND attempt_count < max_attempts
              AND (next_attempt_on_utc IS NULL OR next_attempt_on_utc <= @CurrentTime)
            ORDER BY occurred_on_utc
            LIMIT @BatchSize
            FOR UPDATE SKIP LOCKED
            """,
            new { BatchSize = batchSize, CurrentTime = DateTimeOffset.UtcNow },
            transaction: transaction);

        await transaction.CommitAsync(cancellationToken);

        return messages.AsList();
    }

    public async Task UpdateProcessedMessagesAsync(
        string connectionString,
        IEnumerable<OutboxUpdate> updates,
        CancellationToken cancellationToken = default)
    {
        var updatesList = updates.ToList();
        if (!updatesList.Any())
            return;

        await using var connection = new MySqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var transaction = await connection.BeginTransactionAsync(cancellationToken);

        var updateSql =
            """
            UPDATE outbox_messages
            SET processed_on_utc = CASE 
                {0}
            END,
            last_error_message = CASE 
                {1}
            END,
            attempt_count = CASE 
                {2}
            END,
            next_attempt_on_utc = CASE 
                {3}
            END
            WHERE id IN ({4})
            """;

        var whenThenProcessed = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @ProcessedOn{i}"));
        var whenThenError = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @Error{i}"));
        var whenThenAttemptCount = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @AttemptCount{i}"));
        var whenThenNextAttempt = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @NextAttempt{i}"));
        var ids = string.Join(",", updatesList.Select((_, i) => $"@Id{i}"));

        var parameters = new DynamicParameters();

        for (int i = 0; i < updatesList.Count; i++)
        {
            parameters.Add($"Id{i}", updatesList[i].Id);
            parameters.Add($"ProcessedOn{i}", updatesList[i].ProcessedOnUtc);
            parameters.Add($"Error{i}", updatesList[i].LastErrorMessage);
            parameters.Add($"AttemptCount{i}", updatesList[i].AttemptCount);
            parameters.Add($"NextAttempt{i}", updatesList[i].NextAttemptOnUtc);
        }

        var formattedSql = string.Format(updateSql, whenThenProcessed, whenThenError, whenThenAttemptCount, whenThenNextAttempt, ids);

        await connection.ExecuteAsync(formattedSql, parameters, transaction: transaction);
        await transaction.CommitAsync(cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Order/Worker/Order.Woker.Outbox/Providers/PostgreSqlDatabaseProvider.cs">
#region using

using Dapper;
using Order.Worker.Outbox.Abstractions;
using Order.Worker.Outbox.Models;
using Order.Worker.Outbox.Structs;
using Npgsql;

#endregion

namespace Order.Worker.Outbox.Providers;

public sealed class PostgreSqlDatabaseProvider : IDatabaseProvider
{
    #region Implementations

    public async Task<List<OutboxMessage>> GetUnprocessedMessagesAsync(
        string connectionString,
        int batchSize,
        CancellationToken cancellationToken = default)
    {
        await using var connection = new NpgsqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var transaction = await connection.BeginTransactionAsync(cancellationToken);

        var messages = await connection.QueryAsync<OutboxMessage>(
            """
            SELECT 
                id AS Id,
                event_type AS Type,
                content AS Content,
                attempt_count AS AttemptCount,
                max_attempts AS MaxAttempts,
                next_attempt_on_utc AS NextAttemptOnUtc,
                last_error_message AS LastErrorMessage
            FROM outbox_messages 
            WHERE processed_on_utc IS NULL 
              AND attempt_count < max_attempts
              AND (next_attempt_on_utc IS NULL OR next_attempt_on_utc <= @CurrentTime)
            ORDER BY occurred_on_utc
            LIMIT @BatchSize
            FOR UPDATE SKIP LOCKED
            """,
            new { BatchSize = batchSize, CurrentTime = DateTimeOffset.UtcNow },
            transaction: transaction);

        await transaction.CommitAsync(cancellationToken);

        return messages.AsList();
    }

    public async Task UpdateProcessedMessagesAsync(
        string connectionString,
        IEnumerable<OutboxUpdate> updates,
        CancellationToken cancellationToken = default)
    {
        var updatesList = updates.ToList();
        if (!updatesList.Any())
            return;

        await using var connection = new NpgsqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var transaction = await connection.BeginTransactionAsync(cancellationToken);

        var updateSql =
            """
            UPDATE outbox_messages
            SET processed_on_utc = v.processed_on_utc,
                last_error_message = v.error,
                attempt_count = v.attempt_count,
                next_attempt_on_utc = v.next_attempt_on_utc
            FROM (VALUES
                {0}
            ) AS v(id, processed_on_utc, error, attempt_count, next_attempt_on_utc)
            WHERE outbox_messages.id = v.id::uuid
            """;

        var valuesList = string.Join(",",
            updatesList.Select((_, i) => $"(@Id{i}, @ProcessedOn{i}, @Error{i}, @AttemptCount{i}, @NextAttempt{i})"));

        var parameters = new DynamicParameters();

        for (int i = 0; i < updatesList.Count; i++)
        {
            parameters.Add($"Id{i}", updatesList[i].Id.ToString());
            parameters.Add($"ProcessedOn{i}", updatesList[i].ProcessedOnUtc);
            parameters.Add($"Error{i}", updatesList[i].LastErrorMessage);
            parameters.Add($"AttemptCount{i}", updatesList[i].AttemptCount);
            parameters.Add($"NextAttempt{i}", updatesList[i].NextAttemptOnUtc);
        }

        var formattedSql = string.Format(updateSql, valuesList);

        await connection.ExecuteAsync(formattedSql, parameters, transaction: transaction);
        await transaction.CommitAsync(cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Order/Worker/Order.Woker.Outbox/Providers/SqlServerDatabaseProvider.cs">
#region using

using Dapper;
using Order.Worker.Outbox.Abstractions;
using Order.Worker.Outbox.Models;
using Order.Worker.Outbox.Structs;
using Microsoft.Data.SqlClient;

#endregion

namespace Order.Worker.Outbox.Providers;

public sealed class SqlServerDatabaseProvider : IDatabaseProvider
{
    #region Implementations

    public async Task<List<OutboxMessage>> GetUnprocessedMessagesAsync(
        string connectionString,
        int batchSize,
        CancellationToken cancellationToken = default)
    {
        await using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var transaction = await connection.BeginTransactionAsync(cancellationToken);

        var messages = await connection.QueryAsync<OutboxMessage>(
            """
            SELECT TOP(@BatchSize)
                id AS Id,
                event_type AS Type,
                content AS Content,
                attempt_count AS AttemptCount,
                max_attempts AS MaxAttempts,
                next_attempt_on_utc AS NextAttemptOnUtc,
                last_error_message AS LastErrorMessage
            FROM outbox_messages WITH (READPAST, ROWLOCK)
            WHERE processed_on_utc IS NULL 
              AND attempt_count < max_attempts
              AND (next_attempt_on_utc IS NULL OR next_attempt_on_utc <= @CurrentTime)
            ORDER BY occurred_on_utc
            """,
            new { BatchSize = batchSize, CurrentTime = DateTimeOffset.UtcNow },
            transaction: transaction);

        await transaction.CommitAsync(cancellationToken);

        return messages.AsList();
    }

    public async Task UpdateProcessedMessagesAsync(
        string connectionString,
        IEnumerable<OutboxUpdate> updates,
        CancellationToken cancellationToken = default)
    {
        var updatesList = updates.ToList();
        if (!updatesList.Any())
            return;

        await using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var transaction = await connection.BeginTransactionAsync(cancellationToken);

        var updateSql =
            """
            UPDATE outbox_messages
            SET processed_on_utc = CASE 
                {0}
            END,
            last_error_message = CASE 
                {1}
            END,
            attempt_count = CASE 
                {2}
            END,
            next_attempt_on_utc = CASE 
                {3}
            END
            WHERE id IN ({4})
            """;

        var whenThenProcessed = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @ProcessedOn{i}"));
        var whenThenError = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @Error{i}"));
        var whenThenAttemptCount = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @AttemptCount{i}"));
        var whenThenNextAttempt = string.Join(" ", updatesList.Select((_, i) => $"WHEN id = @Id{i} THEN @NextAttempt{i}"));
        var ids = string.Join(",", updatesList.Select((_, i) => $"@Id{i}"));

        var parameters = new DynamicParameters();

        for (int i = 0; i < updatesList.Count; i++)
        {
            parameters.Add($"Id{i}", updatesList[i].Id);
            parameters.Add($"ProcessedOn{i}", updatesList[i].ProcessedOnUtc);
            parameters.Add($"Error{i}", updatesList[i].LastErrorMessage);
            parameters.Add($"AttemptCount{i}", updatesList[i].AttemptCount);
            parameters.Add($"NextAttempt{i}", updatesList[i].NextAttemptOnUtc);
        }

        var formattedSql = string.Format(updateSql, whenThenProcessed, whenThenError, whenThenAttemptCount, whenThenNextAttempt, ids);

        await connection.ExecuteAsync(formattedSql, parameters, transaction: transaction);
        await transaction.CommitAsync(cancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Order/Worker/Order.Woker.Outbox/Structs/OutboxUpdate.cs">
namespace Order.Worker.Outbox.Structs;

public record struct OutboxUpdate(
    Guid Id,
    DateTimeOffset ProcessedOnUtc,
    string? LastErrorMessage,
    int AttemptCount,
    DateTimeOffset? NextAttemptOnUtc);
</file>

<file path="Services/Order/Worker/Order.Woker.Outbox/DependencyInjection.cs">
#region using

using BuildingBlocks.Logging;
using EventSourcing.MassTransit;
using Order.Worker.Outbox.Processors;
using System.Reflection;

#endregion

namespace Order.Worker.Outbox;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddWorkerServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddSerilogLogging(cfg);
        services.AddMessageBroker(cfg, Assembly.GetExecutingAssembly());
        services.AddScoped<OutboxProcessor>();

        return services;
    }

    #endregion
}
</file>

<file path="Services/Order/Worker/Order.Woker.Outbox/Order.Worker.Outbox.csproj">
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <PropertyGroup>
    <UserSecretsId>dotnet-Worker-7f7483a9-e5da-45da-b9d6-631ff820055e</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Dapper" />
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="MySql.Data" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Order.Domain\Order.Domain.csproj" />
    <ProjectReference Include="..\..\Core\Order.Infrastructure\Order.Infrastructure.csproj" />
  </ItemGroup>
</Project>
</file>

<file path="Services/Order/Worker/Order.Woker.Outbox/Program.cs">
#region using

using Order.Application;
using Order.Infrastructure;
using Order.Worker.Outbox;
using Order.Worker.Outbox.BackgroundServices;

#endregion

var builder = Host.CreateApplicationBuilder(args);

builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddWorkerServices(builder.Configuration)
    .AddHostedService<OutboxBackgroundService>();

var host = builder.Build();

host.Run();
</file>

<file path="Services/Order/Worker/Order.Worker.Consumer/BackgroundServices/OrderBackgroudService.cs">
namespace Order.Worker.Consumer.BackgroundServices;

public sealed class OrderBackgroudService(ILogger<OrderBackgroudService> logger) : BackgroundService
{
    #region Methods

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        logger.LogInformation("Worker starting at: {time}", DateTimeOffset.Now);

        while (!stoppingToken.IsCancellationRequested)
        {
            await Task.Delay(1000, stoppingToken);
        }

        logger.LogInformation("Worker stoping at: {time}", DateTimeOffset.Now);
    }

    #endregion
}
</file>

<file path="Services/Order/Worker/Order.Worker.Consumer/EventHandlers/Integrations/BasketCheckoutIntegrationEventHandler.cs">
#region using

using Common.ValueObjects;
using EventSourcing.Events.Baskets;
using MassTransit;
using MediatR;
using Order.Application.Features.Order.Commands;
using Order.Application.Dtos.Orders;
using Order.Application.Dtos.ValueObjects;
using Order.Domain.Abstractions;
using Order.Domain.Entities;
using System.Text.Json;

#endregion

namespace Order.Worker.Consumer.EventHandlers.Integrations;

public sealed class BasketCheckoutIntegrationEventHandler(
    IMediator sender,
    IUnitOfWork unitOfWork,
    ILogger<BasketCheckoutIntegrationEventHandler> logger)
    : IConsumer<BasketCheckoutIntegrationEvent>
{
    #region Methods

    public async Task Consume(ConsumeContext<BasketCheckoutIntegrationEvent> context)
    {
        var message = context.Message;
        var messageId = context.MessageId ?? Guid.NewGuid();

        // Check if message already exists in inbox (idempotency)
        var existingMessage = await unitOfWork.InboxMessages
            .FirstOrDefaultAsync(m => m.Id == messageId, context.CancellationToken);

        if (existingMessage != null)
        {
            logger.LogInformation("Message {MessageId} already processed. Skipping.", messageId);
            return;
        }

        // Create inbox record to track this event
        var inboxMessage = InboxMessageEntity.Create(
            messageId,
            message.GetType().AssemblyQualifiedName!,
            JsonSerializer.Serialize(message),
            DateTimeOffset.UtcNow);

        await unitOfWork.InboxMessages.AddAsync(inboxMessage, context.CancellationToken);
        await unitOfWork.SaveChangesAsync(context.CancellationToken);

        logger.LogInformation("Processing integration event {EventType} with ID {MessageId}",
            message.GetType().Name, messageId);

        try
        {
            // Process the event
            var dto = new CreateOrUpdateOrderDto
            {
                Customer = new CustomerDto
                {
                    Id = message.Customer.Id,
                    Name = message.Customer.Name,
                    Email = message.Customer.Email,
                    PhoneNumber = message.Customer.PhoneNumber
                },
                ShippingAddress = new AddressDto
                {
                    AddressLine = message.ShippingAddress.AddressLine,
                    Subdivision = message.ShippingAddress.Subdivision,
                    City = message.ShippingAddress.City,
                    StateOrProvince = message.ShippingAddress.StateOrProvince,
                    Country = message.ShippingAddress.Country,
                    PostalCode = message.ShippingAddress.PostalCode
                },
                OrderItems = message.Items.Select(item => new CreateOrderItemDto
                {
                    ProductId = item.ProductId,
                    Quantity = item.Quantity
                }).ToList(),
                CouponCode = message.Discount.CouponCode
            };

            var command = new CreateOrderCommand(dto, Actor.User(dto.Customer.Id.ToString()!));
            await sender.Send(command, context.CancellationToken);

            // Mark as successfully processed
            inboxMessage.CompleteProcessing(DateTimeOffset.UtcNow);
            await unitOfWork.SaveChangesAsync(context.CancellationToken);

            logger.LogInformation("Successfully processed event {MessageId}", messageId);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Failed to process event {MessageId}", messageId);

            // Mark as failed
            inboxMessage.CompleteProcessing(DateTimeOffset.UtcNow, ex.Message);
            await unitOfWork.SaveChangesAsync(context.CancellationToken);

            throw;
        }
    }

    #endregion
}
</file>

<file path="Services/Order/Worker/Order.Worker.Consumer/EventHandlers/Integrations/ReservationExpiredIntegrationEventHandler.cs">
#region using

using Common.ValueObjects;
using Common.Constants;
using EventSourcing.Events.Inventories;
using MassTransit;
using MediatR;
using Order.Application.Features.Order.Commands;
using Order.Domain.Enums;
using Order.Domain.Abstractions;
using Order.Domain.Entities;
using System.Text.Json;

#endregion

namespace Order.Worker.Consumer.EventHandlers.Integrations;

public sealed class ReservationExpiredIntegrationEventHandler(
    ISender sender,
    IUnitOfWork unitOfWork,
    ILogger<ReservationExpiredIntegrationEventHandler> logger)
    : IConsumer<ReservationExpiredIntegrationEvent>
{
    #region Methods

    public async Task Consume(ConsumeContext<ReservationExpiredIntegrationEvent> context)
    {
        var message = context.Message;
        var messageId = context.MessageId ?? Guid.NewGuid();

        // Check if message already exists in inbox (idempotency)
        var existingMessage = await unitOfWork.InboxMessages
            .FirstOrDefaultAsync(m => m.Id == messageId, context.CancellationToken);

        if (existingMessage != null)
        {
            logger.LogInformation("Message {MessageId} already processed. Skipping.", messageId);
            return;
        }

        var inboxMessage = InboxMessageEntity.Create(
            messageId,
            message.GetType().AssemblyQualifiedName!,
            JsonSerializer.Serialize(message),
            DateTimeOffset.UtcNow);

        await unitOfWork.InboxMessages.AddAsync(inboxMessage, context.CancellationToken);
        await unitOfWork.SaveChangesAsync(context.CancellationToken);

        logger.LogInformation("Processing integration event {EventType} with ID {MessageId}",
            message.GetType().Name, messageId);

        try
        {
            // Process the event
            var command = new UpdateOrderStatusCommand(
                OrderId: message.OrderId,
                Status: OrderStatus.Canceled,
                Reason: "Order automatically cancelled due to expired inventory reservation",
                Actor: Actor.Consumer(AppConstants.Service.Order));

            await sender.Send(command, context.CancellationToken);

            // Mark as successfully processed
            inboxMessage.CompleteProcessing(DateTimeOffset.UtcNow);
            await unitOfWork.SaveChangesAsync(context.CancellationToken);

            logger.LogInformation(
                "Successfully cancelled order {OrderId} due to expired reservation {ReservationId} for product {ProductId}",
                message.OrderId, message.ReservationId, message.ProductId);
        }
        catch (Exception ex)
        {
            logger.LogError(ex,
                "Failed to cancel order {OrderId} due to expired reservation {ReservationId}",
                message.OrderId, message.ReservationId);

            // Mark as failed
            inboxMessage.CompleteProcessing(DateTimeOffset.UtcNow, ex.Message);
            await unitOfWork.SaveChangesAsync(context.CancellationToken);

            throw;
        }
    }

    #endregion
}
</file>

<file path="Services/Order/Worker/Order.Worker.Consumer/DependencyInjection.cs">
#region using

using BuildingBlocks.Logging;
using EventSourcing.MassTransit;
using System.Reflection;

#endregion

namespace Order.Worker.Consumer;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddWorkerServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddSerilogLogging(cfg);
        services.AddMessageBroker(cfg, Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Order/Worker/Order.Worker.Consumer/Order.Worker.Consumer.csproj">
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <PropertyGroup>
    <UserSecretsId>dotnet-Order.Worker.Consumer-bf551538-9dee-48f1-9f0b-47f6cba597e3</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Order.Application\Order.Application.csproj" />
    <ProjectReference Include="..\..\Core\Order.Infrastructure\Order.Infrastructure.csproj" />
  </ItemGroup>
  
</Project>
</file>

<file path="Services/Order/Worker/Order.Worker.Consumer/Program.cs">
#region using

using Order.Application;
using Order.Infrastructure;
using Order.Worker.Consumer;
using Order.Worker.Consumer.BackgroundServices;

#endregion

var builder = Host.CreateApplicationBuilder(args);

builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddWorkerServices(builder.Configuration)
    .AddHostedService<OrderBackgroudService>();

var host = builder.Build();
host.Run();
</file>

<file path="Services/Report/Api/Report.Api/Constants/ApiRoutes.cs">
namespace Report.Api.Constants;

public sealed class ApiRoutes
{
    public static class ReportStatistics
    {
        #region Constants

        public const string Tags = "Report Statistics";

        public const string GetDashboardStatistics = "/admin/dashboard-statistics";

        public const string GetOrderGrowthStatistics = "/admin/order-growth-statistics";

        public const string GetTopProductStatistics = "/admin/top-product-statistics";

        #endregion
    }
}
</file>

<file path="Services/Report/Api/Report.Api/Endpoints/GetDashboardTotals.cs">
#region using

using Report.Api.Constants;
using Report.Application.Features.DashboardTotal.Queries;
using Report.Application.Models.Results;

#endregion

namespace Report.Api.Endpoints;

public sealed class GetDashboardTotals : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.ReportStatistics.GetDashboardStatistics, HandleGetDashboardTotalsAsync)
            .WithTags(ApiRoutes.ReportStatistics.Tags)
            .WithName(nameof(GetDashboardTotals))
            .Produces<ApiGetResponse<DashboardTotalsResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<DashboardTotalsResult>> HandleGetDashboardTotalsAsync(
        ISender sender,
        CancellationToken cancellationToken)
    {
        var query = new GetDashboardTotalsQuery();
        var result = await sender.Send(query, cancellationToken);

        return new ApiGetResponse<DashboardTotalsResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Report/Api/Report.Api/Endpoints/GetOrderGrowthLineChart.cs">
#region using

using Report.Api.Constants;
using Report.Application.Features.OrderGrowthLineChart.Queries;
using Report.Application.Models.Results;

#endregion

namespace Report.Api.Endpoints;

public sealed record GetOrderGrowthLineChartRequest(int? Year, int? Month);

public sealed class GetOrderGrowthLineChart : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.ReportStatistics.GetOrderGrowthStatistics, HandleGetOrderGrowthLineChartAsync)
            .WithTags(ApiRoutes.ReportStatistics.Tags)
            .WithName(nameof(GetOrderGrowthLineChart))
            .Produces<ApiGetResponse<OrderGrowthLineChartResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<OrderGrowthLineChartResult>> HandleGetOrderGrowthLineChartAsync(
        ISender sender,
        [AsParameters] GetOrderGrowthLineChartRequest request,
        CancellationToken cancellationToken)
    {
        var query = new GetOrderGrowthLineChartQuery(request.Year, request.Month);
        var result = await sender.Send(query, cancellationToken);

        return new ApiGetResponse<OrderGrowthLineChartResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Report/Api/Report.Api/Endpoints/GetTopProductPieChart.cs">
#region using

using Report.Api.Constants;
using Report.Application.Features.TopProductPieChart.Queries;
using Report.Application.Models.Results;

#endregion

namespace Report.Api.Endpoints;

public sealed record GetTopProductPieChartRequest(int Limit = 5);

public sealed class GetTopProductPieChart : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.ReportStatistics.GetTopProductStatistics, HandleGetTopProductPieChartAsync)
            .WithTags(ApiRoutes.ReportStatistics.Tags)
            .WithName(nameof(GetTopProductPieChart))
            .Produces<ApiGetResponse<TopProductPieChartResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .RequireAuthorization();
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<TopProductPieChartResult>> HandleGetTopProductPieChartAsync(
        ISender sender,
        [AsParameters] GetTopProductPieChartRequest request,
        CancellationToken cancellationToken)
    {
        var query = new GetTopProductPieChartQuery(request.Limit);
        var result = await sender.Send(query, cancellationToken);

        return new ApiGetResponse<TopProductPieChartResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Report/Api/Report.Api/DependencyInjection.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using BuildingBlocks.Swagger.Extensions;
using Common.Configurations;
using Common.Constants;
using HealthChecks.UI.Client;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;

#endregion

namespace Report.Api;

public static class DependencyInjection
{
    public static IServiceCollection AddApiServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services.AddCarter();

        var dbype = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DbType}"];
        var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];
        var dbName = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DatabaseName}"];

        switch (dbype)
        {
            case DatabaseType.SqlServer:
                services.AddHealthChecks()
                    .AddSqlServer(connectionString: conn!);
                break;
            case DatabaseType.MySql:
                services.AddHealthChecks()
                    .AddMySql(connectionString: conn!);
                break;
            case DatabaseType.PostgreSql:
                services.AddHealthChecks()
                    .AddNpgSql(connectionString: conn!);
                break;
            case DatabaseType.MongoDb:
                services.AddHealthChecks()
                    .AddMongoDb(
                        clientFactory: sp => new MongoDB.Driver.MongoClient(conn!),
                        databaseNameFactory: sp => dbName!);
                break;
            default:
                throw new Exception("Unsupported database type");
        }

        services.AddHttpContextAccessor();
        services.AddAuthenticationAndAuthorization(cfg);
        services.AddSwaggerServices(cfg);

        return services;
    }

    public static WebApplication UseApi(this WebApplication app)
    {
        app.UseSerilogReqLogging();
        app.UsePrometheusEndpoint();
        app.MapCarter();
        app.UseExceptionHandler(options => { });
        app.UseHealthChecks("/health",
            new HealthCheckOptions
            {
                ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
            });

        app.UseAuthentication();
        app.UseAuthorization();
        app.UseSwaggerApi();

        app.MapGet("/", (IWebHostEnvironment env) => new ApiDefaultPathResponse
        {
            Service = "Report.Api",
            Status = "Running",
            Timestamp = DateTimeOffset.UtcNow,
            Environment = env.EnvironmentName,
            Endpoints = new Dictionary<string, string>
            {
                { "health", "/health" }
            },
            Message = "API is running..."
        });

        return app;
    }
}
</file>

<file path="Services/Report/Api/Report.Api/GlobalUsing.cs">
global using Carter;
global using MediatR;
global using Common.Models.Reponses;
</file>

<file path="Services/Report/Api/Report.Api/Program.cs">
#region using

using Report.Api;
using Report.Application;
using Report.Infrastructure;

#endregion

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddApiServices(builder.Configuration);

var app = builder.Build();

// Configure the HTTP request pipeline.
app.UseApi();
app.UseInfrastructure();

app.Run();
</file>

<file path="Services/Report/Api/Report.Api/Report.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <UserSecretsId>68beccec-977d-4711-a7f7-5d8d06e5c2e0</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="AspNetCore.HealthChecks.MongoDb" />
    <PackageReference Include="AspNetCore.HealthChecks.MySql" />
    <PackageReference Include="AspNetCore.HealthChecks.NpgSql" />
    <PackageReference Include="AspNetCore.HealthChecks.Redis" />
    <PackageReference Include="AspNetCore.HealthChecks.SqlServer" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" />
    <PackageReference Include="Carter" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Report.Application\Report.Application.csproj" />
    <ProjectReference Include="..\..\Core\Report.Infrastructure\Report.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Report/Api/Report.Grpc/Interceptors/ApiKeyValidationInterceptor.cs">
#region using

using Common.Configurations;
using Common.Constants;
using Grpc.Core;
using Grpc.Core.Interceptors;

#endregion

namespace Report.Grpc.Interceptors;

public class ApiKeyValidationInterceptor(IConfiguration cfg) : Interceptor
{
    #region Methods

    public override async Task<TResponse> UnaryServerHandler<TRequest, TResponse>(
        TRequest request,
        ServerCallContext context,
        UnaryServerMethod<TRequest, TResponse> continuation)
    {
        var provided = context.RequestHeaders.FirstOrDefault(h => h.Key == ReqHeaderName.GrpcKey)?.Value;
        var grpcKey = cfg.GetValue<string>($"{AppConfigCfg.Section}:{AppConfigCfg.GrpcApiKey}");

        if (string.IsNullOrEmpty(provided) || !TimeConstantEquals(provided, grpcKey!))
        {
            throw new RpcException(new Status(StatusCode.Unauthenticated, MessageCode.Unauthorized));
        }

        return await continuation(request, context);
    }

    // Constant-time comparison to mitigate timing attacks (micro-optimization).
    private static bool TimeConstantEquals(string a, string b)
    {
        if (a.Length != b.Length) return false;
        var diff = 0;
        for (int i = 0; i < a.Length; i++)
            diff |= a[i] ^ b[i];
        return diff == 0;
    }

    #endregion
}
</file>

<file path="Services/Report/Api/Report.Grpc/Services/ReportGrpcService.cs">
#region using

using Common.ValueObjects;
using Common.Constants;
using Grpc.Core;
using MediatR;
using Report.Application.Features.DashboardTotal.Commands;
using Report.Application.Features.OrderGrowthLineChart.Commands;
using Report.Application.Features.TopProductPieChart.Commands;
using Report.Application.Dtos.DashboardTotals;
using Report.Application.Dtos.OrderGrowthLineCharts;
using Report.Application.Dtos.TopProductPieCharts;

#endregion

namespace Report.Grpc.Services;

public sealed class ReportGrpcService(ISender sender) : ReportGrpc.ReportGrpcBase
{
    #region Methods

    public override async Task<PutDashboardTotalResponse> PutDashboardTotal(PutDashboardTotalRequest request, ServerCallContext context)
    {
        var dto = new UpdateDashboardTotalDto
        {
            Title = request.Title,
            Count = request.Count
        };

        var command = new UpdateDashboardTotalCommand(dto, Actor.System(AppConstants.Service.Report));
        await sender.Send(command, context.CancellationToken);

        return new PutDashboardTotalResponse { Success = true };
    }

    public override async Task<PutOrderGrowthLineChartResponse> PutOrderGrowthLineChart(PutOrderGrowthLineChartRequest request, ServerCallContext context)
    {
        var items = request.Items.Select(item => new UpdateOrderGrowthLineChartDto
        {
            Day = item.Day,
            Value = item.Value,
            Date = item.Date?.ToDateTime() ?? DateTime.UtcNow
        }).ToList();

        var dto = new UpdateOrderGrowthLineChartListDto
        {
            Items = items
        };

        var command = new UpdateOrderGrowthLineChartCommand(dto, Actor.System(AppConstants.Service.Report));
        await sender.Send(command, context.CancellationToken);

        return new PutOrderGrowthLineChartResponse { Success = true };
    }

    public override async Task<PutTopProductPieChartResponse> PutTopProductPieChart(PutTopProductPieChartRequest request, ServerCallContext context)
    {
        var items = request.Items.Select(item => new UpdateTopProductPieChartDto
        {
            Name = item.Name,
            Value = item.Value
        }).ToList();

        var dto = new UpdateTopProductPieChartListDto
        {
            Items = items
        };

        var command = new UpdateTopProductPieChartCommand(dto, Actor.System(AppConstants.Service.Report));
        await sender.Send(command, context.CancellationToken);

        return new PutTopProductPieChartResponse { Success = true };
    }

    #endregion
}
</file>

<file path="Services/Report/Api/Report.Grpc/DependencyInjection.cs">
#region using

using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using Report.Grpc.Interceptors;

#endregion

namespace Report.Grpc;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddGrpcServices(
       this IServiceCollection services,
       IConfiguration cfg)
    {
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services
            .AddGrpc(o =>
            {
                o.Interceptors.Add<ApiKeyValidationInterceptor>();
            })
            .AddJsonTranscoding();
        services.AddSingleton<ApiKeyValidationInterceptor>();

        return services;
    }

    #endregion
}
</file>

<file path="Services/Report/Api/Report.Grpc/Program.cs">
#region using

using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using Report.Application;
using Report.Grpc;
using Report.Infrastructure;

#endregion

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddGrpcServices(builder.Configuration);

var app = builder.Build();

app.UseSerilogReqLogging();
app.UsePrometheusEndpoint();

app.MapGrpcService<Report.Grpc.Services.ReportGrpcService>();
app.MapGet("/", () => "Report gRPC is running...");

app.Run();
</file>

<file path="Services/Report/Api/Report.Grpc/Report.Grpc.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <ItemGroup>
    <Protobuf Include="..\..\..\..\Shared\Contracts\Report.Contract\Protos\report.proto" GrpcServices="Server" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="grpc.tools">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="microsoft.aspnetcore.grpc.jsontranscoding" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Contracts\Report.Contract\Report.Contract.csproj" />
    <ProjectReference Include="..\..\Core\Report.Application\Report.Application.csproj" />
    <ProjectReference Include="..\..\Core\Report.Infrastructure\Report.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Report/Core/Report.Application/Data/Repositories/IDashboardTotalRepository.cs">
#region using

using Report.Domain.Entities;

#endregion

namespace Report.Application.Data.Repositories;

public interface IDashboardTotalRepository
{
    #region Methods

    Task<List<DashboardTotalEntity>> GetAllAsync(CancellationToken cancellationToken = default);

    Task BulkUpsertAsync(List<DashboardTotalEntity> entities, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Data/Repositories/IOrderGrowthLineChartRepository.cs">
#region using

using Report.Domain.Entities;

#endregion

namespace Report.Application.Data.Repositories;

public interface IOrderGrowthLineChartRepository
{
    #region Methods

    Task<List<OrderGrowthLineChartEntity>> GetByMonthAsync(int year, int month, CancellationToken cancellationToken = default);

    Task<List<OrderGrowthLineChartEntity>> GetByDateRangeAsync(DateTime startDate, DateTime endDate, CancellationToken cancellationToken = default);

    Task BulkUpsertAsync(List<OrderGrowthLineChartEntity> entities, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Data/Repositories/ITopProductPieChartRepository.cs">
#region using

using Report.Domain.Entities;

#endregion

namespace Report.Application.Data.Repositories;

public interface ITopProductPieChartRepository
{
    #region Methods

    Task<List<TopProductPieChartEntity>> GetTopProductsAsync(int limit = 5, CancellationToken cancellationToken = default);

    Task BulkUpsertAsync(List<TopProductPieChartEntity> entities, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Dtos/Abstractions/AuditableDto.cs">
#region using

#endregion

namespace Report.Application.Dtos.Abstractions;

public abstract class AuditableDto : IAuditableDto
{
    #region Fields Properties and Indexers

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}

public interface IAuditableDto : ICreationAuditDto, IModificationAuditDto { }
</file>

<file path="Services/Report/Core/Report.Application/Dtos/Abstractions/DtoId.cs">
namespace Report.Application.Dtos.Abstractions;

public class DtoId<T> : IDtoId<T>
{
    #region Fields Properties and Indexers

    public T Id { get; init; } = default!;

    #endregion
}

public interface IDtoId<T>
{
    T Id { get; init; }
}
</file>

<file path="Services/Report/Core/Report.Application/Dtos/Abstractions/EntityDto.cs">
namespace Report.Application.Dtos.Abstractions;

public abstract class EntityDto<T> : IDtoId<T>, IAuditableDto
{
    #region Fields Properties and Indexers

    public T Id { get; init; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Dtos/Abstractions/ICreationAuditDto.cs">
namespace Report.Application.Dtos.Abstractions;

public interface ICreationAuditDto
{
    #region Fields Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Dtos/Abstractions/IModificationAuditDto.cs">
namespace Report.Application.Dtos.Abstractions;

public interface IModificationAuditDto
{
    #region Fields Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Report/Core/Report.Application/Dtos/DashboardTotals/DashboardTotalDto.cs">
#region using

using Report.Application.Dtos.Abstractions;

#endregion

namespace Report.Application.Dtos.DashboardTotals;

public sealed class DashboardTotalDto : DtoId<Guid>
{
    #region Fields Properties and Indexers

    public string? Bg { get; set; }

    public string? Text { get; set; }

    public string? Icon { get; set; }

    public string? Title { get; set; }

    public string? Count { get; set; }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Dtos/DashboardTotals/UpdateDashboardTotalDto.cs">
namespace Report.Application.Dtos.DashboardTotals;

public sealed class UpdateDashboardTotalDto
{
    #region Fields, Properties and Indexers

    public string? Title { get; set; }

    public string? Count { get; set; }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Dtos/OrderGrowthLineCharts/OrderGrowthLineChartDto.cs">
#region using

using Report.Application.Dtos.Abstractions;

#endregion

namespace Report.Application.Dtos.OrderGrowthLineCharts;

public sealed class OrderGrowthLineChartDto : DtoId<Guid>
{
    #region Fields, Properties and Indexers

    public int Day { get; set; }

    public double Value { get; set; }

    public DateTime Date { get; set; }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Dtos/OrderGrowthLineCharts/UpdateOrderGrowthLineChartDto.cs">
namespace Report.Application.Dtos.OrderGrowthLineCharts;

public sealed class UpdateOrderGrowthLineChartDto
{
    #region Fields, Properties and Indexers

    public int Day { get; set; }

    public double Value { get; set; }

    public DateTime Date { get; set; }

    #endregion
}

public sealed class UpdateOrderGrowthLineChartListDto
{
    #region Fields, Properties and Indexers

    public List<UpdateOrderGrowthLineChartDto> Items { get; set; } = new();

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Dtos/TopProductPieCharts/TopProductPieChartDto.cs">
#region using

using Report.Application.Dtos.Abstractions;

#endregion

namespace Report.Application.Dtos.TopProductPieCharts;

public sealed class TopProductPieChartDto : DtoId<Guid>
{
    #region Fields, Properties and Indexers

    public string Name { get; set; } = default!;

    public double Value { get; set; }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Dtos/TopProductPieCharts/UpdateTopProductPieChartDto.cs">
namespace Report.Application.Dtos.TopProductPieCharts;

public sealed class UpdateTopProductPieChartDto
{
    #region Fields, Properties and Indexers

    public string Name { get; set; } = default!;

    public double Value { get; set; }

    #endregion
}

public sealed class UpdateTopProductPieChartListDto
{
    #region Fields, Properties and Indexers

    public List<UpdateTopProductPieChartDto> Items { get; set; } = new();

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Exceptions/ApplicationException.cs">
namespace Report.Application.Exceptions;

public sealed class ApplicationException : Exception
{
    #region Ctors

    public ApplicationException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Features/DashboardTotal/Commands/UpdateDashboardTotalCommand.cs">
#region using

using Report.Application.Data.Repositories;
using MediatR;
using Report.Application.Dtos.DashboardTotals;

#endregion

namespace Report.Application.Features.DashboardTotal.Commands;

public sealed record UpdateDashboardTotalCommand(UpdateDashboardTotalDto Dto, Actor Actor) : ICommand<Unit>;

public sealed class UpdateDashboardTotalCommandValidator : AbstractValidator<UpdateDashboardTotalCommand>
{
    #region Ctors

    public UpdateDashboardTotalCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest)
            .DependentRules(() =>
            {
                RuleFor(x => x.Dto.Title)
                    .NotEmpty()
                    .WithMessage(MessageCode.TitleIsRequired);

                RuleFor(x => x.Dto.Count)
                    .NotEmpty()
                    .WithMessage(MessageCode.CountIsRequired);
            });
    }

    #endregion
}

public sealed class UpdateDashboardTotalCommandHandler(IDashboardTotalRepository repository) : ICommandHandler<UpdateDashboardTotalCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(UpdateDashboardTotalCommand command, CancellationToken cancellationToken)
    {
        var entities = await repository.GetAllAsync(cancellationToken)
            ?? throw new NotFoundException(MessageCode.ResourceNotFound);

        foreach (var entity in entities)
        {
            if (entity.Title == command.Dto.Title)
            {
                entity.UpdateCount(command.Dto.Count!, command.Actor.ToString());
            }
        }

        await repository.BulkUpsertAsync(entities, cancellationToken);

        return Unit.Value;
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Features/DashboardTotal/Queries/GetDashboardTotalsQuery.cs">
#region using

using AutoMapper;
using Report.Application.Data.Repositories;
using Report.Application.Dtos.DashboardTotals;
using Report.Application.Models.Results;

#endregion

namespace Report.Application.Features.DashboardTotal.Queries;

public sealed record GetDashboardTotalsQuery() : IQuery<DashboardTotalsResult>;

public sealed class GetDashboardTotalsQueryHandler(
    IDashboardTotalRepository repository,
    IMapper mapper)
    : IQueryHandler<GetDashboardTotalsQuery, DashboardTotalsResult>
{
    #region Implementations

    public async Task<DashboardTotalsResult> Handle(GetDashboardTotalsQuery query, CancellationToken cancellationToken)
    {
        var result = await repository.GetAllAsync(cancellationToken);
        var items = mapper.Map<List<DashboardTotalDto>>(result);
        return new DashboardTotalsResult(items);
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Features/OrderGrowthLineChart/Commands/UpdateOrderGrowthLineChartCommand.cs">
#region using

using MediatR;
using Report.Application.Data.Repositories;
using Report.Application.Dtos.OrderGrowthLineCharts;
using Report.Domain.Entities;

#endregion

namespace Report.Application.Features.OrderGrowthLineChart.Commands;

public sealed record UpdateOrderGrowthLineChartCommand(UpdateOrderGrowthLineChartListDto Dto, Actor Actor) : ICommand<Unit>;

public sealed class UpdateOrderGrowthLineChartCommandValidator : AbstractValidator<UpdateOrderGrowthLineChartCommand>
{
    #region Ctors

    public UpdateOrderGrowthLineChartCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest);

        RuleForEach(x => x.Dto.Items)
            .ChildRules(item =>
            {
                item.RuleFor(x => x.Day)
                    .InclusiveBetween(1, 31)
                    .WithMessage(MessageCode.InvalidDayRange);

                item.RuleFor(x => x.Value)
                    .GreaterThanOrEqualTo(0)
                    .WithMessage(MessageCode.ValueCannotBeNegative);
            });
    }

    #endregion
}

public sealed class UpdateOrderGrowthLineChartCommandHandler(IOrderGrowthLineChartRepository repository)
    : ICommandHandler<UpdateOrderGrowthLineChartCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(UpdateOrderGrowthLineChartCommand command, CancellationToken cancellationToken)
    {
        if (!command.Dto.Items.Any())
        {
            return Unit.Value;
        }

        var groupedByDate = command.Dto.Items
            .GroupBy(x => new { x.Date.Year, x.Date.Month })
            .ToList();

        foreach (var group in groupedByDate)
        {
            var year = group.Key.Year;
            var month = group.Key.Month;

            var existingEntities = await repository.GetByMonthAsync(year, month, cancellationToken);

            foreach (var dto in group)
            {
                var existingEntity = existingEntities.FirstOrDefault(x => x.Day == dto.Day);

                if (existingEntity != null)
                {
                    existingEntity.UpdateValue(dto.Value, command.Actor.ToString());
                }
                else
                {
                    var newEntity = OrderGrowthLineChartEntity.Create(
                        day: dto.Day,
                        value: dto.Value,
                        date: dto.Date,
                        performedBy: command.Actor.ToString());

                    existingEntities.Add(newEntity);
                }
            }

            await repository.BulkUpsertAsync(existingEntities, cancellationToken);
        }

        return Unit.Value;
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Features/OrderGrowthLineChart/Queries/GetOrderGrowthLineChartQuery.cs">
#region using

using AutoMapper;
using Report.Application.Data.Repositories;
using Report.Application.Dtos.OrderGrowthLineCharts;
using Report.Application.Models.Results;

#endregion

namespace Report.Application.Features.OrderGrowthLineChart.Queries;

public sealed record GetOrderGrowthLineChartQuery(int? Year = null, int? Month = null) : IQuery<OrderGrowthLineChartResult>;

public sealed class GetOrderGrowthLineChartQueryHandler(
    IOrderGrowthLineChartRepository repository,
    IMapper mapper)
    : IQueryHandler<GetOrderGrowthLineChartQuery, OrderGrowthLineChartResult>
{
    #region Implementations

    public async Task<OrderGrowthLineChartResult> Handle(GetOrderGrowthLineChartQuery query, CancellationToken cancellationToken)
    {
        List<Report.Domain.Entities.OrderGrowthLineChartEntity> result;

        if (query.Year.HasValue && query.Month.HasValue)
        {
            result = await repository.GetByMonthAsync(query.Year.Value, query.Month.Value, cancellationToken);
        }
        else
        {
            var now = DateTime.UtcNow;
            result = await repository.GetByMonthAsync(now.Year, now.Month, cancellationToken);
        }

        var items = mapper.Map<List<OrderGrowthLineChartDto>>(result);
        return new OrderGrowthLineChartResult(items);
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Features/TopProductPieChart/Commands/UpdateTopProductPieChartCommand.cs">
#region using

using MediatR;
using Report.Application.Data.Repositories;
using Report.Application.Dtos.TopProductPieCharts;
using Report.Domain.Entities;

#endregion

namespace Report.Application.Features.TopProductPieChart.Commands;

public sealed record UpdateTopProductPieChartCommand(UpdateTopProductPieChartListDto Dto, Actor Actor) : ICommand<Unit>;

public sealed class UpdateTopProductPieChartCommandValidator : AbstractValidator<UpdateTopProductPieChartCommand>
{
    #region Ctors

    public UpdateTopProductPieChartCommandValidator()
    {
        RuleFor(x => x.Dto)
            .NotNull()
            .WithMessage(MessageCode.BadRequest);

        RuleForEach(x => x.Dto.Items)
            .ChildRules(item =>
            {
                item.RuleFor(x => x.Name)
                    .NotEmpty()
                    .WithMessage(MessageCode.NameIsRequired);

                item.RuleFor(x => x.Value)
                    .GreaterThanOrEqualTo(0)
                    .WithMessage(MessageCode.ValueCannotBeNegative);
            });
    }

    #endregion
}

public sealed class UpdateTopProductPieChartCommandHandler(ITopProductPieChartRepository repository)
    : ICommandHandler<UpdateTopProductPieChartCommand, Unit>
{
    #region Implementations

    public async Task<Unit> Handle(UpdateTopProductPieChartCommand command, CancellationToken cancellationToken)
    {
        if (!command.Dto.Items.Any())
        {
            return Unit.Value;
        }

        var existingEntities = await repository.GetTopProductsAsync(limit: 100, cancellationToken);

        foreach (var dto in command.Dto.Items)
        {
            var existingEntity = existingEntities.FirstOrDefault(x => x.Name == dto.Name);

            if (existingEntity != null)
            {
                existingEntity.UpdateValue(dto.Value, command.Actor.ToString());
            }
            else
            {
                var newEntity = TopProductPieChartEntity.Create(
                    name: dto.Name,
                    value: dto.Value,
                    performedBy: command.Actor.ToString());

                existingEntities.Add(newEntity);
            }
        }

        await repository.BulkUpsertAsync(existingEntities, cancellationToken);

        return Unit.Value;
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Features/TopProductPieChart/Queries/GetTopProductPieChartQuery.cs">
#region using

using AutoMapper;
using Report.Application.Data.Repositories;
using Report.Application.Dtos.TopProductPieCharts;
using Report.Application.Models.Results;

#endregion

namespace Report.Application.Features.TopProductPieChart.Queries;

public sealed record GetTopProductPieChartQuery(int Limit = 5) : IQuery<TopProductPieChartResult>;

public sealed class GetTopProductPieChartQueryHandler(
    ITopProductPieChartRepository repository,
    IMapper mapper)
    : IQueryHandler<GetTopProductPieChartQuery, TopProductPieChartResult>
{
    #region Implementations

    public async Task<TopProductPieChartResult> Handle(GetTopProductPieChartQuery query, CancellationToken cancellationToken)
    {
        var result = await repository.GetTopProductsAsync(query.Limit, cancellationToken);
        var items = mapper.Map<List<TopProductPieChartDto>>(result);
        return new TopProductPieChartResult(items);
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Mappings/ReportMappingProfile.cs">
#region using

using AutoMapper;
using Report.Application.Dtos.DashboardTotals;
using Report.Application.Dtos.OrderGrowthLineCharts;
using Report.Application.Dtos.TopProductPieCharts;
using Report.Domain.Entities;

#endregion

namespace Report.Application.Mappings;

public sealed class ReportMappingProfile : Profile
{
    #region Ctors

    public ReportMappingProfile()
    {
        CreateMap<DashboardTotalEntity, DashboardTotalDto>();
        CreateMap<OrderGrowthLineChartEntity, OrderGrowthLineChartDto>();
        CreateMap<TopProductPieChartEntity, TopProductPieChartDto>();
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Models/Results/DashboardTotalsResult.cs">
#region using

using Report.Application.Dtos.DashboardTotals;

#endregion

namespace Report.Application.Models.Results;

public sealed class DashboardTotalsResult
{
    #region Fields Properties and Indexers

    public List<DashboardTotalDto> Items { get; set; } = new();

    #endregion

    #region Ctors

    public DashboardTotalsResult(List<DashboardTotalDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Models/Results/OrderGrowthLineChartResult.cs">
#region using

using Report.Application.Dtos.OrderGrowthLineCharts;

#endregion

namespace Report.Application.Models.Results;

public sealed class OrderGrowthLineChartResult
{
    #region Fields, Properties and Indexers

    public List<OrderGrowthLineChartDto> Items { get; set; } = new();

    #endregion

    #region Ctors

    public OrderGrowthLineChartResult(List<OrderGrowthLineChartDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/Models/Results/TopProductPieChartResult.cs">
#region using

using Report.Application.Dtos.TopProductPieCharts;

#endregion

namespace Report.Application.Models.Results;

public sealed class TopProductPieChartResult
{
    #region Fields, Properties and Indexers

    public List<TopProductPieChartDto> Items { get; set; } = new();

    #endregion

    #region Ctors

    public TopProductPieChartResult(List<TopProductPieChartDto> items)
    {
        Items = items;
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/ApplicationMarker.cs">
namespace Report.Application;

public sealed class ApplicationMarker { }
</file>

<file path="Services/Report/Core/Report.Application/DependencyInjection.cs">
#region using

using BuildingBlocks.Behaviors;
using BuildingBlocks.Exceptions.Handler;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.FeatureManagement;
using System.Reflection;

#endregion

namespace Report.Application;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddApplicationServices(this IServiceCollection services)
    {
        services.AddExceptionHandler<CustomExceptionHandler>();
        services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
        services.AddMediatR(config =>
        {
            config.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
            config.AddOpenBehavior(typeof(ValidationBehavior<,>));
            config.AddOpenBehavior(typeof(LoggingBehavior<,>));
        });
        services.AddFeatureManagement();
        services.AddAutoMapper(Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Application/GlobalUsing.cs">
global using BuildingBlocks.CQRS;
global using FluentValidation;
global using Common.Constants;
global using BuildingBlocks.Exceptions;
global using Common.ValueObjects;
</file>

<file path="Services/Report/Core/Report.Application/Report.Application.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="AutoMapper" />
    <PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" />
    <PackageReference Include="Scrutor" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\Report.Domain\Report.Domain.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Constants\" />
    <Folder Include="Models\Results\" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Report/Core/Report.Domain/Abstractions/Aggregate.cs">
namespace Report.Domain.Abstractions;

public abstract class Aggregate<TId> : Entity<TId>, IAggregate<TId>
{
    #region Fields Properties and Indexers

    private readonly List<IDomainEvent> _domainEvents = new();

    #endregion

    #region Implementations

    public IReadOnlyList<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    public void AddDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }

    public IDomainEvent[] ClearDomainEvents()
    {
        IDomainEvent[] dequeuedEvents = _domainEvents.ToArray();

        _domainEvents.Clear();

        return dequeuedEvents;
    }

    #endregion

}
</file>

<file path="Services/Report/Core/Report.Domain/Abstractions/Entity.cs">
#region using

using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;

#endregion

namespace Report.Domain.Abstractions;

public abstract class Entity<T> : IEntityId<T>, IAuditable
{
    #region Fields, Properties and Indexers

    [BsonId]
    [BsonRepresentation(BsonType.String)]
    public T Id { get; set; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Report/Core/Report.Domain/Abstractions/IAggregate.cs">
namespace Report.Domain.Abstractions;

public interface IAggregate<T> : IAggregate, IEntityId<T>
{
}

public interface IAggregate : ICreationAuditable, IModificationAuditable
{
    #region Fields Properties and Indexers

    IReadOnlyList<IDomainEvent> DomainEvents { get; }

    IDomainEvent[] ClearDomainEvents();

    #endregion

}
</file>

<file path="Services/Report/Core/Report.Domain/Abstractions/IAuditable.cs">
namespace Report.Domain.Abstractions;

public interface IAuditable : ICreationAuditable, IModificationAuditable { }
</file>

<file path="Services/Report/Core/Report.Domain/Abstractions/ICreationAuditable.cs">
namespace Report.Domain.Abstractions;

public interface ICreationAuditable
{
    #region Fields Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Report/Core/Report.Domain/Abstractions/IDomainEvent.cs">
#region using

using MediatR;

#endregion

namespace Report.Domain.Abstractions;

public interface IDomainEvent : INotification
{
    #region Fields Properties and Indexers

    Guid EventId => Guid.NewGuid();

    public DateTimeOffset OccurredOn => DateTime.Now;

    public string EventType => GetType()?.AssemblyQualifiedName ?? string.Empty;

    #endregion

}
</file>

<file path="Services/Report/Core/Report.Domain/Abstractions/IEntityId.cs">
namespace Report.Domain.Abstractions;

public interface IEntityId<T>
{
    #region Fields Properties and Indexers

    public T Id { get; set; }

    #endregion

}
</file>

<file path="Services/Report/Core/Report.Domain/Abstractions/IModificationAuditable.cs">
namespace Report.Domain.Abstractions;

public interface IModificationAuditable
{
    #region Fields Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Report/Core/Report.Domain/Entities/DashboardTotalEntity.cs">
#region using

using Report.Domain.Abstractions;

#endregion

namespace Report.Domain.Entities;

public sealed class DashboardTotalEntity : Entity<Guid>
{
    #region Fields Properties and Indexers

    public string? Bg { get; set; }

    public string? Text { get; set; }

    public string? Icon { get; set; }

    public string? Title { get; set; }

    public string? Count { get; set; }

    #endregion

    #region Factories

    public static DashboardTotalEntity Create(
        string title,
        string count,
        string? bg = null,
        string? text = null,
        string? icon = null,
        string? performedBy = null)
    {
        if (string.IsNullOrWhiteSpace(title))
            throw new ArgumentException("Title cannot be null or empty.", nameof(title));

        if (string.IsNullOrWhiteSpace(count))
            throw new ArgumentException("Count cannot be null or empty.", nameof(count));

        var entity = new DashboardTotalEntity
        {
            Id = Guid.NewGuid(),
            Title = title,
            Count = count,
            Bg = bg,
            Text = text,
            Icon = icon,
            CreatedBy = performedBy,
            LastModifiedBy = performedBy,
            CreatedOnUtc = DateTimeOffset.UtcNow,
            LastModifiedOnUtc = DateTimeOffset.UtcNow
        };

        return entity;
    }

    #endregion

    #region Methods

    public void UpdateCount(string count, string performedBy)
    {
        if (string.IsNullOrWhiteSpace(count))
            throw new ArgumentException("Count cannot be null or empty.", nameof(count));

        Count = count;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    public void UpdateDisplay(string? bg, string? text, string? icon, string performedBy)
    {
        Bg = bg;
        Text = text;
        Icon = icon;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Domain/Entities/OrderGrowthLineChartEntity.cs">
#region using

using Report.Domain.Abstractions;

#endregion

namespace Report.Domain.Entities;

public sealed class OrderGrowthLineChartEntity : Entity<Guid>
{
    #region Fields, Properties and Indexers

    public int Day { get; set; }

    public double Value { get; set; }

    public DateTime Date { get; set; }

    #endregion

    #region Factories

    public static OrderGrowthLineChartEntity Create(
        int day,
        double value,
        DateTime date,
        string? performedBy = null)
    {
        if (day < 1 || day > 31)
            throw new ArgumentOutOfRangeException(nameof(day), "Day must be between 1 and 31.");

        if (value < 0)
            throw new ArgumentOutOfRangeException(nameof(value), "Value cannot be negative.");

        var entity = new OrderGrowthLineChartEntity
        {
            Id = Guid.NewGuid(),
            Day = day,
            Value = value,
            Date = date,
            CreatedBy = performedBy,
            LastModifiedBy = performedBy,
            CreatedOnUtc = DateTimeOffset.UtcNow,
            LastModifiedOnUtc = DateTimeOffset.UtcNow
        };

        return entity;
    }

    #endregion

    #region Methods

    public void UpdateValue(double value, string performedBy)
    {
        if (value < 0)
            throw new ArgumentOutOfRangeException(nameof(value), "Value cannot be negative.");

        Value = value;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Domain/Entities/TopProductPieChartEntity.cs">
#region using

using Report.Domain.Abstractions;

#endregion

namespace Report.Domain.Entities;

public sealed class TopProductPieChartEntity : Entity<Guid>
{
    #region Fields, Properties and Indexers

    public string Name { get; set; } = default!;

    public double Value { get; set; }

    #endregion

    #region Factories

    public static TopProductPieChartEntity Create(
        string name,
        double value,
        string? performedBy = null)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Name cannot be null or empty.", nameof(name));

        if (value < 0)
            throw new ArgumentOutOfRangeException(nameof(value), "Value cannot be negative.");

        var entity = new TopProductPieChartEntity
        {
            Id = Guid.NewGuid(),
            Name = name,
            Value = value,
            CreatedBy = performedBy,
            LastModifiedBy = performedBy,
            CreatedOnUtc = DateTimeOffset.UtcNow,
            LastModifiedOnUtc = DateTimeOffset.UtcNow
        };

        return entity;
    }

    #endregion

    #region Methods

    public void UpdateValue(double value, string performedBy)
    {
        if (value < 0)
            throw new ArgumentOutOfRangeException(nameof(value), "Value cannot be negative.");

        Value = value;
        LastModifiedBy = performedBy;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Domain/Enums/DashboardTotalTitle.cs">
#region using

using System.ComponentModel;

#endregion

namespace Report.Domain.Enums;

public enum DashboardTotalTitle
{
    #region Fields, Properties and Indexers

    [Description("Total Orders")]
    TotalOrders,

    [Description("Total Users")]
    TotalUsers,

    [Description("Total Products")]
    TotalProducts,

    [Description("Total Revenue")]
    TotalRevenue

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Domain/Exceptions/DomainException.cs">
namespace Report.Domain.Exceptions;

public sealed class DomainException : Exception
{
    public DomainException(string message) : base(message)
    {
    }
}
</file>

<file path="Services/Report/Core/Report.Domain/Models/Externals/Keycloaks/KeycloakAccessToken.cs">
#region using

using System.Text.Json.Serialization;

#endregion

namespace Report.Domain.Models.Externals.Keycloaks;

public sealed class KeycloakAccessToken
{
    #region Fields, Properties and Indexers

    [JsonPropertyName("access_token")]
    public string? AccessToken { get; set; }

    [JsonPropertyName("expires_in")]
    public int ExpiresIn { get; set; }

    [JsonPropertyName("refresh_expires_in")]
    public int RefreshExpiresIn { get; set; }

    [JsonPropertyName("token_type")]
    public string? TokenType { get; set; }

    [JsonPropertyName("id_token")]
    public string? IdToken { get; set; }

    [JsonPropertyName("not-before-policy")]
    public int NotBeforePolicy { get; set; }

    [JsonPropertyName("scope")]
    public string? Scope { get; set; }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Domain/Models/Externals/Keycloaks/KeycloakUser.cs">
#region using

using System.Text.Json.Serialization;

#endregion

namespace Report.Domain.Models.Externals.Keycloaks;

public sealed class KeycloakUserResponse
{
    #region Fields, Properties and Indexers

    [JsonPropertyName("id")]
    public string Id { get; set; } = default!;

    [JsonPropertyName("createdTimestamp")]
    public long CreatedTimestamp { get; set; }

    [JsonPropertyName("username")]
    public string? Username { get; set; }

    [JsonPropertyName("enabled")]
    public bool Enabled { get; set; }

    [JsonPropertyName("totp")]
    public bool Totp { get; set; }

    [JsonPropertyName("emailVerified")]
    public bool EmailVerified { get; set; }

    [JsonPropertyName("firstName")]
    public string? FirstName { get; set; }

    [JsonPropertyName("lastName")]
    public string? LastName { get; set; }

    [JsonPropertyName("email")]
    public string? Email { get; set; }

    [JsonPropertyName("notBefore")]
    public int NotBefore { get; set; }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Domain/GlobalUsing.cs">

</file>

<file path="Services/Report/Core/Report.Domain/Report.Domain.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="MediatR" />
    <PackageReference Include="MongoDB.Bson" />
    <PackageReference Include="Newtonsoft.Json" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Events\" />
    <Folder Include="Models\Internals\" />
    <Folder Include="ValueObjects\" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Report/Core/Report.Infrastructure/ApiClients/IKeycloakApi.cs">
#region using

using Refit;
using Report.Domain.Models.Externals.Keycloaks;

#endregion

namespace Report.Infrastructure.ApiClients;

public interface IKeycloakApi
{
    #region Methods

    [Post("/realms/{realm}/protocol/openid-connect/token")]
    [Headers("Content-Type: application/x-www-form-urlencoded")]
    Task<KeycloakAccessToken> GetAccessTokenAsync(
        [AliasAs("realm")] string realm,
        [Body(BodySerializationMethod.UrlEncoded)] Dictionary<string, string> form);

    [Get("/admin/realms/{realm}/users")]
    Task<List<KeycloakUserResponse>> GetUsersAsync(
        [AliasAs("realm")] string realm,
        [Header("Authorization")] string bearerToken);

    [Get("/admin/realms/{realm}/roles/{role}/users")]
    Task<List<KeycloakUserResponse>> GetUsersByRoleAsync(
        [AliasAs("realm")] string realm,
        [AliasAs("role")] string role,
        [Header("Authorization")] string bearerToken);

    [Get("/admin/realms/{realm}/users/count")]
    Task<List<KeycloakUserResponse>> GetCountUsersAsync(
        [AliasAs("realm")] string realm,
        [Header("Authorization")] string bearerToken);

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Infrastructure/Constants/MongoCollection.cs">
namespace Report.Infrastructure.Constants;

public sealed class MongoCollection
{
    #region Constants

    public const string DashboardTotal = "dashboard_total";

    public const string OrderGrowthLineChart = "order_growth_line_chart";

    public const string TopProductPieChart = "top_product_pie_chart";

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Infrastructure/Data/Extensions/DatabaseExtentions.cs">
#region using

using Common.ValueObjects;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using MongoDB.Driver;
using Report.Domain.Entities;
using Report.Domain.Enums;
using Report.Infrastructure.Constants;

#endregion

namespace Report.Infrastructure.Data.Extensions;

public static class DatabaseExtentions
{
    #region Methods

    public static async Task InitialiseDatabaseAsync(this WebApplication app)
    {
        var db = app.Services.GetRequiredService<IMongoDatabase>();
        var performedBy = Actor.System(AppConstants.Service.Report).ToString();

        await SeedDashboardTotalAsync(db, performedBy);
    }

    private static async Task SeedDashboardTotalAsync(IMongoDatabase db, string performedBy)
    {
        var collection = db.GetCollection<DashboardTotalEntity>(MongoCollection.DashboardTotal);
        var count = await collection.CountDocumentsAsync(FilterDefinition<DashboardTotalEntity>.Empty);

        if (count > 0) return;

        var models = new List<WriteModel<DashboardTotalEntity>>();
        var docs = new List<DashboardTotalEntity>()
        {
            DashboardTotalEntity.Create(
                title: DashboardTotalTitle.TotalRevenue.GetDescription(),
                count: "0",
                bg: "bg-[#E5F9FF] dark:bg-slate-900",
                text: "text-info-500",
                icon: "heroicons:cube",
                performedBy: performedBy),
            DashboardTotalEntity.Create(
                title: DashboardTotalTitle.TotalUsers.GetDescription(),
                count: "0",
                bg: "bg-[#A5F9FD] dark:bg-slate-900/50",
                text: "text-primary-500",
                icon: "heroicons:user-group",
                performedBy: performedBy),
            DashboardTotalEntity.Create(
                title: DashboardTotalTitle.TotalProducts.GetDescription(),
                count: "0",
                bg: "bg-[#FFEDE6] dark:bg-slate-900",
                text: "text-warning-500",
                icon: "heroicons:circle-stack",
                performedBy: performedBy),
            DashboardTotalEntity.Create(
                title: DashboardTotalTitle.TotalOrders.GetDescription(),
                count: "0",
                bg: "bg-[#EAE6FF] dark:bg-slate-900",
                text: "text-[#5743BE]",
                icon: "heroicons:shopping-cart",
                performedBy: performedBy)
        };

        foreach (var doc in docs)
        {
            var filter = Builders<DashboardTotalEntity>.Filter.Eq(x => x.Title, doc.Title);
            var replace = new ReplaceOneModel<DashboardTotalEntity>(filter, doc)
            {
                IsUpsert = true
            };

            models.Add(replace);
        }

        if (models.Any())
        {
            await collection.BulkWriteAsync(models);
        }
    }

    public static async Task EnsureIndexesAsync(this WebApplication app)
    {
        var db = app.Services.GetRequiredService<IMongoDatabase>();

        // Indexes for DashboardTotalEntity
        var dashboardTotalCollection = db.GetCollection<DashboardTotalEntity>(MongoCollection.DashboardTotal);
        await dashboardTotalCollection.Indexes.CreateOneAsync(
            new CreateIndexModel<DashboardTotalEntity>(
                Builders<DashboardTotalEntity>.IndexKeys.Ascending(x => x.Title),
                new CreateIndexOptions { Unique = true }));

        // Indexes for OrderGrowthLineChartEntity
        var orderGrowthCollection = db.GetCollection<OrderGrowthLineChartEntity>(MongoCollection.OrderGrowthLineChart);
        await orderGrowthCollection.Indexes.CreateOneAsync(
            new CreateIndexModel<OrderGrowthLineChartEntity>(
                Builders<OrderGrowthLineChartEntity>.IndexKeys
                    .Ascending(x => x.Date),
                new CreateIndexOptions { Unique = true }));

        await orderGrowthCollection.Indexes.CreateOneAsync(
            new CreateIndexModel<OrderGrowthLineChartEntity>(
                Builders<OrderGrowthLineChartEntity>.IndexKeys
                    .Descending(x => x.CreatedOnUtc)));

        // Indexes for TopProductPieChartEntity
        var topProductCollection = db.GetCollection<TopProductPieChartEntity>(MongoCollection.TopProductPieChart);
        await topProductCollection.Indexes.CreateOneAsync(
            new CreateIndexModel<TopProductPieChartEntity>(
                Builders<TopProductPieChartEntity>.IndexKeys
                    .Ascending(x => x.Name),
                new CreateIndexOptions { Unique = true }));

        await topProductCollection.Indexes.CreateOneAsync(
            new CreateIndexModel<TopProductPieChartEntity>(
                Builders<TopProductPieChartEntity>.IndexKeys
                    .Descending(x => x.Value)));
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Infrastructure/Exceptions/InfrastructureException.cs">
namespace Report.Infrastructure.Exceptions;

public sealed class InfrastructureException : Exception
{
    #region Ctors

    public InfrastructureException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Infrastructure/GrpcClients/Extensions/GrpcClientExtension.cs">
#region using

using Catalog.Grpc;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Report.Infrastructure.GrpcClients.Interceptors;

#endregion

namespace Report.Infrastructure.GrpcClients.Extensions;

public static class GrpcClientExtension
{
    #region Methods

    public static IServiceCollection AddGrpcClients(this IServiceCollection services, IConfiguration cfg)
    {
        // Catalog Grpc
        var catalogServiceUrl = cfg.GetValue<string>($"{GrpcClientCfg.Catalog.Section}:{GrpcClientCfg.Catalog.Url}")
            ?? throw new InvalidOperationException("Catalog service URL is not configured.");

        services.AddGrpcClient<CatalogGrpc.CatalogGrpcClient>(options =>
        {
            options.Address = new Uri(catalogServiceUrl);
        })
        .AddInterceptor<GrpcApiKeyInterceptor>()
        .ConfigurePrimaryHttpMessageHandler(() =>
        {
            return new HttpClientHandler
            {
                ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
            };
        });

        services.AddSingleton<GrpcApiKeyInterceptor>();

        return services;
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Infrastructure/GrpcClients/Interceptors/GrpcApiKeyInterceptor.cs">
#region using

using Grpc.Core;
using Grpc.Core.Interceptors;
using Microsoft.Extensions.Configuration;

#endregion

namespace Report.Infrastructure.GrpcClients.Interceptors;

public sealed class GrpcApiKeyInterceptor(IConfiguration cfg) : Interceptor
{
    #region Methods

    public override AsyncUnaryCall<TResponse> AsyncUnaryCall<TRequest, TResponse>(
        TRequest request,
        ClientInterceptorContext<TRequest, TResponse> context,
        AsyncUnaryCallContinuation<TRequest, TResponse> continuation)
    {
        var grpcKey = cfg.GetValue<string>($"{GrpcClientCfg.Catalog.Section}:{GrpcClientCfg.Catalog.ApiKey}")
            ?? throw new InvalidOperationException("gRPC Key is not configured.");
        var headers = context.Options.Headers ?? [];
        if (!headers.Any(h => h.Key.Equals(ReqHeaderName.GrpcKey, StringComparison.OrdinalIgnoreCase)))
        {
            headers.Add(ReqHeaderName.GrpcKey, grpcKey);
        }

        var newOptions = context.Options.WithHeaders(headers);
        var newContext = new ClientInterceptorContext<TRequest, TResponse>(
            context.Method,
            context.Host,
            newOptions);

        return base.AsyncUnaryCall(request, newContext, continuation);
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Infrastructure/Repositories/DashboardTotalRepository.cs">
#region using

using MongoDB.Driver;
using Report.Application.Data.Repositories;
using Report.Domain.Entities;
using Report.Infrastructure.Constants;

#endregion

namespace Report.Infrastructure.Repositories;

public sealed class DashboardTotalRepository : IDashboardTotalRepository
{
    #region Fields Properties and Indexers

    private readonly IMongoCollection<DashboardTotalEntity> _collection;

    #endregion

    #region Ctors

    public DashboardTotalRepository(IMongoDatabase db)
    {
        _collection = db.GetCollection<DashboardTotalEntity>(MongoCollection.DashboardTotal);
    }

    #endregion

    #region Implementations

    public async Task<List<DashboardTotalEntity>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await _collection.Find(_ => true)
            .SortBy(x => x.Title)
            .ToListAsync(cancellationToken);
    }

    public async Task BulkUpsertAsync(List<DashboardTotalEntity> entities, CancellationToken cancellationToken = default)
    {
        var models = new List<WriteModel<DashboardTotalEntity>>();

        foreach (var entity in entities)
        {
            var filter = Builders<DashboardTotalEntity>.Filter.Eq(x => x.Title, entity.Title);
            var replace = new ReplaceOneModel<DashboardTotalEntity>(filter, entity)
            {
                IsUpsert = true
            };
            models.Add(replace);
        }

        if (models.Any())
        {
            await _collection.BulkWriteAsync(models, cancellationToken: cancellationToken);
        }
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Infrastructure/Repositories/OrderGrowthLineChartRepository.cs">
#region using

using MongoDB.Driver;
using Report.Application.Data.Repositories;
using Report.Domain.Entities;
using Report.Infrastructure.Constants;

#endregion

namespace Report.Infrastructure.Repositories;

public sealed class OrderGrowthLineChartRepository : IOrderGrowthLineChartRepository
{
    #region Fields, Properties and Indexers

    private readonly IMongoCollection<OrderGrowthLineChartEntity> _collection;

    #endregion

    #region Ctors

    public OrderGrowthLineChartRepository(IMongoDatabase db)
    {
        _collection = db.GetCollection<OrderGrowthLineChartEntity>(MongoCollection.OrderGrowthLineChart);
    }

    #endregion

    #region Implementations

    public async Task<List<OrderGrowthLineChartEntity>> GetByMonthAsync(int year, int month, CancellationToken cancellationToken = default)
    {
        var startDate = new DateTime(year, month, 1);
        var endDate = startDate.AddMonths(1).AddDays(-1);

        var filter = Builders<OrderGrowthLineChartEntity>.Filter.And(
            Builders<OrderGrowthLineChartEntity>.Filter.Gte(x => x.Date, startDate),
            Builders<OrderGrowthLineChartEntity>.Filter.Lte(x => x.Date, endDate));

        return await _collection.Find(filter)
            .SortBy(x => x.Date)
            .ToListAsync(cancellationToken);
    }

    public async Task<List<OrderGrowthLineChartEntity>> GetByDateRangeAsync(DateTime startDate, DateTime endDate, CancellationToken cancellationToken = default)
    {
        var filter = Builders<OrderGrowthLineChartEntity>.Filter.And(
            Builders<OrderGrowthLineChartEntity>.Filter.Gte(x => x.Date, startDate),
            Builders<OrderGrowthLineChartEntity>.Filter.Lte(x => x.Date, endDate));

        return await _collection.Find(filter)
            .SortBy(x => x.Date)
            .ToListAsync(cancellationToken);
    }

    public async Task BulkUpsertAsync(List<OrderGrowthLineChartEntity> entities, CancellationToken cancellationToken = default)
    {
        var models = new List<WriteModel<OrderGrowthLineChartEntity>>();

        foreach (var entity in entities)
        {
            var filter = Builders<OrderGrowthLineChartEntity>.Filter.Eq(x => x.Date, entity.Date);

            var update = Builders<OrderGrowthLineChartEntity>.Update
                .Set(x => x.Day, entity.Day)
                .Set(x => x.Value, entity.Value)
                .Set(x => x.Date, entity.Date)
                .Set(x => x.LastModifiedBy, entity.LastModifiedBy)
                .Set(x => x.LastModifiedOnUtc, entity.LastModifiedOnUtc)
                .SetOnInsert(x => x.Id, entity.Id == Guid.Empty ? Guid.NewGuid() : entity.Id)
                .SetOnInsert(x => x.CreatedBy, entity.CreatedBy)
                .SetOnInsert(x => x.CreatedOnUtc, entity.CreatedOnUtc);

            var updateModel = new UpdateOneModel<OrderGrowthLineChartEntity>(filter, update)
            {
                IsUpsert = true
            };
            models.Add(updateModel);
        }

        if (models.Any())
        {
            await _collection.BulkWriteAsync(models, cancellationToken: cancellationToken);
        }
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Infrastructure/Repositories/TopProductPieChartRepository.cs">
#region using

using MongoDB.Driver;
using Report.Application.Data.Repositories;
using Report.Domain.Entities;
using Report.Infrastructure.Constants;

#endregion

namespace Report.Infrastructure.Repositories;

public sealed class TopProductPieChartRepository : ITopProductPieChartRepository
{
    #region Fields, Properties and Indexers

    private readonly IMongoCollection<TopProductPieChartEntity> _collection;

    #endregion

    #region Ctors

    public TopProductPieChartRepository(IMongoDatabase db)
    {
        _collection = db.GetCollection<TopProductPieChartEntity>(MongoCollection.TopProductPieChart);
    }

    #endregion

    #region Implementations

    public async Task<List<TopProductPieChartEntity>> GetTopProductsAsync(int limit = 5, CancellationToken cancellationToken = default)
    {
        return await _collection.Find(_ => true)
            .SortByDescending(x => x.Value)
            .Limit(limit)
            .ToListAsync(cancellationToken);
    }

    public async Task BulkUpsertAsync(List<TopProductPieChartEntity> entities, CancellationToken cancellationToken = default)
    {
        var models = new List<WriteModel<TopProductPieChartEntity>>();

        foreach (var entity in entities)
        {
            var filter = Builders<TopProductPieChartEntity>.Filter.Eq(x => x.Name, entity.Name);

            var update = Builders<TopProductPieChartEntity>.Update
                .Set(x => x.Name, entity.Name)
                .Set(x => x.Value, entity.Value)
                .Set(x => x.LastModifiedBy, entity.LastModifiedBy)
                .Set(x => x.LastModifiedOnUtc, entity.LastModifiedOnUtc)
                .SetOnInsert(x => x.Id, entity.Id == Guid.Empty ? Guid.NewGuid() : entity.Id)
                .SetOnInsert(x => x.CreatedBy, entity.CreatedBy)
                .SetOnInsert(x => x.CreatedOnUtc, entity.CreatedOnUtc);

            var updateModel = new UpdateOneModel<TopProductPieChartEntity>(filter, update)
            {
                IsUpsert = true
            };
            models.Add(updateModel);
        }

        if (models.Any())
        {
            await _collection.BulkWriteAsync(models, cancellationToken: cancellationToken);
        }
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Infrastructure/Services/CatalogGrpcService.cs">
//#region using

//using Catalog.Grpc;
//using Microsoft.Extensions.Logging;

//#endregion

//namespace Report.Infrastructure.Services;

//public sealed class CatalogGrpcService(CatalogGrpc.CatalogGrpcClient grpcClient, ILogger<CatalogGrpcService> logger) : ICatalogGrpcService
//{
//    #region Methods

//    public async Task<ProductReponse?> GetProductByIdAsync(string productId, CancellationToken cancellationToken = default)
//    {
//        try
//        {
//            var result = await grpcClient.GetProductByIdAsync(
//                new GetProductByIdRequest { Id = productId },
//                cancellationToken: cancellationToken);

//            var product = result.Product;

//            return new ProductReponse()
//            {
//                Id = Guid.Parse(product.Id),
//                Price = (decimal)product.Price,
//                Name = product.Name
//            };
//        }
//        catch (Exception ex)
//        {
//            logger.LogWarning(ex, "Failed to get product by ID {ProductId} from Catalog Grpc service", productId);
//            return null;
//        }
//    }

//    public async Task<GetAllProductsResponse?> GetProductsAsync(string[] ids, string searchText = "", CancellationToken cancellationToken = default)
//    {
//        try
//        {
//            var request = new GetProductsRequest { SearchText = searchText };
//            if (ids is not null && ids.Length > 0)
//                request.Ids.AddRange(ids);

//            var result = await grpcClient.GetProductsAsync(request, cancellationToken: cancellationToken);

//            var response = new GetAllProductsResponse
//            {
//                Items = result.Products
//                    .Select(p => new ProductReponse
//                    {
//                        Id = Guid.Parse(p.Id),
//                        Name = p.Name,
//                        Price = (decimal)p.Price,
//                        Thumbnail = p.Thumbnail
//                    })
//                    .ToList()
//            };

//            return response;
//        }
//        catch (Exception ex)
//        {
//            logger.LogWarning(ex, "Failed to get products from Catalog Grpc service");
//            return null;
//        }
//    }

//    #endregion
//}
</file>

<file path="Services/Report/Core/Report.Infrastructure/DependencyInjection.cs">
#region using

using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using MongoDB.Driver;
using Report.Infrastructure.Data.Extensions;

#endregion

namespace Report.Infrastructure;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddInfrastructureServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("NotificationSender")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithTransientLifetime());

        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Service")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithScopedLifetime());

        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Repository")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithSingletonLifetime());

        // DbContext
        {
            var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];
            var dbName = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DatabaseName}"];

            services.AddSingleton<IMongoClient>(sp =>
            {
                var settings = MongoClientSettings.FromConnectionString(conn);
                return new MongoClient(settings);
            });
            services.AddSingleton<IMongoDatabase>(sp =>
            {
                return sp.GetRequiredService<IMongoClient>().GetDatabase(dbName);
            });
        }

        return services;
    }

    public static WebApplication UseInfrastructure(this WebApplication app)
    {
        app.EnsureIndexesAsync().GetAwaiter();
        app.InitialiseDatabaseAsync().GetAwaiter();

        return app;
    }

    #endregion
}
</file>

<file path="Services/Report/Core/Report.Infrastructure/GlobalUsing.cs">
global using Common.Configurations;
global using Common.Constants;
global using Common.Extensions;
</file>

<file path="Services/Report/Core/Report.Infrastructure/InfrastructureMarker.cs">
namespace Report.Infrastructure;

public sealed class InfrastructureMarker { }
</file>

<file path="Services/Report/Core/Report.Infrastructure/Report.Infrastructure.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <Protobuf Include="..\..\..\..\Shared\Contracts\Catalog.Contract\Protos\catalog.proto" GrpcServices="Client" />
  </ItemGroup>
  
  <ItemGroup>
    <PackageReference Include="Scrutor" />
    <PackageReference Include="MongoDB.Driver" />
    <PackageReference Include="Refit.HttpClientFactory" />
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="Google.Protobuf" />
    <PackageReference Include="Grpc.Net.Client" />
    <PackageReference Include="Grpc.Tools">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\Report.Application\Report.Application.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Search/Api/Search.Api/Constants/ApiRoutes.cs">
namespace Search.Api.Constants;

public sealed class ApiRoutes
{
    public static class Product
    {
        #region Constants

        public const string Tags = "Products";

        private const string Base = "products";

        public const string Search = $"/{Base}";

        #endregion
    }
}
</file>

<file path="Services/Search/Api/Search.Api/Endpoints/SearchProduct.cs">
#region using

using Common.Models;
using Search.Api.Constants;
using Search.Application.Features.Product.Queries;
using Search.Application.Models.Filters;
using Search.Application.Models.Results;
using Search.Domain.Enums;

#endregion

namespace Search.Api.Endpoints;

public sealed class SearchProduct : ICarterModule
{
    #region Implementations

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapGet(ApiRoutes.Product.Search, HandleSearchProductAsync)
            .WithTags(ApiRoutes.Product.Tags)
            .WithName(nameof(SearchProduct))
            .Produces<ApiGetResponse<SearchProductResult>>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest);
    }

    #endregion

    #region Methods

    private async Task<ApiGetResponse<SearchProductResult>> HandleSearchProductAsync(
        ISender sender,
        [AsParameters] PaginationRequest paging,
        string? searchText = null,
        string? categories = null,
        decimal? minPrice = null,
        decimal? maxPrice = null,
        ProductStatus? status = null,
        SortBy? sortBy = null,
        SortType? sortType = null)
    {
        var filter = new SearchTermsFilter(
            SearchText: searchText,
            Categories: categories ?? string.Empty,
            MinPrice: minPrice,
            MaxPrice: maxPrice,
            Status: status,
            SortBy: sortBy,
            SortType: sortType);

        var query = new SearchProductQuery(filter, paging);
        var result = await sender.Send(query);

        return new ApiGetResponse<SearchProductResult>(result);
    }

    #endregion
}
</file>

<file path="Services/Search/Api/Search.Api/DependencyInjection.cs">
#region using

using BuildingBlocks.Authentication.Extensions;
using BuildingBlocks.DistributedTracing;
using BuildingBlocks.Logging;
using BuildingBlocks.Swagger.Extensions;
using Common.Configurations;
using Common.Constants;
using HealthChecks.UI.Client;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Search.Infrastructure;

#endregion

namespace Search.Api;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddApiServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddDistributedTracing(cfg);
        services.AddSerilogLogging(cfg);
        services.AddCarter();

        // HealthChecks
        {
            var dbype = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DbType}"];
            var conn = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.Database}"];
            var dbName = cfg[$"{ConnectionStringsCfg.Section}:{ConnectionStringsCfg.DatabaseName}"];

            switch (dbype)
            {
                case DatabaseType.SqlServer:
                    services.AddHealthChecks()
                        .AddSqlServer(connectionString: conn!);
                    break;
                case DatabaseType.MySql:
                    services.AddHealthChecks()
                        .AddMySql(connectionString: conn!);
                    break;
                case DatabaseType.PostgreSql:
                    services.AddHealthChecks()
                        .AddNpgSql(connectionString: conn!);
                    break;
                case DatabaseType.MongoDb:
                    services.AddHealthChecks()
                        .AddMongoDb(
                            clientFactory: sp => new MongoDB.Driver.MongoClient(conn!),
                            databaseNameFactory: sp => dbName!);
                    break;
                default:
                    services.AddHealthChecks()
                        .AddCheck("datasource", () => HealthCheckResult.Healthy("ok"));
                    break;
            }
        }

        services.AddHttpContextAccessor();
        services.AddAuthenticationAndAuthorization(cfg);
        services.AddSwaggerServices(cfg);

        return services;
    }

    public static WebApplication UseApi(this WebApplication app)
    {
        app.UseInfrastructure();

        app.UseSerilogReqLogging();
        app.UsePrometheusEndpoint();
        app.MapCarter();
        app.UseExceptionHandler(options => { });
        app.UseHealthChecks("/health",
            new HealthCheckOptions
            {
                ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
            });

        app.UseAuthentication();
        app.UseAuthorization();
        app.UseSwaggerApi();

        app.MapGet("/", (IWebHostEnvironment env) => new ApiDefaultPathResponse
        {
            Service = "Search.Api",
            Status = "Running",
            Timestamp = DateTimeOffset.UtcNow,
            Environment = env.EnvironmentName,
            Endpoints = new Dictionary<string, string>
            {
                { "health", "/health" }
            },
            Message = "API is running..."
        });

        return app;
    }

    #endregion

}
</file>

<file path="Services/Search/Api/Search.Api/GlobalUsing.cs">
global using Carter;
global using MediatR;
global using Common.Models.Reponses;
</file>

<file path="Services/Search/Api/Search.Api/Program.cs">
#region using

using Search.Api;
using Search.Application;
using Search.Infrastructure;

#endregion

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddApiServices(builder.Configuration);

var app = builder.Build();

// Configure the HTTP request pipeline.
app.UseApi();
app.UseInfrastructure();

app.Run();
</file>

<file path="Services/Search/Api/Search.Api/Search.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <UserSecretsId>68beccec-977d-4711-a7f7-5d8d06e5c2e0</UserSecretsId>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="AspNetCore.HealthChecks.MongoDb" />
    <PackageReference Include="AspNetCore.HealthChecks.MySql" />
    <PackageReference Include="AspNetCore.HealthChecks.NpgSql" />
    <PackageReference Include="AspNetCore.HealthChecks.Redis" />
    <PackageReference Include="AspNetCore.HealthChecks.SqlServer" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" />
    <PackageReference Include="Carter" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Search.Application\Search.Application.csproj" />
    <ProjectReference Include="..\..\Core\Search.Infrastructure\Search.Infrastructure.csproj" />
  </ItemGroup>
  
  <ItemGroup>
    <Folder Include="Models\" />
  </ItemGroup>
  
</Project>
</file>

<file path="Services/Search/Core/Search.Application/Dtos/Abstractions/AuditableDto.cs">
namespace Search.Application.Dtos.Abstractions;

public abstract class AuditableDto : IAuditableDto
{
    #region Fields, Properties and Indexers

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}

public interface IAuditableDto : ICreationAuditDto, IModificationAuditDto { }
</file>

<file path="Services/Search/Core/Search.Application/Dtos/Abstractions/DtoId.cs">
namespace Search.Application.Dtos.Abstractions;

public class DtoId<T> : IDtoId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    #endregion
}

public interface IDtoId<T>
{
    T Id { get; init; }
}
</file>

<file path="Services/Search/Core/Search.Application/Dtos/Abstractions/EntityDto.cs">
namespace Search.Application.Dtos.Abstractions;

public abstract class EntityDto<T> : IDtoId<T>, IAuditableDto
{
    #region Fields, Properties and Indexers

    public T Id { get; init; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Application/Dtos/Abstractions/ICreationAuditDto.cs">
namespace Search.Application.Dtos.Abstractions;

public interface ICreationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Application/Dtos/Abstractions/IModificationAuditDto.cs">
namespace Search.Application.Dtos.Abstractions;

public interface IModificationAuditDto
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Search/Core/Search.Application/Dtos/Products/ProductDto.cs">
#region using

using Search.Application.Dtos.Abstractions;
using Search.Domain.Enums;

#endregion

namespace Search.Application.Dtos.Products;

public sealed class ProductDto : EntityDto<string>
{
    #region Fields, Properties and Indexers

    public string Name { get; set; } = default!;

    public string Sku { get; set; } = default!;

    public string Slug { get; set; } = default!;

    public decimal Price { get; set; }

    public decimal? SalePrice { get; set; }

    public List<string>? Categories { get; set; }

    public List<string>? Images { get; set; }

    public string Thumbnail { get; set; } = default!;

    public ProductStatus Status { get; set; }

    public string DisplayStatus { get; set; } = default!;

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Application/Dtos/Products/UpsertProductDto.cs">
#region using

using Search.Domain.Enums;

#endregion

namespace Search.Application.Dtos.Products;

public sealed class UpsertProductDto
{
    #region Fields, Properties and Indexers

    public string ProductId { get; set; } = default!;

    public string Name { get; set; } = default!;

    public string Sku { get; set; } = default!;

    public string Slug { get; set; } = default!;

    public decimal Price { get; set; }

    public decimal? SalePrice { get; set; }

    public List<string>? Categories { get; set; }

    public List<string>? Images { get; set; }

    public string Thumbnail { get; set; } = default!;

    public ProductStatus Status { get; set; }

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Application/Exceptions/ApplicationException.cs">
namespace Search.Application.Exceptions;

public sealed class ApplicationException : Exception
{
    #region Ctors

    public ApplicationException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Application/Features/Product/Commands/DeleteProductCommand.cs">
#region using

using Microsoft.Extensions.Logging;
using Search.Application.Repositories;

#endregion

namespace Search.Application.Features.Product.Commands;

public sealed record DeleteProductCommand(string ProductId) : ICommand<bool>;

public sealed class DeleteProductCommandHandler(
    IProductRepository productRepository,
    ILogger<DeleteProductCommandHandler> logger) : ICommandHandler<DeleteProductCommand, bool>
{
    #region Implementations

    public async Task<bool> Handle(DeleteProductCommand command, CancellationToken cancellationToken)
    {
        var result = await productRepository.DeleteAsync(command.ProductId, cancellationToken);

        if (result)
        {
            logger.LogInformation("Successfully deleted product {ProductId} from Elasticsearch", command.ProductId);
        }
        else
        {
            logger.LogWarning("Failed to delete product {ProductId} from Elasticsearch", command.ProductId);
        }

        return result;
    }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Application/Features/Product/Commands/UpsertProductCommand.cs">
#region using

using AutoMapper;
using Microsoft.Extensions.Logging;
using Search.Application.Dtos.Products;
using Search.Application.Repositories;
using Search.Domain.Entities;

#endregion

namespace Search.Application.Features.Product.Commands;

public sealed record UpsertProductCommand(UpsertProductDto Dto) : ICommand<bool>;

public sealed class UpsertProductCommandHandler(
    IProductRepository productRepository,
    IMapper mapper,
    ILogger<UpsertProductCommandHandler> logger) : ICommandHandler<UpsertProductCommand, bool>
{
    #region Implementations

    public async Task<bool> Handle(UpsertProductCommand command, CancellationToken cancellationToken)
    {
        var dto = command.Dto;

        // Map DTO to ProductEntity using AutoMapper
        var product = mapper.Map<ProductEntity>(dto);

        var result = await productRepository.UpsertAsync(product, cancellationToken);

        if (result)
        {
            logger.LogInformation("Successfully upserted product {ProductId} in Elasticsearch", dto.ProductId);
        }
        else
        {
            logger.LogWarning("Failed to upsert product {ProductId} in Elasticsearch", dto.ProductId);
        }

        return result;
    }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Application/Features/Product/Queries/SearchProductQuery.cs">
#region using

using AutoMapper;
using Search.Application.Dtos.Products;
using Search.Application.Models.Filters;
using Search.Application.Models.Results;
using Search.Application.Repositories;

#endregion

namespace Search.Application.Features.Product.Queries;

public sealed record SearchProductQuery(
    SearchTermsFilter Filter,
    PaginationRequest Paging) : IQuery<SearchProductResult>;

public sealed class SearchProductQueryHandler(
    IProductRepository productRepository,
    IMapper mapper) : IQueryHandler<SearchProductQuery, SearchProductResult>
{
    #region Implementations

    public async Task<SearchProductResult> Handle(SearchProductQuery query, CancellationToken cancellationToken)
    {
        var (products, totalCount) = await productRepository.SearchAsync(
            query.Filter,
            query.Paging,
            cancellationToken);

        var productDtos = mapper.Map<List<ProductDto>>(products);

        return new SearchProductResult(productDtos, totalCount, query.Paging);
    }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Application/Mappings/SearchMappingProfile.cs">
#region using

using AutoMapper;
using Search.Application.Dtos.Products;
using Search.Domain.Entities;

#endregion

namespace Search.Application.Mappings;

public sealed class SearchMappingProfile : Profile
{
    #region Ctors

    public SearchMappingProfile()
    {
        CreateEntityMappings();
    }

    #endregion

    #region Methods

    private void CreateEntityMappings()
    {
        // ProductEntity -> ProductDto
        CreateMap<ProductEntity, ProductDto>()
            .ForMember(dest => dest.DisplayStatus, opt => opt.MapFrom(src => src.Status.GetDescription()));

        // UpsertProductDto -> ProductEntity
        CreateMap<UpsertProductDto, ProductEntity>()
            .ForMember(dest => dest.Id, opt => opt.MapFrom(src => src.ProductId));
    }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Application/Models/Filters/SearchTermsFilter.cs">
#region using

using Search.Domain.Enums;

#endregion

namespace Search.Application.Models.Filters;

public record class SearchTermsFilter(
    string? SearchText,
    string Categories,
    decimal? MinPrice = null,
    decimal? MaxPrice = null,
    ProductStatus? Status = null,
    SortBy? SortBy = null,
    SortType? SortType = null);
</file>

<file path="Services/Search/Core/Search.Application/Models/Results/SearchProductResult.cs">
#region using

using Search.Application.Dtos.Products;

#endregion

namespace Search.Application.Models.Results;

public sealed class SearchProductResult
{
    #region Fields, Properties and Indexers

    public List<ProductDto> Products { get; init; }

    public PagingResult Paging { get; init; }

    #endregion

    #region Ctors

    public SearchProductResult(
        List<ProductDto> products,
        long totalCount,
        PaginationRequest pagination)
    {
        Products = products;
        Paging = PagingResult.Of(totalCount, pagination);
    }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Application/Repositories/IProductRepository.cs">
#region using

using Search.Application.Models.Filters;
using Search.Domain.Entities;

#endregion

namespace Search.Application.Repositories;

public interface IProductRepository
{
    #region Methods

    Task<(List<ProductEntity> Items, long TotalCount)> SearchAsync(
        SearchTermsFilter filter,
        PaginationRequest? paging = null,
        CancellationToken cancellationToken = default);

    Task<bool> UpsertAsync(ProductEntity product, CancellationToken cancellationToken = default);

    Task<bool> DeleteAsync(string productId, CancellationToken cancellationToken = default);

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Application/ApplicationMarker.cs">
namespace Search.Application;

public sealed class ApplicationMarker { }
</file>

<file path="Services/Search/Core/Search.Application/DependencyInjection.cs">
#region using

using BuildingBlocks.Behaviors;
using BuildingBlocks.Exceptions.Handler;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.FeatureManagement;
using System.Reflection;

#endregion

namespace Search.Application;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddApplicationServices(this IServiceCollection services)
    {
        services.AddExceptionHandler<CustomExceptionHandler>();
        services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
        services.AddMediatR(config =>
        {
            config.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
            config.AddOpenBehavior(typeof(ValidationBehavior<,>));
            config.AddOpenBehavior(typeof(LoggingBehavior<,>));
        });
        services.AddFeatureManagement();
        services.AddAutoMapper(Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Application/GlobalUsing.cs">
global using BuildingBlocks.CQRS;
global using FluentValidation;
global using Common.Extensions;
global using Common.Models;
global using BuildingBlocks.Pagination;
</file>

<file path="Services/Search/Core/Search.Application/Search.Application.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="AutoMapper" />
    <PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" />
    <PackageReference Include="Scrutor" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\BuildingBlocks\BuildingBlocks.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\Search.Domain\Search.Domain.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Features\Product\EventHandlers\Domain\" />
    <Folder Include="Models\Responses\" />
    <Folder Include="Services\" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Search/Core/Search.Domain/Abstractions/Aggregate.cs">
namespace Search.Domain.Abstractions;

public abstract class Aggregate<TId> : Entity<TId>, IAggregate<TId>
{
    #region Fields, Properties and Indexers

    private readonly List<IDomainEvent> _domainEvents = new();

    #endregion

    #region Implementations

    public IReadOnlyList<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    public void AddDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }

    public IDomainEvent[] ClearDomainEvents()
    {
        IDomainEvent[] dequeuedEvents = _domainEvents.ToArray();

        _domainEvents.Clear();

        return dequeuedEvents;
    }

    #endregion

}
</file>

<file path="Services/Search/Core/Search.Domain/Abstractions/Entity.cs">
namespace Search.Domain.Abstractions;

public abstract class Entity<T> : IEntityId<T>, IAuditable
{
    #region Fields, Properties and Indexers

    public T Id { get; set; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }

    public string? CreatedBy { get; set; }

    public DateTimeOffset? LastModifiedOnUtc { get; set; }

    public string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Search/Core/Search.Domain/Abstractions/EntityId.cs">
namespace Search.Domain.Abstractions;

public abstract class EntityId<T> : IEntityId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; set; } = default!;

    #endregion

}
</file>

<file path="Services/Search/Core/Search.Domain/Abstractions/IAggregate.cs">
namespace Search.Domain.Abstractions;

public interface IAggregate<T> : IAggregate, IEntityId<T>
{
}

public interface IAggregate : ICreationAuditable, IModificationAuditable
{
    #region Fields, Properties and Indexers

    IReadOnlyList<IDomainEvent> DomainEvents { get; }

    IDomainEvent[] ClearDomainEvents();

    #endregion

}
</file>

<file path="Services/Search/Core/Search.Domain/Abstractions/IAuditable.cs">
namespace Search.Domain.Abstractions;

public interface IAuditable : ICreationAuditable, IModificationAuditable { }
</file>

<file path="Services/Search/Core/Search.Domain/Abstractions/ICreationAuditable.cs">
namespace Search.Domain.Abstractions;

public interface ICreationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset CreatedOnUtc { get; set; }

    string? CreatedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Search/Core/Search.Domain/Abstractions/IDomainEvent.cs">
#region using

using MediatR;

#endregion

namespace Search.Domain.Abstractions;

public interface IDomainEvent : INotification
{
    #region Fields, Properties and Indexers

    Guid EventId => Guid.NewGuid();

    public DateTimeOffset OccurredOn => DateTime.Now;

    public string EventType => GetType()?.AssemblyQualifiedName ?? string.Empty;

    #endregion

}
</file>

<file path="Services/Search/Core/Search.Domain/Abstractions/IEntityId.cs">
namespace Search.Domain.Abstractions;

public interface IEntityId<T>
{
    #region Fields, Properties and Indexers

    public T Id { get; set; }

    #endregion

}
</file>

<file path="Services/Search/Core/Search.Domain/Abstractions/IModificationAuditable.cs">
namespace Search.Domain.Abstractions;

public interface IModificationAuditable
{
    #region Fields, Properties and Indexers

    DateTimeOffset? LastModifiedOnUtc { get; set; }

    string? LastModifiedBy { get; set; }

    #endregion

}
</file>

<file path="Services/Search/Core/Search.Domain/Entities/ProductEntity.cs">
#region using

using Search.Domain.Abstractions;
using Search.Domain.Enums;

#endregion

namespace Search.Domain.Entities;

public sealed class ProductEntity : Entity<string>
{
    #region Fields, Properties and Indexers

    public string Name { get; set; } = default!;

    public string Sku { get; set; } = default!;

    public string Slug { get; set; } = default!;

    public decimal Price { get; set; } = default!;

    public decimal? SalePrice { get; set; } = default!;

    public List<string>? Categories { get; set; } = default!;

    public List<string>? Images { get; set; } = default!;

    public string Thumbnail { get; set; } = default!;

    public ProductStatus Status { get; set; }

    #endregion

    #region Factories

    public static ProductEntity Create(string id,
        string name,
        string sku,
        string slug,
        decimal price,
        decimal? salePrice,
        List<string>? categories,
        string performedBy)
    {
        var product = new ProductEntity
        {
            Id = id,
            Name = name,
            Sku = sku,
            Slug = slug,
            Price = price,
            SalePrice = salePrice,
            Status = ProductStatus.OutOfStock,
            Categories = categories,
            CreatedOnUtc = DateTimeOffset.UtcNow,
            CreatedBy = performedBy
        };

        return product;
    }

    #endregion

    #region Methods

    public void Update(string name,
        string sku,
        string slug,
        decimal price,
        decimal? salePrice,
        ProductStatus status,
        List<string>? categories,
        string? performedBy)
    {
        Name = name;
        Sku = sku;
        Slug = slug;
        Price = price;
        SalePrice = salePrice;
        Categories = categories;
        Status = status;
        LastModifiedOnUtc = DateTimeOffset.UtcNow;
        LastModifiedBy = performedBy;
    }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Domain/Enums/ElasticIndex.cs">
#region using

using System.ComponentModel;

#endregion

namespace Search.Domain.Enums;

public enum ElasticIndex
{
    [Description("idx_products_tbl")]
    Products,
}
</file>

<file path="Services/Search/Core/Search.Domain/Enums/ProductStatus.cs">
#region using

using System.ComponentModel;

#endregion

namespace Search.Domain.Enums;

public enum ProductStatus
{
    [Description("In Stock")]
    InStock = 1,

    [Description("Out of Stock")]
    OutOfStock = 2
}
</file>

<file path="Services/Search/Core/Search.Domain/Enums/SortBy.cs">
namespace Search.Domain.Enums;

public enum SortBy
{
    Name = 1,
    Sku = 2,
    Price = 3,
    SalePrice = 4,
    Status = 5,
    CreatedOnUtc = 6
}
</file>

<file path="Services/Search/Core/Search.Domain/Enums/SortType.cs">
namespace Search.Domain.Enums;

public enum SortType
{
    Asc = 1,
    Desc = 2
}
</file>

<file path="Services/Search/Core/Search.Domain/Exceptions/DomainException.cs">
namespace Search.Domain.Exceptions;

public sealed class DomainException : Exception
{
    public DomainException(string message) : base(message)
    {
    }
}
</file>

<file path="Services/Search/Core/Search.Domain/GlobalUsing.cs">

</file>

<file path="Services/Search/Core/Search.Domain/Search.Domain.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="MediatR" />
    <PackageReference Include="Newtonsoft.Json" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Events\" />
    <Folder Include="ValueObjects\" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Search/Core/Search.Infrastructure/Data/ElasticSearchInitializer.cs">
#region using

using Nest;
using Polly;
using Search.Domain.Enums;

#endregion

namespace Search.Infrastructure.Data;

public sealed class ElasticSearchInitializer(IElasticClient elasticClient)
{
    public async Task InitializeAsync()
    {
        await CreateProductIndexAsync();
    }

    private async Task CreateProductIndexAsync()
    {
        var retryPolicy = Polly.Policy
            .Handle<Exception>()
            .WaitAndRetryAsync(5, i => TimeSpan.FromSeconds(5 * i));

        var circuitBreakerPolicy = Polly.Policy
            .Handle<Exception>()
            .CircuitBreakerAsync(2, TimeSpan.FromSeconds(30));

        var result = await retryPolicy
            .WrapAsync(circuitBreakerPolicy)
            .ExecuteAsync(async () =>
            {
                var indexName = ElasticIndex.Products.GetDescription();

                var indexExistsResponse = await elasticClient.Indices.ExistsAsync(indexName);

                if (indexExistsResponse.Exists) return true;

                var createIndexResponse = await elasticClient.Indices.CreateAsync(
                        indexName,
                        c => c.ConfigureProductMapping());

                return createIndexResponse.IsValid;
            });
    }
}
</file>

<file path="Services/Search/Core/Search.Infrastructure/Data/ElasticSearchProfileMapping.cs">
#region using

using Nest;
using Search.Domain.Entities;

#endregion

namespace Search.Infrastructure.Data;

public static class ElasticSearchProfileMapping
{
    public static CreateIndexDescriptor ConfigureProductMapping(this CreateIndexDescriptor descriptor)
    {
        return descriptor
                    .Settings(s => s
                        .Analysis(analysis => analysis
                            .Analyzers(analyzers => analyzers
                                .Standard("standard_analyzer", sa => sa
                                    .StopWords()
                                    .MaxTokenLength(255))
                                .Custom("custom_search_analyzer", c => c
                                    .Tokenizer("standard")
                                    .Filters("lowercase", "asciifolding")))))
                    .Map<ProductEntity>(m => m
                        .Properties(p => p
                            .Text(t => t
                                .Name(n => n.Name)
                                .Analyzer("custom_search_analyzer")
                                .Fields(f => f
                                    .Keyword(k => k
                                        .Name("keyword"))))
                            .Number(t => t
                                .Name(n => n.Price)
                                .Type(NumberType.Double))
                            .Number(t => t
                                .Name(n => n.SalePrice)
                                .Type(NumberType.Double))
                            .Text(t => t
                                .Name(n => n.Categories)
                                .Fields(f => f
                                    .Keyword(k => k
                                        .Name("keyword"))))
                            .Date(t => t
                                .Name(n => n.CreatedOnUtc))
                            .Keyword(t => t
                                .Name(n => n.CreatedBy))
                            .Date(t => t
                                .Name(n => n.LastModifiedOnUtc))
                            .Keyword(t => t
                                .Name(n => n.LastModifiedBy))

                            ));
    }
}
</file>

<file path="Services/Search/Core/Search.Infrastructure/Exceptions/InfrastructureException.cs">
namespace Search.Infrastructure.Exceptions;

public sealed class InfrastructureException : Exception
{
    #region Ctors

    public InfrastructureException(string message) : base(message)
    {
    }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Infrastructure/Repositories/ProductRepository.cs">
#region using

using Common.Models;
using Elasticsearch.Net;
using Nest;
using Search.Application.Models.Filters;
using Search.Application.Repositories;
using Search.Domain.Entities;
using Search.Domain.Enums;

#endregion

namespace Search.Infrastructure.Repositories;

public class ProductRepository(IElasticClient elasticClient) : IProductRepository
{

    #region Fields, Properties and Indexers

    private readonly string _index = ElasticIndex.Products.GetDescription();

    #endregion

    #region Implementations

    public async Task<bool> DeleteAsync(string productId, CancellationToken cancellationToken = default)
    {
        var result = await elasticClient.DeleteAsync<ProductEntity>(productId, i => i
            .Index(_index)
            .Refresh(Refresh.True));

        return result.IsValid && result.Result == Result.Deleted;
    }

    public async Task<(List<ProductEntity> Items, long TotalCount)> SearchAsync(
        SearchTermsFilter filter,
        PaginationRequest? paging = null,
        CancellationToken cancellationToken = default)
    {
        var searchDescriptor = new SearchDescriptor<ProductEntity>()
            .Index(_index)
            .Query(q => BuildQuery(q, filter));

        ApplySorting(searchDescriptor, filter);

        // Apply pagination if provided
        if (paging != null)
        {
            var pageNumber = paging.PageNumber <= 0 ? 1 : paging.PageNumber;
            var pageSize = paging.PageSize <= 0 ? 10 : paging.PageSize;
            var skip = (pageNumber - 1) * pageSize;

            searchDescriptor = searchDescriptor
                .From(skip)
                .Size(pageSize);
        }

        var searchResponse = await elasticClient.SearchAsync<ProductEntity>(searchDescriptor, cancellationToken);

        if (!searchResponse.IsValid) return ([], 0);

        var totalCount = searchResponse.Total;
        var items = searchResponse.Documents.ToList();

        return (items, totalCount);
    }

    public async Task<bool> UpsertAsync(ProductEntity product, CancellationToken cancellationToken = default)
    {
        var result = await elasticClient.IndexAsync(product, i => i
            .Index(_index)
            .Id(product.Id)
            .Refresh(Refresh.True));

        return result.IsValid && (result.Result == Result.Created || result.Result == Result.Updated);
    }

    #endregion

    #region Methods

    private static QueryContainer BuildQuery(QueryContainerDescriptor<ProductEntity> q, SearchTermsFilter filter)
    {
        var mustClauses = new List<QueryContainer>();

        // Search by text in Name field
        if (!filter.SearchText.IsNullOrWhiteSpace())
        {
            mustClauses.Add(q.Match(m => m
                .Field(f => f.Name)
                .Query(filter.SearchText!)
                .Fuzziness(Fuzziness.Auto)
                .Operator(Operator.Or)));
        }

        // Filter by categories
        if (!filter.Categories.IsNullOrWhiteSpace())
        {
            var categoryList = filter.Categories
                .Split(",", StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToList();

            if (categoryList.Any())
            {
                mustClauses.Add(q.Terms(t => t
                .Field(f => f.Categories.Suffix("keyword"))
                .Terms(categoryList)));
            }
        }

        // Filter by price range
        if (filter.MinPrice.HasValue || filter.MaxPrice.HasValue)
        {
            mustClauses.Add(q.Range(r =>
            {
                var range = r.Field(f => f.Price);

                if (filter.MinPrice.HasValue)
                {
                    range = range.GreaterThanOrEquals((double)filter.MinPrice.Value);
                }

                if (filter.MaxPrice.HasValue)
                {
                    range = range.LessThanOrEquals((double)filter.MaxPrice.Value);
                }

                return range;
            }));
        }

        // Filter by status
        if (filter.Status.HasValue)
        {
            mustClauses.Add(q.Term(t => t
                .Field(f => f.Status)
                .Value((int)filter.Status.Value)));
        }

        // If no filters, return all documents
        return !mustClauses.Any()
            ? q.MatchAll()
            : q.Bool(b => b.Must(mustClauses.ToArray()));
    }

    private static void ApplySorting(SearchDescriptor<ProductEntity> searchDescriptor, SearchTermsFilter filter)
    {
        if (!filter.SortBy.HasValue)
        {
            return;
        }

        var sortType = filter.SortType ?? Domain.Enums.SortType.Asc;

        Func<SortDescriptor<ProductEntity>, IPromise<IList<ISort>>> sortSelector = filter.SortBy.Value switch
        {
            Domain.Enums.SortBy.Name => sortType == Domain.Enums.SortType.Asc
                ? sort => sort.Ascending(p => p.Name.Suffix("keyword"))
                : sort => sort.Descending(p => p.Name.Suffix("keyword")),
            Domain.Enums.SortBy.Sku => sortType == Domain.Enums.SortType.Asc
                ? sort => sort.Ascending(p => p.Sku.Suffix("keyword"))
                : sort => sort.Descending(p => p.Sku.Suffix("keyword")),
            Domain.Enums.SortBy.Price => sortType == Domain.Enums.SortType.Asc
                ? sort => sort.Ascending(p => p.Price)
                : sort => sort.Descending(p => p.Price),
            Domain.Enums.SortBy.SalePrice => sortType == Domain.Enums.SortType.Asc
                ? sort => sort.Ascending(p => p.SalePrice)
                : sort => sort.Descending(p => p.SalePrice),
            Domain.Enums.SortBy.Status => sortType == Domain.Enums.SortType.Asc
                ? sort => sort.Ascending(p => p.Status)
                : sort => sort.Descending(p => p.Status),
            Domain.Enums.SortBy.CreatedOnUtc => sortType == Domain.Enums.SortType.Asc
                ? sort => sort.Ascending(p => p.CreatedOnUtc)
                : sort => sort.Descending(p => p.CreatedOnUtc),
            _ => sort => sort.Ascending(p => p.Name.Suffix("keyword"))
        };

        searchDescriptor.Sort(sortSelector);
    }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Infrastructure/DependencyInjection.cs">
#region using

using Elasticsearch.Net;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Nest;
using Search.Infrastructure.Data;

#endregion

namespace Search.Infrastructure;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddInfrastructureServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Service")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithScopedLifetime());

        services.Scan(s => s
            .FromAssemblyOf<InfrastructureMarker>()
            .AddClasses(c => c.Where(t => t.Name.EndsWith("Repository")))
            .UsingRegistrationStrategy(Scrutor.RegistrationStrategy.Skip)
            .AsImplementedInterfaces()
            .WithSingletonLifetime());


        var uri = cfg[$"{ElasticSearchCfg.Section}:{ElasticSearchCfg.Uri}"];
        var username = cfg[$"{ElasticSearchCfg.Section}:{ElasticSearchCfg.Username}"];
        var password = cfg[$"{ElasticSearchCfg.Section}:{ElasticSearchCfg.Password}"];

        Uri[] nodes = [new(uri!)];
        StaticConnectionPool connectionPool = new(nodes);
        ConnectionSettings? connectionSettings = new ConnectionSettings(connectionPool)
            .DisableDirectStreaming()
            .BasicAuthentication(username, password);
        connectionSettings.PrettyJson();
        ElasticClient elasticClient = new(connectionSettings);

        services.AddSingleton<IElasticClient>(elasticClient);
        services.AddTransient<ElasticSearchInitializer>();

        return services;
    }

    public static WebApplication UseInfrastructure(this WebApplication app)
    {
        // Initialize Elasticsearch indices on startup
        using var scope = app.Services.CreateScope();
        var initializer = scope.ServiceProvider.GetRequiredService<ElasticSearchInitializer>();
        var logger = scope.ServiceProvider.GetRequiredService<ILogger<ElasticSearchInitializer>>();

        try
        {
            logger.LogInformation("Initializing Elasticsearch indices...");
            initializer.InitializeAsync().GetAwaiter().GetResult();
            logger.LogInformation("Elasticsearch indices initialized successfully");
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error initializing Elasticsearch indices");
            throw;
        }

        return app;
    }

    #endregion
}
</file>

<file path="Services/Search/Core/Search.Infrastructure/GlobalUsing.cs">
global using Common.Configurations;
global using Common.Extensions;
</file>

<file path="Services/Search/Core/Search.Infrastructure/InfrastructureMarker.cs">
namespace Search.Infrastructure;

public sealed class InfrastructureMarker { }
</file>

<file path="Services/Search/Core/Search.Infrastructure/Search.Infrastructure.csproj">
<Project Sdk="Microsoft.NET.Sdk">
  
  <ItemGroup>
    <PackageReference Include="Elasticsearch.Net" />
    <PackageReference Include="NEST" />
    <PackageReference Include="Polly" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\Search.Application\Search.Application.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Constants\" />
    <Folder Include="Data\Extensions\" />
  </ItemGroup>

</Project>
</file>

<file path="Services/Search/Worker/Search.Worker.Consumer/BackgroundServices/SearchBackgroudService.cs">
namespace Search.Worker.Consumer.BackgroundServices;

public class SearchBackgroudService(ILogger<SearchBackgroudService> logger) : BackgroundService
{
    #region Methods

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        logger.LogInformation("Worker starting at: {time}", DateTimeOffset.Now);

        while (!stoppingToken.IsCancellationRequested)
        {
            await Task.Delay(1000, stoppingToken);
        }

        logger.LogInformation("Worker stoping at: {time}", DateTimeOffset.Now);
    }

    #endregion
}
</file>

<file path="Services/Search/Worker/Search.Worker.Consumer/EventHandlers/Integrations/DeletedUnPublishedProductIntegrationEventHandler.cs">
#region using

using EventSourcing.Events.Catalog;
using MassTransit;
using MediatR;
using Search.Application.Features.Product.Commands;

#endregion

namespace Search.Worker.Consumer.EventHandlers.Integrations;

public sealed class DeletedUnPublishedProductIntegrationEventHandler(
    ISender sender,
    ILogger<DeletedUnPublishedProductIntegrationEventHandler> logger)
    : IConsumer<DeletedUnPublishedProductIntegrationEvent>
{
    #region Methods

    public async Task Consume(ConsumeContext<DeletedUnPublishedProductIntegrationEvent> context)
    {
        logger.LogInformation("Integration Event handled: {IntegrationEvent}", context.Message.GetType().Name);

        var integrationEvent = context.Message;

        var command = new DeleteProductCommand(integrationEvent.ProductId.ToString());
        await sender.Send(command, context.CancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Search/Worker/Search.Worker.Consumer/EventHandlers/Integrations/UpsertedProductIntegrationEventHandler.cs">
#region using

using EventSourcing.Events.Catalog;
using MassTransit;
using MediatR;
using Search.Application.Features.Product.Commands;
using Search.Application.Dtos.Products;
using Search.Domain.Enums;

#endregion

namespace Search.Worker.Consumer.EventHandlers.Integrations;

public sealed class UpsertedProductIntegrationEventHandler(
    ISender sender,
    ILogger<UpsertedProductIntegrationEventHandler> logger)
    : IConsumer<UpsertedProductIntegrationEvent>
{
    #region Methods

    public async Task Consume(ConsumeContext<UpsertedProductIntegrationEvent> context)
    {
        logger.LogInformation("Integration Event handled: {IntegrationEvent}", context.Message.GetType().Name);

        var integrationEvent = context.Message;

        // Map integration event to DTO
        var dto = new UpsertProductDto
        {
            ProductId = integrationEvent.ProductId.ToString(),
            Name = integrationEvent.Name,
            Sku = integrationEvent.Sku,
            Slug = integrationEvent.Slug,
            Price = integrationEvent.Price,
            SalePrice = integrationEvent.SalePrice,
            Categories = integrationEvent.Categories,
            Images = integrationEvent.Images,
            Thumbnail = integrationEvent.Thumbnail,
            Status = (ProductStatus)integrationEvent.Status,
            CreatedOnUtc = integrationEvent.CreatedOnUtc,
            CreatedBy = integrationEvent.CreatedBy,
            LastModifiedOnUtc = integrationEvent.LastModifiedOnUtc,
            LastModifiedBy = integrationEvent.LastModifiedBy
        };

        var command = new UpsertProductCommand(dto);
        await sender.Send(command, context.CancellationToken);
    }

    #endregion
}
</file>

<file path="Services/Search/Worker/Search.Worker.Consumer/DependencyInjection.cs">
#region using

using BuildingBlocks.Logging;
using EventSourcing.MassTransit;
using System.Reflection;

#endregion

namespace Search.Worker.Consumer;

public static class DependencyInjection
{
    #region Methods

    public static IServiceCollection AddWorkerServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        services.AddSerilogLogging(cfg);
        services.AddMessageBroker(cfg, Assembly.GetExecutingAssembly());

        return services;
    }

    #endregion
}
</file>

<file path="Services/Search/Worker/Search.Worker.Consumer/Program.cs">
#region using

using Search.Application;
using Search.Infrastructure;
using Search.Worker.Consumer;
using Search.Worker.Consumer.BackgroundServices;

#endregion

var builder = Host.CreateApplicationBuilder(args);

builder.Services
    .AddApplicationServices()
    .AddInfrastructureServices(builder.Configuration)
    .AddWorkerServices(builder.Configuration)
    .AddHostedService<SearchBackgroudService>();

var host = builder.Build();
host.Run();
</file>

<file path="Services/Search/Worker/Search.Worker.Consumer/Search.Worker.Consumer.csproj">
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <PropertyGroup>
    <UserSecretsId>dotnet-Worker-90f825b9-6755-4208-b522-3eec123e375c</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Shared\EventSourcing\EventSourcing.csproj" />
    <ProjectReference Include="..\..\..\..\Shared\Common\Common.csproj" />
    <ProjectReference Include="..\..\Core\Search.Application\Search.Application.csproj" />
    <ProjectReference Include="..\..\Core\Search.Infrastructure\Search.Infrastructure.csproj" />
  </ItemGroup>
</Project>
</file>

<file path="Shared/BuildingBlocks/Authentication/Extensions/AuthorizationExtension.cs">
#region using

using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.IdentityModel.Tokens;
using Common.Configurations;
using Common.Constants;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text.Json;

namespace BuildingBlocks.Authentication.Extensions;

#endregion

public static class AuthenticationExtensions
{
    #region Methods

    public static IServiceCollection AddAuthenticationAndAuthorization(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        var authority = cfg[$"{AuthorizationCfg.Section}:{AuthorizationCfg.Authority}"];
        var clientId = cfg[$"{AuthorizationCfg.Section}:{AuthorizationCfg.ClientId}"];
        var audience = cfg[$"{AuthorizationCfg.Section}:{AuthorizationCfg.Audience}"];
        var requireHttps = cfg.GetValue<bool>($"{AuthorizationCfg.Section}:{AuthorizationCfg.RequireHttpsMetadata}");

        services.AddAuthentication(options =>
        {
            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
        })
        .AddJwtBearer(options =>
        {
            options.Authority = authority;
            options.Audience = audience;
            options.RequireHttpsMetadata = requireHttps;
            options.SaveToken = true;

            options.TokenValidationParameters = new TokenValidationParameters
            {
                ValidateIssuer = true,
                ValidateAudience = false,
                ValidateLifetime = true,
                ValidateIssuerSigningKey = true,

                ClockSkew = TimeSpan.FromSeconds(60),

                NameClaimType = JwtRegisteredClaimNames.Sub,
                RoleClaimType = ClaimTypes.Role
            };

            options.Events = new JwtBearerEvents
            {
                OnTokenValidated = ctx =>
                {
                    var id = ctx.Principal?.Identity as ClaimsIdentity;

                    if (id == null) return Task.CompletedTask;

                    var realmAccess = ctx.Principal!.FindFirst(CustomClaimTypes.RealmAccess)?.Value;
                    if (realmAccess != null)
                    {
                        using var doc = JsonDocument.Parse(realmAccess);
                        if (doc.RootElement.TryGetProperty(CustomClaimTypes.Roles, out var roles))
                        {
                            foreach (var r in roles.EnumerateArray())
                            {
                                var role = r.GetString();
                                if (!string.IsNullOrEmpty(role))
                                    id.AddClaim(new Claim(ClaimTypes.Role, role));
                            }
                        }
                    }

                    return Task.CompletedTask;
                }
            };
        });

        services.AddAuthorization();

        return services;
    }

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/Authentication/Extensions/UserContextExtension.cs">
#region using

using Common.Constants;
using Common.Models.Context;
using Microsoft.AspNetCore.Http;
using System.Security.Claims;

#endregion

namespace BuildingBlocks.Authentication.Extensions;

public static class UserContextExtension
{
    #region Methods

    public static UserContext GetCurrentUser(this IHttpContextAccessor context)
    {
        var identity = context.HttpContext?.User;
        var userId = identity?.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? string.Empty;
        var userName = identity?.FindFirst(CustomClaimTypes.UserName)?.Value ?? string.Empty;
        var firstName = identity?.FindFirst(ClaimTypes.GivenName)?.Value ?? string.Empty;
        var lastName = identity?.FindFirst(ClaimTypes.Surname)?.Value ?? string.Empty;
        var email = identity?.FindFirst(ClaimTypes.Email)?.Value ?? string.Empty;
        var tenant = identity?.FindFirst(CustomClaimTypes.Tenant)?.Value ?? string.Empty;
        var roles = identity?.FindAll(ClaimTypes.Role).Select(c => c.Value).ToList() ?? [];
        bool.TryParse(identity?.FindFirst(CustomClaimTypes.EmailVerified)?.Value, out bool emailVerified);

        return new UserContext()
        {
            EmailVerified = emailVerified,
            FirstName = firstName,
            LastName = lastName,
            Email = email,
            Id = userId,
            UserName = userName,
            Tenant = tenant,
            Roles = roles
        };
    }

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/Behaviors/LoggingBehavior.cs">
#region using

using MediatR;
using Microsoft.Extensions.Logging;
using System.Diagnostics;

#endregion

namespace BuildingBlocks.Behaviors;

public sealed class LoggingBehavior<TRequest, TResponse>
    (ILogger<LoggingBehavior<TRequest, TResponse>> logger)
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : notnull, IRequest<TResponse>
    where TResponse : notnull
{
    #region Implementations

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        logger.LogInformation("[START] Handle request={Request} - Response={Response} - RequestData={RequestData}",
            typeof(TRequest).Name, typeof(TResponse).Name, request);

        var timer = new Stopwatch();
        timer.Start();

        var response = await next();

        timer.Stop();
        var timeTaken = timer.Elapsed;
        if (timeTaken.Seconds > 3) // if the request is greater than 3 seconds, then log the warnings
            logger.LogWarning("[PERFORMANCE] The request {Request} took {TimeTaken} seconds.",
                typeof(TRequest).Name, timeTaken.Seconds);

        logger.LogInformation("[END] Handled {Request} with {Response}", typeof(TRequest).Name, typeof(TResponse).Name);
        return response;
    }

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/Behaviors/ValidationBehavior.cs">
#region using

using BuildingBlocks.CQRS;
using FluentValidation;
using MediatR;

#endregion

namespace BuildingBlocks.Behaviors;

public sealed class ValidationBehavior<TRequest, TResponse>
    (IEnumerable<IValidator<TRequest>> validators)
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : ICommand<TResponse>
{
    #region Implementations

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        var context = new ValidationContext<TRequest>(request);

        var validationResults =
            await Task.WhenAll(validators.Select(v => v.ValidateAsync(context, cancellationToken)));

        var failures =
            validationResults
            .Where(r => r.Errors.Any())
            .SelectMany(r => r.Errors)
            .ToList();

        if (failures.Any()) throw new ValidationException(failures);

        return await next();
    }

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/CQRS/ICommand.cs">
#region using

using MediatR;

#endregion

namespace BuildingBlocks.CQRS;

public interface ICommand : ICommand<Unit>
{
}

public interface ICommand<out TResponse> : IRequest<TResponse>
{
}
</file>

<file path="Shared/BuildingBlocks/CQRS/ICommandHandler.cs">
#region using

using MediatR;

#endregion

namespace BuildingBlocks.CQRS;

public interface ICommandHandler<in TCommand>
    : ICommandHandler<TCommand, Unit>
    where TCommand : ICommand<Unit>
{
}

public interface ICommandHandler<in TCommand, TResponse>
    : IRequestHandler<TCommand, TResponse>
    where TCommand : ICommand<TResponse>
    where TResponse : notnull
{
}
</file>

<file path="Shared/BuildingBlocks/CQRS/IQuery.cs">
#region using

using MediatR;

#endregion

namespace BuildingBlocks.CQRS;

public interface IQuery<out TResponse> : IRequest<TResponse>
    where TResponse : notnull
{
}
</file>

<file path="Shared/BuildingBlocks/CQRS/IQueryHandler.cs">
#region using

using MediatR;

#endregion

namespace BuildingBlocks.CQRS;

public interface IQueryHandler<in TQuery, TResponse>
    : IRequestHandler<TQuery, TResponse>
    where TQuery : IQuery<TResponse>
    where TResponse : notnull
{
}
</file>

<file path="Shared/BuildingBlocks/DistributedTracing/DistributedTracingExtension.cs">
#region using

using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using OpenTelemetry.Exporter;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using Common.Configurations;
using System.Diagnostics;
using Json.Formater;

#endregion

namespace BuildingBlocks.DistributedTracing;

public static class DistributedTracingExtension
{
    #region Methods

    public static IServiceCollection AddDistributedTracing(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        var enable = cfg.GetValue($"{DistributedTracingCfg.Section}:{DistributedTracingCfg.Enable}", false);
        if (!enable) return services;

        var otlpEndpoint = cfg[$"{DistributedTracingCfg.Section}:{DistributedTracingCfg.Otlp}:{DistributedTracingCfg.Endpoint}"];

        services.AddOpenTelemetry()
            .ConfigureResource(r => r
                .AddService(
                    serviceName: cfg[$"{DistributedTracingCfg.Section}:{DistributedTracingCfg.ServiceName}"]!,
                    serviceNamespace: $"namespace-{cfg[$"{DistributedTracingCfg.Section}:{DistributedTracingCfg.ServiceName}"]}",
                    serviceInstanceId: $"{cfg[$"{DistributedTracingCfg.Section}:{DistributedTracingCfg.ServiceName}"]}-{Environment.MachineName}-{Process.GetCurrentProcess().Id}")
                .AddEnvironmentVariableDetector()
                .AddAttributes(new Dictionary<string, object>
                {
                    ["deployment.environment"] = cfg["ASPNETCORE_ENVIRONMENT"] ?? "Production",
                    ["host.name"] = Environment.MachineName.Format()
                }))
            .WithTracing(tracingBuilder =>
            {
                tracingBuilder
                    .SetSampler(new TraceIdRatioBasedSampler(
                        cfg.GetValue<double>($"{DistributedTracingCfg.Section}:{DistributedTracingCfg.SamplingRate}")))
                    .AddHttpClientInstrumentation(opts =>
                    {
                        opts.RecordException = true;
                        opts.EnrichWithException = (activity, exception) =>
                        {
                            activity.SetTag("exception.type", exception.GetType().FullName.Format());
                            activity.SetTag("exception.message", exception.Message);
                        };
                    })
                    .AddAspNetCoreInstrumentation(opts =>
                    {
                        opts.RecordException = true;
                        opts.Filter = ctx =>
                        {
                            var p = ctx.Request.Path.Value ?? "";
                            if (p.StartsWith("/health")) return false;
                            if (p.StartsWith("/metrics")) return false;
                            if (p.StartsWith("/favicon")) return false;
                            return true;
                        };
                    })
                    .AddHttpClientInstrumentation(o => o.RecordException = true)
                    .AddSource(cfg[$"{DistributedTracingCfg.Section}:{DistributedTracingCfg.Source}"]!);

                tracingBuilder.AddOtlpExporter(opt =>
                {
                    opt.Endpoint = new Uri(otlpEndpoint!);
                    opt.Protocol = OtlpExportProtocol.Grpc;
                    opt.TimeoutMilliseconds = cfg.GetValue($"{DistributedTracingCfg.Section}:{DistributedTracingCfg.Otlp}:{DistributedTracingCfg.TimeoutMs}", 10000);
                });
            })
            .WithMetrics(metricsBuilder =>
            {
                metricsBuilder
                    .AddRuntimeInstrumentation()
                    //.AddProcessInstrumentation()
                    .AddAspNetCoreInstrumentation()
                    .AddHttpClientInstrumentation()
                    .AddView("http.server.duration", new ExplicitBucketHistogramConfiguration
                    {
                        Boundaries = new double[] { 1, 2, 5, 10, 25, 50, 100, 250, 500, 1000, 2500, 5000, 10000 }
                    })
                    .AddView("http.client.duration", new ExplicitBucketHistogramConfiguration
                    {
                        Boundaries = new double[] { 1, 5, 10, 20, 50, 100, 250, 500, 1000, 2500, 5000 }
                    })
                    .AddOtlpExporter(o =>
                    {
                        o.Protocol = OtlpExportProtocol.Grpc;
                        o.Endpoint = new Uri(otlpEndpoint!);
                    });

                if (cfg.GetValue($"{DistributedTracingCfg.Section}:{DistributedTracingCfg.Prometheus}:{DistributedTracingCfg.Enable}", false))
                {
                    metricsBuilder.AddPrometheusExporter();
                }
            });

        return services;
    }

    public static WebApplication UsePrometheusEndpoint(this WebApplication app)
    {
        var cfg = app.Configuration;
        var enable = cfg.GetValue($"{DistributedTracingCfg.Section}:{DistributedTracingCfg.Enable}", false);

        if (!enable) return app;

        var enablePrometheus = cfg.GetValue($"{DistributedTracingCfg.Section}:{DistributedTracingCfg.Prometheus}:{DistributedTracingCfg.Enable}", false);

        if (enablePrometheus)
        {
            app.MapPrometheusScrapingEndpoint();
        }

        return app;
    }

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/Exceptions/Handler/CustomExceptionHandler.cs">
#region using

using FluentValidation;
using Microsoft.AspNetCore.Diagnostics;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Common.Configurations;
using Common.Constants;
using Common.Models;
using Common.Models.Reponses;

#endregion

namespace BuildingBlocks.Exceptions.Handler;

public sealed class CustomExceptionHandler(
    ILogger<CustomExceptionHandler> logger,
    IConfiguration cfg) : IExceptionHandler
{
    #region Implementations

    public async ValueTask<bool> TryHandleAsync(
        HttpContext context,
        Exception exception,
        CancellationToken cancellationToken)
    {
        var includeInnerEx = cfg.GetValue<bool>($"{AppConfigCfg.Section}:{AppConfigCfg.IncludeInnerException}");
        var includeStackTrace = cfg.GetValue<bool>($"{AppConfigCfg.Section}:{AppConfigCfg.IncludeExceptionStackTrace}");

        (string ErrorMessage, int StatusCode, string? Details, string InnerException) details = exception switch
        {
            ValidationException =>
            (
                exception.Message,
                context.Response.StatusCode = StatusCodes.Status400BadRequest,
                MessageCode.BadRequest,
                includeInnerEx ? exception.GetType().Name : string.Empty
            ),
            ClientValidationException =>
            (
                exception.Message,
                context.Response.StatusCode = StatusCodes.Status400BadRequest,
                MessageCode.BadRequest,
                includeInnerEx ? exception.GetType().Name : string.Empty
            ),
            NotFoundException =>
            (
                exception.Message,
                context.Response.StatusCode = StatusCodes.Status404NotFound,
                MessageCode.NotFound,
                includeInnerEx ? exception.GetType().Name : string.Empty
            ),
            UnauthorizedException =>
            (
                exception.Message,
                context.Response.StatusCode = StatusCodes.Status401Unauthorized,
                MessageCode.Unauthorized,
                includeInnerEx ? exception.GetType().Name : string.Empty
            ),
            NoPermissionException =>
            (
                exception.Message,
                context.Response.StatusCode = StatusCodes.Status401Unauthorized,
                MessageCode.AccessDenied,
                includeInnerEx ? exception.GetType().Name : string.Empty
            ),
            _ =>
            (
                includeInnerEx ? exception.Message : MessageCode.UnknownError,
                context.Response.StatusCode = StatusCodes.Status500InternalServerError,
                includeStackTrace ? exception.StackTrace : null,
                includeInnerEx ? exception.InnerException?.Message ?? string.Empty : string.Empty
            )
        };

        var errors = new List<ErrorResult>();

        if (exception is FluentValidation.ValidationException validationException)
        {
            foreach (var error in validationException.Errors)
            {
                errors.Add(new ErrorResult(error.ErrorMessage, error.PropertyName));
            }
        }
        else if (exception is ClientValidationException badRequestException)
        {
            errors.Add(new ErrorResult(badRequestException.Message, badRequestException.Details!));
        }
        else if (exception is NotFoundException notFoundException)
        {
            errors.Add(new ErrorResult(notFoundException.Message, notFoundException.Details!));
        }
        else
        {
            errors.Add(new ErrorResult(details.ErrorMessage, details.InnerException));
        }

        var response = ResultSharedResponse<object>.Failure(
            statusCode: details.StatusCode,
            instance: context.Request.Path,
            errors: errors,
            message: details.Details);

        if (details.StatusCode == StatusCodes.Status500InternalServerError)
        {
            logger.LogError("Error Message: {exceptionMessage}, Time of occurrence {time}", exception.Message, DateTime.UtcNow);
        }
        else
        {
            logger.LogWarning("Message: {exceptionMessage}, Time of occurrence {time}", exception.Message, DateTime.UtcNow);
        }

        await context.Response.WriteAsJsonAsync(response, cancellationToken: cancellationToken);

        return true;
    }

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/Exceptions/ClientValidationException.cs">
namespace BuildingBlocks.Exceptions;

public sealed class ClientValidationException : Exception
{
    #region Fields, Properties and Indexers

    public object? Details { get; }

    #endregion

    #region Ctors

    public ClientValidationException(string message) : base(message)
    {
    }

    public ClientValidationException(string message, object? details) : base(message)
    {
        Details = details;
    }

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/Exceptions/InternalServerException.cs">
namespace BuildingBlocks.Exceptions;

public sealed class InternalServerException : Exception
{
    #region Fields, Properties and Indexers

    public object? Details { get; }

    #endregion

    #region Ctors

    public InternalServerException(string message) : base(message)
    {
    }

    public InternalServerException(string message, object? details) : base(message)
    {
        Details = details;
    }

    #endregion

}
</file>

<file path="Shared/BuildingBlocks/Exceptions/NoPermissionException.cs">
namespace BuildingBlocks.Exceptions;

public sealed class NoPermissionException : Exception
{
    #region Fields, Properties and Indexers

    public object? Details { get; }

    #endregion

    #region Ctors

    public NoPermissionException(string message) : base(message)
    {
    }

    public NoPermissionException(string message, object? details) : base(message)
    {
        Details = details;
    }

    #endregion

}
</file>

<file path="Shared/BuildingBlocks/Exceptions/NotFoundException.cs">
namespace BuildingBlocks.Exceptions;

public sealed class NotFoundException : Exception
{
    #region Fields, Properties and Indexers

    public object? Details { get; }

    #endregion

    #region Ctors

    public NotFoundException(string message) : base(message)
    {
    }

    public NotFoundException(string message, object? details) : base(message)
    {
        Details = details;
    }

    #endregion

}
</file>

<file path="Shared/BuildingBlocks/Exceptions/UnauthorizedException.cs">
namespace BuildingBlocks.Exceptions;

public sealed class UnauthorizedException : Exception
{
    #region Fields, Properties and Indexers

    public object? Details { get; }

    #endregion

    #region Ctors

    public UnauthorizedException(string message) : base(message)
    {
    }

    public UnauthorizedException(string message, object? details) : base(message)
    {
        Details = details;
    }

    #endregion

}
</file>

<file path="Shared/BuildingBlocks/Logging/ActivityTraceEnricher.cs">
#region using

using System.Diagnostics;

#endregion

namespace BuildingBlocks.Logging;

public sealed class ActivityTraceEnricher : Serilog.Core.ILogEventEnricher
{
    #region Methods

    public void Enrich(Serilog.Events.LogEvent logEvent, Serilog.Core.ILogEventPropertyFactory pf)
    {
        var act = Activity.Current;
        if (act is null) return;

        logEvent.AddPropertyIfAbsent(pf.CreateProperty("trace_id", act.TraceId.ToString()));
        logEvent.AddPropertyIfAbsent(pf.CreateProperty("span_id", act.SpanId.ToString()));
    }

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/Logging/SerilogLoggingExtensions.cs">
#region using

using Common.Configurations;
using Json.Formater;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Serilog;
using Serilog.Core;
using Serilog.Events;
using Serilog.Formatting.Compact;
using Serilog.Sinks.OpenTelemetry;
using System.Diagnostics;

#endregion

namespace BuildingBlocks.Logging;

public static class SerilogLoggingExtensions
{
    #region Methods

    public static IServiceCollection AddSerilogLogging(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        var section = SerilogCfg.Section;
        var enable = cfg.GetValue($"{section}:{SerilogCfg.Enable}", false);
        if (!enable) return services;

        var serviceName = cfg[$"{section}:{SerilogCfg.ServiceName}"] ?? AppDomain.CurrentDomain.FriendlyName;
        var env = cfg["ASPNETCORE_ENVIRONMENT"] ?? "Production";
        var lvlDefault = ParseLevel(cfg[$"{section}:{SerilogCfg.MinimumLevel}:{SerilogCfg.Default}"] ?? "Information");
        var lvlMicrosoft = ParseLevel(cfg[$"{section}:{SerilogCfg.MinimumLevel}:{SerilogCfg.Override}:{SerilogCfg.Microsoft}"] ?? "Warning");
        var lvlSystem = ParseLevel(cfg[$"{section}:{SerilogCfg.MinimumLevel}:{SerilogCfg.Override}:{SerilogCfg.System}"] ?? "Warning");
        var consoleEnable = cfg.GetValue($"{section}:{SerilogCfg.Console}:{SerilogCfg.Enable}", true);
        var consoleLevel = ParseLevel(cfg[$"{section}:{SerilogCfg.Console}:{SerilogCfg.Level}"] ?? "Information");
        var otlpEndpoint = cfg[$"{section}:{SerilogCfg.Otlp}:{SerilogCfg.Endpoint}"];
        var levelSwitch = new LoggingLevelSwitch(lvlDefault);
        var loggerCfg = new LoggerConfiguration()
            .MinimumLevel.ControlledBy(levelSwitch)
            .MinimumLevel.Override("Microsoft", lvlMicrosoft)
            .MinimumLevel.Override("System", lvlSystem)
            .Enrich.FromLogContext()
            .Enrich.WithProperty("service.name", serviceName)
            .Enrich.WithProperty("service.version", "1.0.0")
            .Enrich.WithProperty("deployment.environment", env)
            .Enrich.WithProperty("host.name", Environment.MachineName)
            .Enrich.WithProperty("process.id", Environment.ProcessId)
            .Enrich.WithProperty("process.name", Process.GetCurrentProcess().ProcessName)
            .Enrich.WithProperty("app.domain", AppDomain.CurrentDomain.FriendlyName)
            .Enrich.WithProperty("runtime.version", Environment.Version.ToString())
            .Enrich.WithProperty("user.name", Environment.UserName)
            .Enrich.WithProperty("os.platform", Environment.OSVersion.Platform.ToString())
            
            .Enrich.With<ActivityTraceEnricher>();

        if (consoleEnable)
        {
            loggerCfg = loggerCfg.WriteTo.Console(
                new CompactJsonFormatter(),
                restrictedToMinimumLevel: consoleLevel);
        }

        loggerCfg = loggerCfg.WriteTo.OpenTelemetry(o =>
        {
            o.Endpoint = otlpEndpoint;
            o.Protocol = OtlpProtocol.Grpc;
            o.ResourceAttributes = new Dictionary<string, object>
            {
                ["service.name"] = serviceName,
                ["deployment.environment"] = env
            };
        });

        #region Clear Empty
        loggerCfg.Enrich.WithProperty(string.Empty.Format(), string.Empty.BeautyFormat());
        #endregion

        Log.Logger = loggerCfg.CreateLogger();

        services.AddSerilog(logger: Log.Logger, dispose: true);

        if (cfg.GetValue($"{section}:EnableSelfLog", false))
        {
            Serilog.Debugging.SelfLog.Enable(msg => Console.Error.WriteLine(msg));
        }

        return services;
    }

    public static WebApplication UseSerilogReqLogging(this WebApplication app)
    {
        var section = SerilogCfg.Section;
        var enable = app.Configuration.GetValue($"{section}:{SerilogCfg.Enable}", false);
        if (!enable) return app;

        app.UseSerilogRequestLogging(options =>
        {
            options.GetLevel = (httpCtx, elapsed, ex) =>
            {
                var path = httpCtx.Request.Path.Value ?? "";
                if (path.StartsWith("/health", StringComparison.OrdinalIgnoreCase)) return LogEventLevel.Debug;
                if (path.StartsWith("/metrics", StringComparison.OrdinalIgnoreCase)) return LogEventLevel.Debug;
                if (path.StartsWith("/swagger", StringComparison.OrdinalIgnoreCase)) return LogEventLevel.Debug;
                if (ex != null || httpCtx.Response.StatusCode >= 500) return LogEventLevel.Error;

                return LogEventLevel.Information;
            };
            options.EnrichDiagnosticContext = (diag, ctx) =>
            {
                diag.Set("RequestHost", ctx.Request.Host.ToString());
                diag.Set("UserAgent", ctx.Request.Headers.UserAgent.ToString());
                diag.Set("ClientIP", ctx.Connection.RemoteIpAddress?.ToString());
                diag.Set("Route", ctx.GetEndpoint()?.DisplayName);
            };
            options.MessageTemplate = "HTTP {RequestMethod} {RequestPath} -> {StatusCode} in {Elapsed:0.0000} ms"
            .BeautyFormat();
            options.IncludeQueryInRequestPath = false;
        });

        app.Lifetime.ApplicationStopped.Register(Log.CloseAndFlush);

        return app;
    }

    private static LogEventLevel ParseLevel(string s) =>
        Enum.TryParse<LogEventLevel>(s, true, out var lvl) ? lvl : LogEventLevel.Information;

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/Pagination/Extensions/PagingExtensions.cs">
#region using

using Common.Models;
using MongoDB.Driver;

#endregion

namespace BuildingBlocks.Pagination.Extensions;

public static class PagingExtensions
{
    #region Methods

    public static IFindFluent<TDocument, TProjection> WithPaging<TDocument, TProjection>(
        this IFindFluent<TDocument, TProjection> fluent,
        PaginationRequest paging)
    {
        if (fluent is null) throw new ArgumentNullException(nameof(fluent));
        if (paging is null) throw new ArgumentNullException(nameof(paging));

        var (pageNumber, pageSize, skip) = Normalize(paging);
        return fluent.Skip(skip).Limit(pageSize);
    }

    public static IQueryable<T> WithPaging<T>(
        this IQueryable<T> query,
        PaginationRequest paging)
    {
        if (query is null) throw new ArgumentNullException(nameof(query));
        if (paging is null) throw new ArgumentNullException(nameof(paging));

        var (pageNumber, pageSize, skip) = Normalize(paging);
        return query.Skip(skip).Take(pageSize);
    }

    public static int GetTotalPages(this PaginationRequest paging, long totalCount)
    {
        if (paging.PageSize <= 0) throw new ArgumentOutOfRangeException(nameof(paging.PageSize), "Page size must be greater than zero.");
        return (int)Math.Ceiling(totalCount / (double)paging.PageSize);
    }

    private static (int pageNumber, int pageSize, int skip) Normalize(PaginationRequest paging)
    {
        var pageNumber = paging.PageNumber <= 0 ? 1 : paging.PageNumber;
        var pageSize = paging.PageSize <= 0 ? 10 : paging.PageSize;

        checked
        {
            var skip = (pageNumber - 1) * pageSize;
            return (pageNumber, pageSize, skip);
        }
    }

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/Pagination/PaginatedResult.cs">
namespace BuildingBlocks.Pagination;

public sealed class PaginatedResult<T>(
    int pageNumber,
    int pageSize,
    long count,
    IEnumerable<T> items,
    bool hasItem = false) where T : class
{
    #region Fields, Properties and Indexers

    public IEnumerable<T> Items { get; } = items;

    public int PageNumber { get; } = pageNumber;

    public int PageSize { get; } = pageSize;

    public long Count { get; } = count;

    public bool HasItem { get; } = hasItem;

    #endregion

}
</file>

<file path="Shared/BuildingBlocks/Pagination/PagingResult.cs">
#region using

using BuildingBlocks.Pagination.Extensions;
using Common.Models;

#endregion

namespace BuildingBlocks.Pagination;

public sealed class PagingResult
{
    #region Fields, Properties and Indexers

    public long TotalCount { get; private set; }

    public int PageNumber { get; private set; }

    public int PageSize { get; private set; }

    public bool HasItem { get; private set; }

    public int TotalPages { get; private set; }

    public bool HasNextPage { get; private set; }

    public bool HasPreviousPage { get; private set; }

    #endregion

    #region Ctors

    private PagingResult(long totalCount, PaginationRequest pagination)
    {
        TotalCount = totalCount;
        PageNumber = pagination.PageNumber;
        PageSize = pagination.PageSize;
        HasItem = totalCount > 0;
    }

    #endregion

    #region Methods

    public static PagingResult Of(long totalCount, PaginationRequest pagination)
    {
        var result = new PagingResult(totalCount, pagination);
        if (pagination.PageSize > 0)
        {
            result.TotalPages = pagination.GetTotalPages(totalCount);
            result.HasNextPage = pagination.PageNumber < result.TotalPages;
            result.HasPreviousPage = pagination.PageNumber > 1 && pagination.PageNumber <= result.TotalPages;
        }
        return result;
    }

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/Swagger/Extensions/FormOpenApiExtensions.cs">
#region using
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.OpenApi.Models;
#endregion

namespace BuildingBlocks.Swagger.Extensions;

public static class FormOpenApiExtensions
{
    public static RouteHandlerBuilder WithMultipartForm<T>(
        this RouteHandlerBuilder builder,
        string[]? required = null) where T : class
    {
        return builder.Accepts<T>("multipart/form-data")
            .WithOpenApi(op =>
            {
                var schema = new OpenApiSchema
                {
                    Type = "object",
                    Properties = new Dictionary<string, OpenApiSchema>()
                };
                var media = new OpenApiMediaType { Schema = schema };

                foreach (var p in typeof(T).GetProperties())
                {
                    var name = char.ToLowerInvariant(p.Name[0]) + p.Name[1..];
                    var t = p.PropertyType;
                    var u = Nullable.GetUnderlyingType(t) ?? t;
                    if (typeof(IFormFile).IsAssignableFrom(u))
                    {
                        schema.Properties[name] = new OpenApiSchema { Type = "string", Format = "binary" };
                        continue;
                    }

                    if (typeof(IEnumerable<IFormFile>).IsAssignableFrom(u) && u != typeof(string))
                    {
                        schema.Properties[name] = new OpenApiSchema
                        {
                            Type = "array",
                            Items = new OpenApiSchema { Type = "string", Format = "binary" }
                        };
                        continue;
                    }

                    if (typeof(System.Collections.IEnumerable).IsAssignableFrom(u) && u != typeof(string))
                    {
                        var elemType = u.IsArray ? u.GetElementType()! :
                                       u.GenericTypeArguments.FirstOrDefault() ?? typeof(string);

                        schema.Properties[name] = new OpenApiSchema
                        {
                            Type = "array",
                            Items = MapPrimitive(elemType)
                        };

                        media.Encoding[name] = new OpenApiEncoding
                        {
                            Style = ParameterStyle.Form,
                            Explode = true
                        };
                        continue;
                    }

                    var s = MapPrimitive(u);
                    s.Nullable = (Nullable.GetUnderlyingType(t) != null);
                    schema.Properties[name] = s;
                }

                if (required != null)
                    foreach (var r in required) schema.Required.Add(r);

                op.RequestBody = new OpenApiRequestBody
                {
                    Required = true,
                    Content = { ["multipart/form-data"] = media }
                };

                return op;
            });
    }

    private static OpenApiSchema MapPrimitive(Type t)
    {
        if (t == typeof(string)) return new() { Type = "string" };
        if (t == typeof(bool)) return new() { Type = "boolean" };
        if (t == typeof(int)) return new() { Type = "integer", Format = "int32" };
        if (t == typeof(long)) return new() { Type = "integer", Format = "int64" };
        if (t == typeof(float) || t == typeof(double) || t == typeof(decimal)) return new() { Type = "number" };
        if (t == typeof(DateTime) || t == typeof(DateTimeOffset)) return new() { Type = "string", Format = "date-time" };
        return new() { Type = "string" };
    }
}
</file>

<file path="Shared/BuildingBlocks/Swagger/Extensions/SwaggerGenExtension.cs">
#region using

using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.OpenApi.Models;
using Common.Configurations;

#endregion

namespace BuildingBlocks.Swagger.Extensions;

public static class SwaggerGenExtension
{
    #region Methods

    public static IServiceCollection AddSwaggerServices(
        this IServiceCollection services,
        IConfiguration cfg)
    {
        var authority = cfg[$"{AuthorizationCfg.Section}:{AuthorizationCfg.Authority}"];
        var clientId = cfg[$"{AuthorizationCfg.Section}:{AuthorizationCfg.ClientId}"];
        var clientSecret = cfg[$"{AuthorizationCfg.Section}:{AuthorizationCfg.ClientSecret}"];
        var scopesArray = cfg.GetValue<string[]>($"{AuthorizationCfg.Section}:{AuthorizationCfg.Scopes}");
        var oauthScopes = scopesArray?.ToDictionary(s => s, s => $"OpenID scope {s}");
        var authUrl = new Uri($"{authority}/protocol/openid-connect/auth");
        var tokenUrl = new Uri($"{authority}/protocol/openid-connect/token");

        services.AddEndpointsApiExplorer();
        services.AddSwaggerGen(opts =>
        {
            opts.SwaggerDoc("v1", new OpenApiInfo
            {
                Title = cfg[$"{AppConfigCfg.Section}:{AppConfigCfg.ServiceName}"],
                Version = "v1",
                Description = $"This is an API for {cfg[$"{AppConfigCfg.Section}:{AppConfigCfg.ServiceName}"]}",
                Contact = new OpenApiContact
                {
                    Name = cfg[$"{SwaggerGenCfg.Section}:{SwaggerGenCfg.ContactName}"],
                    Email = cfg[$"{SwaggerGenCfg.Section}:{SwaggerGenCfg.ContactEmail}"],
                    Url = new Uri(cfg[$"{SwaggerGenCfg.Section}:{SwaggerGenCfg.ContactUrl}"]!)
                }
            });

            opts.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
            {
                In = ParameterLocation.Header,
                Name = "Authorization",
                Type = SecuritySchemeType.ApiKey,
                Scheme = "Bearer",
                BearerFormat = "JWT",
                Description = "Enter Bearer {token}"
            });
            opts.AddSecurityRequirement(new OpenApiSecurityRequirement
            {
                [new OpenApiSecurityScheme
                {
                    Reference = new OpenApiReference
                    {
                        Type = ReferenceType.SecurityScheme,
                        Id = "Bearer"
                    }
                }] = Array.Empty<string>()
            });

            opts.AddSecurityDefinition("oauth2", new OpenApiSecurityScheme
            {
                Type = SecuritySchemeType.OAuth2,
                Flows = new OpenApiOAuthFlows
                {
                    AuthorizationCode = new OpenApiOAuthFlow
                    {
                        AuthorizationUrl = authUrl,
                        TokenUrl = tokenUrl,
                        Scopes = oauthScopes
                    }
                }
            });

            opts.OperationFilter<AuthorizeCheckOperationFilter>();
        });

        return services;
    }

    public static WebApplication UseSwaggerApi(this WebApplication app)
    {
        var cfg = app.Configuration;

        if (!cfg.GetValue<bool>($"{SwaggerGenCfg.Section}:{SwaggerGenCfg.Enable}"))
            return app;

        var clientId = cfg[$"{AuthorizationCfg.Section}:{AuthorizationCfg.ClientId}"];
        var clientSecret = cfg[$"{AuthorizationCfg.Section}:{AuthorizationCfg.ClientSecret}"];
        var scopes = cfg.GetValue<string[]>($"{AuthorizationCfg.Section}:{AuthorizationCfg.Scopes}");

        app.UseSwagger();
        app.UseSwaggerUI(c =>
        {
            c.SwaggerEndpoint("/swagger/v1/swagger.json", "v1");
            c.OAuthClientId(clientId);
            c.OAuthClientSecret(clientSecret);
            //c.OAuthUsePkce();
            c.OAuthScopes(scopes);
            c.OAuth2RedirectUrl(cfg[$"{AuthorizationCfg.Section}:{AuthorizationCfg.OAuth2RedirectUrl}"]);
        });

        return app;
    }

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/Swagger/AuthorizeCheckOperationFilter.cs">
#region using

using Microsoft.AspNetCore.Authorization;
using Microsoft.OpenApi.Models;
using Swashbuckle.AspNetCore.SwaggerGen;

#endregion

namespace BuildingBlocks.Swagger;

public sealed class AuthorizeCheckOperationFilter : IOperationFilter
{
    #region Implementations

    public void Apply(OpenApiOperation operation, OperationFilterContext context)
    {
        var hasAuthorize = context.ApiDescription
            .ActionDescriptor
            .EndpointMetadata
            .OfType<IAuthorizeData>()
            .Any();

        if (!hasAuthorize) return;

        operation.Responses.TryAdd("401", new OpenApiResponse { Description = "Unauthorized" });
        operation.Responses.TryAdd("403", new OpenApiResponse { Description = "Forbidden" });

        operation.Security = new List<OpenApiSecurityRequirement>
        {
            new OpenApiSecurityRequirement
            {
                [ new OpenApiSecurityScheme {
                    Reference = new OpenApiReference {
                        Type = ReferenceType.SecurityScheme,
                        Id   = "oauth2"
                    }
                }] = new[] { "openid" }
            }
        };
    }

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/Validators/CustomValidators.cs">
#region using

using FluentValidation;
using System.Text.RegularExpressions;

#endregion

namespace BuildingBlocks.Validators;

public static class CustomValidators
{
    #region Methods

    public static IRuleBuilderOptions<T, IList<TElement>> MustHave<T, TElement>(this IRuleBuilder<T, IList<TElement>> ruleBuilder, int num)
    {
        return ruleBuilder.NotNull();
    }

    /// <summary>
    /// Validates that the phone number is in a valid format.
    /// Supports international formats like +1234567890, (123) 456-7890, 123-456-7890, 123.456.7890, 123 456 7890, etc.
    /// </summary>
    /// <typeparam name="T">The type being validated</typeparam>
    /// <param name="ruleBuilder">The rule builder</param>
    /// <returns>Rule builder options</returns>
    public static IRuleBuilderOptions<T, string> IsValidPhoneNumber<T>(this IRuleBuilder<T, string> ruleBuilder)
    {
        return ruleBuilder.Must(BeAValidPhoneNumber).WithMessage("Invalid phone number format");
    }

    /// <summary>
    /// Validates that the phone number is in a valid format with custom error message.
    /// </summary>
    /// <typeparam name="T">The type being validated</typeparam>
    /// <param name="ruleBuilder">The rule builder</param>
    /// <param name="errorMessage">Custom error message</param>
    /// <returns>Rule builder options</returns>
    public static IRuleBuilderOptions<T, string> IsValidPhoneNumber<T>(this IRuleBuilder<T, string> ruleBuilder, string errorMessage)
    {
        return ruleBuilder.Must(BeAValidPhoneNumber).WithMessage(errorMessage);
    }

    private static bool BeAValidPhoneNumber(string? phoneNumber)
    {
        if (string.IsNullOrWhiteSpace(phoneNumber))
            return false;

        // Remove all whitespace and common separators for validation
        var cleanNumber = Regex.Replace(phoneNumber, @"[\s\-\(\)\.]+", "");

        // Check for international format starting with +
        if (cleanNumber.StartsWith("+"))
        {
            cleanNumber = cleanNumber.Substring(1);
        }

        // Phone number should contain only digits after cleaning
        if (!Regex.IsMatch(cleanNumber, @"^\d+$"))
            return false;

        // Phone number should be between 7 and 15 digits (international standard)
        if (cleanNumber.Length < 7 || cleanNumber.Length > 15)
            return false;

        // Additional validation: Common phone number patterns
        var phonePatterns = new[]
        {
            @"^\+?[1-9]\d{6,14}$",                          // International format: +1234567890 (7-15 digits)
            @"^\+?1?[-.\s]?\(?[0-9]{3}\)?[-.\s]?[0-9]{3}[-.\s]?[0-9]{4}$", // US format variations
            @"^\+?[0-9]{2,4}[-.\s]?[0-9]{3,4}[-.\s]?[0-9]{3,4}[-.\s]?[0-9]{3,4}$", // International variations
            @"^\(?[0-9]{3}\)?[-.\s]?[0-9]{3}[-.\s]?[0-9]{4}$" // Standard US format without country code
        };

        return phonePatterns.Any(pattern => Regex.IsMatch(phoneNumber, pattern));
    }

    #endregion
}
</file>

<file path="Shared/BuildingBlocks/BuildingBlocks.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="MongoDB.Driver" />
    <PackageReference Include="FluentValidation" />
    <PackageReference Include="FluentValidation.AspNetCore" />
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" />
    <PackageReference Include="MediatR" />
    <PackageReference Include="Microsoft.FeatureManagement.AspNetCore" />
    <PackageReference Include="Json.Formater" />
    <PackageReference Include="Serilog" />
    <PackageReference Include="Serilog.AspNetCore" />
    <PackageReference Include="Serilog.Sinks.Console" />
    <PackageReference Include="Serilog.Sinks.OpenTelemetry" />
    <PackageReference Include="Serilog.Sinks.Seq" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" />
    <PackageReference Include="SharpAbp.Abp.OpenTelemetry.Exporter.Prometheus.AspNetCore" />
    <PackageReference Include="Swashbuckle.AspNetCore" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" />
    <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Common\Common.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Shared/Common/Attributes/ExportExcelAttribute.cs">
namespace Common.Attributes;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
public class ExportExcelAttribute : Attribute
{
    #region Fields, Properties and Indexers

    /// <summary>
    /// Custom column header text to display in the Excel export
    /// </summary>
    /// <remarks>
    /// When specified, this value will be used instead of the property name as the column header. Leave null to use the property name
    /// </remarks>
    public string? HeaderName { get; set; }

    /// <summary>
    /// Maps specific property values to cell colors in Excel export
    /// </summary>
    /// <remarks>
    /// Provide a JSON object where:
    /// - Keys: possible string values of the property
    /// - Values: colors to apply (HTML color names or hex codes)
    /// 
    /// Example:
    /// {
    ///   "Low": "yellow",
    ///   "Medium": "blue", 
    ///   "High": "red"
    /// }
    /// 
    /// Colors can be standard HTML names or hex codes (#RRGGBB)
    /// Find color codes at: https://htmlcolorcodes.com/color-picker/
    /// </remarks>
    public string? ValueColorMap { get; set; }

    /// <summary>
    /// Maps numeric ranges to cell colors in Excel export
    /// </summary>
    /// <remarks>
    /// Provide a JSON object where:
    /// - Keys: numeric ranges as "min-max" 
    /// - Values: colors to apply (HTML color names or hex codes)
    /// 
    /// Special range keywords:
    /// - "min": represents smallest possible decimal
    /// - "max": represents largest possible decimal
    /// 
    /// Example:
    /// {
    ///   "min-0": "red",     // Negative numbers in red
    ///   "0-100": "yellow",  // 0-100 in yellow
    ///   "1000-max": "green" // 1000+ in green
    /// }
    /// 
    /// Colors can be standard HTML names or hex codes (#RRGGBB)
    /// Find color codes at: https://htmlcolorcodes.com/color-picker/
    /// </remarks>
    public string? NumericRangeColorMap { get; set; }

    /// <summary>
    /// Summary functions to apply to this column in Excel export
    /// </summary>
    /// <remarks>
    /// Provide a JSON array of function configurations where each object contains:
    /// - 'Function': Excel function name (SUM, AVERAGE, MAX, MIN, COUNT, etc.)
    /// - 'Label': Display text for the summary row
    /// - 'Format': Excel format string for the summary result
    /// 
    /// Example:
    /// [
    ///     { 'Function': 'SUM', 'Label': 'Total", "Format': '#,##0.00' },
    ///     { 'Function': 'AVERAGE', 'Label': 'Average', 'Format': '#,##0.00' },
    ///     { 'Function': 'MAX', 'Label': 'Highest', 'Format': '#,##0.00' },
    ///     { 'Function': 'MIN', 'Label': 'Min", 'Format': '#,##0.00' }
    /// ]
    /// </remarks>
    public string? SummaryFunctions { get; set; }

    /// <summary>
    /// Excel format string to apply to cells in this column
    /// </summary>
    /// <remarks>
    /// Common format strings:
    /// - Numbers: "#,##0", "#,##0.00"
    /// - Currency: "$#,##0.00", "#,##0.00"
    /// - Percentage: "0.00%", "0%"
    /// - Dates: "dd/MM/yyyy", "MM/dd/yyyy", "yyyy-MM-dd", "dd-MMM-yyyy"
    /// - Date/Time: "dd/MM/yyyy HH:mm", "yyyy-MM-dd HH:mm:ss"
    /// - Text: "@" (forces text formatting)
    /// - Scientific: "0.00E+00"
    /// - Special: "[Red]#,##0.00;[Blue]-#,##0.00" (conditional formatting)
    /// 
    /// For more information on Excel format strings, see:
    /// https://support.microsoft.com/en-us/office/number-format-codes-5026bbd6-04bc-48cd-bf33-80f18b4eae68
    /// </remarks>
    public string? Format { get; set; }

    /// <summary>
    /// Maps boolean values to custom display text in Excel export
    /// </summary>
    /// <remarks>
    /// Provide a JSON object where:
    /// - Keys: 'True' and 'False' (case-insensitive)
    /// - Values: Display text to use for each boolean state
    /// 
    /// Example:
    /// {
    ///   'True': 'Active',
    ///   'False': 'Inactive'
    /// }
    /// or
    /// {
    ///   'True': 'Yes',
    ///   'False': 'No'
    /// }
    /// 
    /// If not specified, defaults to "Yes" for True and "No" for False
    /// </remarks>
    public string? BooleanValueMap { get; set; }

    /// <summary>
    /// If true, locks this entire column in the Excel sheet to prevent editing
    /// </summary>
    public bool IsLockColumn { get; set; } = false;

    #endregion
}
</file>

<file path="Shared/Common/Configurations/ApiClientCfg.cs">
namespace Common.Configurations;

public sealed class ApiClientCfg
{
    public static class Catalog
    {
        #region Constants

        public const string Section = "ApiClients:Catalog";

        public const string BaseUrl = "BaseUrl";

        #endregion
    }

    public static class Keycloak
    {
        #region Constants

        public const string Section = "ApiClients:Keycloak";

        public const string BaseUrl = "BaseUrl";

        public const string Realm = "Realm";

        public const string ClientId = "ClientId";

        public const string ClientSecret = "ClientSecret";

        public const string Scopes = "Scopes";

        public const string GrantType = "GrantType";

        #endregion
    }

}
</file>

<file path="Shared/Common/Configurations/AppConfigCfg.cs">
namespace Common.Configurations;

public sealed class AppConfigCfg
{
    #region Constants

    public const string Section = "AppConfig";

    public const string ServiceName = "ServiceName";

    public const string ApiKey = "ApiKey";

    public const string IncludeInnerException = "IncludeInnerException";

    public const string IncludeExceptionStackTrace = "IncludeExceptionStackTrace";

    public const string GrpcApiKey = "GrpcApiKey";

    public const string ReservationExpirationMinutes = "ReservationExpirationMinutes";

    #endregion

}
</file>

<file path="Shared/Common/Configurations/AppDomainCfg.cs">
namespace Common.Configurations;

public sealed class AppDomainCfg
{
    #region Constants

    public const string Section = "AppDomains";

    public const string WebStoreUrl = "WebStoreUrl";

    public const string WebAdminUrl = "WebAdminUrl";

    #endregion
}
</file>

<file path="Shared/Common/Configurations/AuthorizationCfg.cs">
namespace Common.Configurations;

public sealed class AuthorizationCfg
{
    #region Constants

    public const string Section = "Authentication";

    public const string Authority = "Authority";

    public const string Audience = "Audience";

    public const string ClientId = "ClientId";

    public const string ClientSecret = "ClientSecret";

    public const string Scopes = "Scopes";

    public const string RequireHttpsMetadata = "RequireHttpsMetadata";

    public const string OAuth2RedirectUrl = "OAuth2RedirectUrl";

    #endregion

}
</file>

<file path="Shared/Common/Configurations/ConnectionStringsCfg.cs">
namespace Common.Configurations;

public sealed class ConnectionStringsCfg
{
    #region Constants

    public const string Section = "ConnectionStrings";

    public const string DbType = "DbType";

    public const string Database = "Database";

    public const string DatabaseName = "DatabaseName"; // For MongoDB

    #endregion
}
</file>

<file path="Shared/Common/Configurations/CorsCfg.cs">
namespace Common.Configurations;

public sealed class CorsCfg
{
    #region Constants

    public const string Section = "CorsConfig";

    public const string PolicyName = "PolicyName";

    public const string Domains = "Domains";

    #endregion
}
</file>

<file path="Shared/Common/Configurations/DistributedTracingCfg.cs">
namespace Common.Configurations;

public sealed class DistributedTracingCfg
{
    #region Constants

    public const string Section = "DistributedTracing";

    public const string Source = "Source";

    public const string SamplingRate = "SamplingRate";

    public const string Zipkin = "Zipkin";

    public const string Otlp = "Otlp";

    public const string Prometheus = "Prometheus";

    public const string Endpoint = "Endpoint";

    public const string ServiceName = "ServiceName";

    public const string Enable = "Enable";

    public const string TimeoutMs = "TimeoutMs";

    #endregion

}
</file>

<file path="Shared/Common/Configurations/ElasticSearchCfg.cs">
namespace Common.Configurations;

public sealed class ElasticSearchCfg
{
    #region Constants

    public const string Section = "ElasticSearch";

    public const string Username = "Username";

    public const string Password = "Password";

    public const string Uri = "Uri";

    #endregion
}
</file>

<file path="Shared/Common/Configurations/GrpcClientCfg.cs">
namespace Common.Configurations;

public sealed class GrpcClientCfg
{
    public static class Catalog
    {
        #region Constants

        public const string Section = "GrpcClients:Catalog";

        public const string Url = "Url";

        public const string ApiKey = "ApiKey";

        #endregion
    }

    public static class Discount
    {
        #region Constants

        public const string Section = "GrpcClients:Discount";

        public const string Url = "Url";

        public const string ApiKey = "ApiKey";

        #endregion
    }

    public static class Inventory
    {
        #region Constants

        public const string Section = "GrpcClients:Inventory";

        public const string Url = "Url";

        public const string ApiKey = "ApiKey";

        #endregion
    }

    public static class Order
    {
        #region Constants

        public const string Section = "GrpcClients:Order";

        public const string Url = "Url";

        public const string ApiKey = "ApiKey";

        #endregion
    }

    public static class Report
    {
        #region Constants

        public const string Section = "GrpcClients:Report";

        public const string Url = "Url";

        public const string ApiKey = "ApiKey";

        #endregion
    }
}
</file>

<file path="Shared/Common/Configurations/KeycloakApiCfg.cs">
namespace Common.Configurations;

public sealed class KeycloakApiCfg
{
    #region Constants

    public const string Section = "ApiClients:Keycloak";

    public const string BaseUrl = "BaseUrl";

    public const string Realm = "Realm";

    public const string ClientId = "ClientId";

    public const string ClientSecret = "ClientSecret";

    public const string Scopes = "Scopes";

    public const string GrantType = "GrantType";

    #endregion

}
</file>

<file path="Shared/Common/Configurations/MessageBrokerCfg.cs">
namespace Common.Configurations;

public sealed class MessageBrokerCfg
{
    #region Constants

    public const string Section = "MessageBroker";

    public const string Host = "Host";

    public const string Port = "Port";

    public const string UserName = "UserName";

    public const string Password = "Password";

    #endregion

}
</file>

<file path="Shared/Common/Configurations/MinIoCfg.cs">
namespace Common.Configurations;

public sealed class MinIoCfg
{
    #region Constants

    public const string Section = "MinIO";

    public const string Endpoint = "Endpoint";

    public const string AccessKey = "AccessKey";

    public const string SecretKey = "SecretKey";

    public const string Secure = "Secure";

    #endregion

}
</file>

<file path="Shared/Common/Configurations/NotificationCfg.cs">
namespace Common.Configurations;

public static class NotificationCfg
{
    public static class EmailSettings
    {
        #region Constants

        public const string Section = "NotificationChanelConfig:EmailSettings";

        public const string SmtpServer = "SmtpServer";

        public const string SmtpPort = "SmtpPort";

        public const string FromAddress = "FromAddress";

        public const string FromName = "FromName";

        public const string Username = "Username";

        public const string Password = "Password";

        public const string EnableSsl = "EnableSsl";

        public const string TimeoutMs = "TimeoutMs";

        #endregion
    }

    public static class WhatsAppSettings
    {
        #region Constants

        public const string Section = "NotificationChanelConfig:WhatsAppSettings";

        public const string BaseUrl = "BaseUrl";

        public const string PhoneNumberId = "PhoneNumberId";

        public const string AccessToken = "AccessToken";

        public const string AppSecret = "AppSecret";

        #endregion
    }

    public static class DiscordSettings
    {
        #region Constants

        public const string Section = "NotificationChanelConfig:DiscordSettings";

        public const string BaseUrl = "BaseUrl";

        public const string WebhookId = "WebhookId";

        public const string WebhookToken = "WebhookToken";

        public const string BotName = "BotName";

        public const string AvatarUrl = "AvatarUrl";

        public const string Url = "Url";

        #endregion
    }
}
</file>

<file path="Shared/Common/Configurations/RedisCacheCfg.cs">
namespace Common.Configurations;

public sealed class RedisCacheCfg
{
    #region Constants

    public const string Section = "RedisCache";

    public const string EndPoint = "EndPoint";

    public const string Password = "Password";

    public const string InstanceName = "InstanceName";

    #endregion
}
</file>

<file path="Shared/Common/Configurations/SerilogCfg.cs">
namespace Common.Configurations;

public sealed class SerilogCfg
{
    #region Constants

    public const string Section = "Logging:Serilog";

    public const string ServiceName = "ServiceName";

    public const string Endpoint = "Endpoint";

    public const string MinimumLevel = "MinimumLevel";

    public const string Default = "Default";

    public const string Override = "Override";

    public const string Microsoft = "Microsoft";

    public const string System = "System";

    public const string Enable = "Enable";

    public const string Otlp = "Otlp";

    public const string Console = "Console";

    public const string Level = "Level";

    #endregion

}
</file>

<file path="Shared/Common/Configurations/SwaggerGenCfg.cs">
namespace Common.Configurations;

public sealed class SwaggerGenCfg
{
    #region Constants

    public const string Section = "SwaggerGen";

    public const string Enable = "Enable";

    public const string ContactName = "ContactName";

    public const string ContactUrl = "ContactUrl";

    public const string ContactEmail = "ContactEmail";

    public const string OAuth2RedirectUrl = "OAuth2RedirectUrl";

    #endregion

}
</file>

<file path="Shared/Common/Configurations/WorkerCfg.cs">
namespace Common.Configurations;

public sealed class WorkerCfg
{
    public class Outbox
    {
        #region Constants

        public const string Section = "WorkerSettings:Outbox";

        public const string BatchSize = "BatchSize";

        public const string ProcessorFrequency = "ProcessorFrequency";

        public const string MaxParallelism = "MaxParallelism";

        #endregion

    }

    public class Proccessor
    {
        #region Constants

        public const string Section = "WorkerSettings:Proccessor";

        public const string BatchSize = "BatchSize";

        #endregion

    }

}
</file>

<file path="Shared/Common/Constants/AppConstants.cs">
namespace Common.Constants;

public sealed class AppConstants
{
    #region Common

    public const int MaxAttempts = 3;

    #endregion

    #region Bucket

    public static class Bucket
    {
        public const string Products = "products";
    }

    #endregion

    #region Service

    public static class Service
    {
        public const string Basket = "basket";

        public const string Catalog = "catalog";

        public const string Communication = "communication";

        public const string Discount = "discount";

        public const string Inventory = "inventory";

        public const string Notification = "notification";

        public const string Order = "order";

        public const string Report = "report";

        public const string Search = "search";
    }

    #endregion

    #region File Content Type

    public static class FileContentType
    {
        public const string OctetStream = "application/octet-stream";
    }

    #endregion
}
</file>

<file path="Shared/Common/Constants/AuthorizeRole.cs">
namespace Common.Constants;

public sealed class AuthorizeRole
{
    #region Constants

    public const string SystemAdmin = "system:admin";

    public const string User = "app:user";

    #endregion
}
</file>

<file path="Shared/Common/Constants/CustomClaimTypes.cs">
namespace Common.Constants;

public sealed class CustomClaimTypes
{
    #region Constants

    public const string RealmAccess = "realm_access";

    public const string Roles = "roles";

    public const string UserName = "preferred_username";

    public const string EmailVerified = "email_verified";

    public const string Tenant = "tenant";

    #endregion
}
</file>

<file path="Shared/Common/Constants/DatabaseType.cs">
namespace Common.Constants;

public sealed class DatabaseType
{
    #region Constants

    public const string SqlServer = "SQLSERVER";

    public const string PostgreSql = "POSTGRESQL";

    public const string MySql = "MYSQL";

    public const string MongoDb = "MONGODB";

    public const string Marten = "MARTEN";

    #endregion
}
</file>

<file path="Shared/Common/Constants/MessageCode.cs">
namespace Common.Constants;

public sealed class MessageCode
{
    #region Fields, Properties and Indexers

    public const string BadRequest = "BAD_REQUEST";

    public const string DecisionFlowIllegal = "DECISION_FLOW_ILLEGAL";

    public const string InvalidEmailAddress = "INVALID_EMAIL_ADDRESS";

    public const string InvalidPhoneNumber = "INVALID_PHONE_NUMBER";

    public const string Max255Characters = "MAX_255_CHARACTERS";

    public const string Max500Characters = "MAX_500_CHARACTERS";

    public const string Max100Characters = "MAX_100_CHARACTERS";

    public const string Max50Characters = "MAX_50_CHARACTERS";

    public const string Max20Characters = "MAX_20_CHARACTERS";

    public const string Min5Characters = "MIN_5_CHARACTERS";

    public const string CreateSuccess = "CREATE_SUCCESS";

    public const string GetSuccess = "GET_SUCCESS";

    public const string UpdateSuccess = "UPDATE_SUCCESS";

    public const string DeleteSuccess = "DELETE_SUCCESS";

    public const string CreateFailure = "CREATE_FAILURE";

    public const string GetFailure = "GET_FAILURE";

    public const string UpdateFailure = "UPDATE_FAILURE";

    public const string DeleteFailure = "DELETE_FAILURE";

    public const string AccessDenied = "ACCESS_DENIED";

    public const string ResourceNotFound = "RESOURCE_NOT_FOUND";

    public const string ResourceNotExists = "RESOURCE_NOT_EXISTS";

    public const string UnknownError = "UNKNOWN_ERROR";

    public const string AgentNameIsRequired = "AGENT_NAME_IS_REQUIRED";

    public const string EmailIsRequired = "EMAIL_IS_REQUIRED";

    public const string UserNameIsRequired = "USERNAME_IS_REQUIRED";

    public const string FirstNameIsRequired = "FIRST_NAME_IS_REQUIRED";

    public const string LastNameIsRequired = "LAST_NAME_IS_REQUIRED";

    public const string IdIsRequired = "ID_IS_REQUIRED";

    public const string PasswordIsRequired = "PASSWORD_IS_REQUIRED";

    public const string ConfirmPasswordIsRequired = "CONFIRM_PASSWORD_IS_REQUIRED";

    public const string ConfirmPasswordIsNotMatch = "CONFIRM_PASSWORD_IS_NOT_MATCH";

    public const string UserNotFound = "USER_NOT_FOUND";

    public const string UserAlreadyExists = "USER_ALREADY_EXISTS";

    public const string ActionIsRequired = "ACTION_IS_REQUIRED";

    public const string Unauthorized = "UNAUTHORIZED";

    public const string NotFound = "NOT_FOUND";

    public const string EmailAlreadyExists = "EMAIL_ALREADY_EXISTS";

    public const string UserNameAlreadyExists = "USERNAME_ALREADY_EXISTS";

    public const string RequestUserIdIsRequired = "REQUEST_USER_ID_IS_REQUIRED";

    public const string UserIdIsRequired = "USER_ID_IS_REQUIRED";

    public const string ChanelIsRequired = "CHANEL_IS_REQUIRED";

    public const string AddressIsRequired = "ADDRESS_IS_REQUIRED";

    public const string SubjectIsRequired = "SUBJECT_IS_REQUIRED";

    public const string BodyIsRequired = "BODY_IS_REQUIRED";

    public const string ProductNameIsRequired = "PRODUCT_NAME_IS_REQUIRED";

    public const string SkuIsRequired = "SKU_IS_REQUIRED";

    public const string ShortDescriptionIsRequired = "SHORT_DESCRIPTION_IS_REQUIRED";

    public const string LongDescriptionIsRequired = "LONG_DESCRIPTION_IS_REQUIRED";

    public const string PriceIsRequired = "PRICE_IS_REQUIRED";

    public const string CategoryIsNotExists = "CATEGORY_IS_NOT_EXISTS";

    public const string CurrencyIsRequired = "CURRENCY_IS_REQUIRED";

    public const string MoneyCannotBeNegative = "MONEY_CANNOT_BE_NEGATIVE";

    public const string MaxDiscountAmountCannotBeNegative = "MAX_DISCOUNT_AMOUNT_CANNOT_BE_NEGATIVE";

    public const string ProductIdIsRequired = "PRODUCT_ID_IS_REQUIRED";

    public const string ProductIsNotFound = "PRODUCT_IS_NOT_FOUND";

    public const string ProductIsNotExists = "PRODUCT_IS_NOT_EXISTS";

    public const string StatusIsInvalid = "STATUS_IS_INVALID";

    public const string QuantityCannotBeNegative = "QUANTITY_CANNOT_BE_NEGATIVE";

    public const string QuantityIsRequired = "QUANTITY_IS_REQUIRED";

    public const string LocationIsRequired = "LOCATION_IS_REQUIRED";

    public const string InsufficientStock = "INSUFFICIENT_STOCK";

    public const string InventoryChangeTypeIsRequired = "INVENTORY_CHANGE_TYPE_IS_REQUIRED";

    public const string SourceIsRequired = "SOURCE_IS_REQUIRED";

    public const string OutOfRange = "OUT_OF_RANGE";

    public const string NotEnoughAvailable = "NOT_ENOUGH_AVAILABLE";

    public const string ReleaseExceedsReserved = "RELEASE_EXCEEDS_RESERVED";

    public const string CommitExceedsReserved = "COMMIT_EXCEEDS_RESERVED";

    public const string CommitExceedsQuantity = "COMMIT_EXCEEDS_QUANTITY";

    public const string InvalidReservationAmount = "INVALID_RESERVATION_AMOUNT";

    public const string ReservationNotFound = "RESERVATION_NOT_FOUND";

    public const string ReservationAlreadyCommitted = "RESERVATION_ALREADY_COMMITTED";

    public const string ReservationExpired = "RESERVATION_EXPIRED";

    public const string CannotCommitNonPendingReservation = "CANNOT_COMMIT_NON_PENDING_RESERVATION";

    public const string InventoryItemIdIsRequired = "INVENTORY_ITEM_ID_IS_REQUIRED";

    public const string StatusIsRequired = "STATUS_IS_REQUIRED";

    public const string NameIsRequired = "NAME_IS_REQUIRED";

    public const string CustomerNameIsRequired = "CUSTOMER_NAME_IS_REQUIRED";

    public const string PhoneNumberIsRequired = "PHONE_NUMBER_IS_REQUIRED";

    public const string AddressLineIsRequired = "ADDRESS_LINE_IS_REQUIRED";

    public const string CountryIsRequired = "COUNTRY_IS_REQUIRED";

    public const string StateOrProvinceIsRequired = "STATE_OR_PROVINCE_IS_REQUIRED";

    public const string PostalCodeIsRequired = "POSTAL_CODE_IS_REQUIRED";

    public const string SubdivisionIsRequired = "SUBDIVISION_IS_REQUIRED";

    public const string CityIsRequired = "CITY_IS_REQUIRED";

    public const string OrderItemsIsRequired = "ORDER_ITEMS_IS_REQUIRED";

    public const string ProductIsRequired = "PRODUCT_IS_REQUIRED";

    public const string OrderIdIsRequired = "ORDER_ID_IS_REQUIRED";

    public const string BasketIsRequired = "BASKET_IS_REQUIRED";

    public const string CouponCodeIsRequired = "COUPON_CODE_IS_REQUIRED";

    public const string DescriptionIsRequired = "DESCRIPTION_IS_REQUIRED";

    public const string ValidFromIsRequired = "VALID_FROM_IS_REQUIRED";

    public const string ValidToIsRequired = "VALID_TO_IS_REQUIRED";

    public const string ValidToInvalid = "VALID_TO_INVALID";

    public const string CouponCodeIsExists = "COUPON_CODE_IS_EXISTS";

    public const string CouponCodeIsNotExistsOrExpired = "COUPON_CODE_IS_NOT_EXISTS_OR_EXPIRED";

    public const string EventIdIsRequired = "EVENT_ID_IS_REQUIRED";

    public const string TemplateKeyIsRequired = "TEMPLATE_KEY_IS_REQUIRED";

    public const string ToRecipientsIsRequired = "TO_RECIPIENTS_IS_REQUIRED";

    public const string AtLeastOneRecipientIsRequired = "AT_LEAST_ONE_RECIPIENT_IS_REQUIRED";

    public const string MaxAttemptsMustBeGreaterThanZero = "MAX_ATTEMPTS_MUST_BE_GREATER_THAN_ZERO";

    public const string TemplateNotFound = "TEMPLATE_NOT_FOUND";

    public const string ThumbnailIsRequired = "THUMBNAIL_IS_REQUIRED";

    public const string BrandIsNotExists = "BRAND_IS_NOT_EXISTS";

    public const string BrandIdIsRequired = "BRAND_ID_IS_REQUIRED";

    public const string BrandNameIsRequired = "BRAND_NAME_IS_REQUIRED";

    public const string CategoryIdIsRequired = "CATEGORY_ID_IS_REQUIRED";

    public const string CategoryNameIsRequired = "CATEGORY_NAME_IS_REQUIRED";

    public const string CategoryHasChildren = "CATEGORY_HAS_CHILDREN";

    public const string CategoryCannotBeItsOwnParent = "CATEGORY_CANNOT_BE_ITS_OWN_PARENT";

    public const string MaxUsageIsRequired = "MAX_USAGE_IS_REQUIRED";

    public const string ValueIsRequired = "VALUE_IS_REQUIRED";

    public const string ProgramNameIsRequired = "PROGRAM_NAME_IS_REQUIRED";

    public const string InvalidOrderStatus = "INVALID_ORDER_STATUS";

    public const string OrderStatusSameAsCurrent = "ORDER_STATUS_SAME_AS_CURRENT";

    public const string CancelReasonIsRequired = "CANCEL_REASON_IS_REQUIRED";

    public const string RefundReasonIsRequired = "REFUND_REASON_IS_REQUIRED";

    public const string OrderCannotBeUpdated = "ORDER_CANNOT_BE_UPDATED";

    public const string OrderStatusCannotBeUpdated = "ORDER_STATUS_CANNOT_BE_UPDATED";

    public const string TitleIsRequired = "TITLE_IS_REQUIRED";

    public const string CountIsRequired = "COUNT_IS_REQUIRED";

    public const string InvalidDayRange = "INVALID_DAY_RANGE";

    public const string ValueCannotBeNegative = "VALUE_CANNOT_BE_NEGATIVE";

    public const string ProductsIsNotExistsOrNotInStock = "PRODUCTS_IS_NOT_EXISTS_OR_NOT_IN_STOCK";

    public const string ProductIsNotExistsOrNotInStock = "PRODUCT_IS_NOT_EXISTS_OR_NOT_IN_STOCK";

    public const string OrderNotFound = "ORDER_NOT_FOUND";

    public const string InventoryItemAlreadyExists = "INVENTORY_ITEM_ALREADY_EXISTS";

    public const string LocationIsNotExists = "LOCATION_IS_NOT_EXISTS";

    public const string InventoryItemNotFound = "INVENTORY_ITEM_NOT_FOUND";

    #endregion
}
</file>

<file path="Shared/Common/Constants/ReqHeaderName.cs">
namespace Common.Constants;

public sealed class ReqHeaderName
{
    #region Constants

    public const string GrpcKey = "x-grpc-key";

    #endregion

}
</file>

<file path="Shared/Common/Enums/ApplicationStatus.cs">
#region using

using System.ComponentModel;

#endregion

namespace Common.Enums;

public enum ApplicationStatus
{
    #region Fields, Properties and Indexers

    [Description("Draf")]
    Draft = 1,

    [Description("Awaiting Approval")]
    AwaitingApproval = 2,

    [Description("Approved")]
    Approved = 3,

    [Description("Rejected")]
    Rejected = 4,

    [Description("Expired")]
    Expired = 6,

    [Description("Active")]
    Active = 7,

    [Description("Inactive")]
    Inactive = 8,

    #endregion

}
</file>

<file path="Shared/Common/Extensions/EnumExtension.cs">
#region using

using System.ComponentModel;
using System.Reflection;

#endregion

namespace Common.Extensions;

public static class EnumExtension
{
    #region Methods

    public static string GetDescription<TEnum>(this TEnum? value) where TEnum : struct, Enum
    {
        if (!value.HasValue)
            return string.Empty;

        var field = typeof(TEnum).GetField(value.ToString()!);
        if (field == null)
            return value.ToString() ?? string.Empty;

        var attribute = field.GetCustomAttribute<DescriptionAttribute>();
        return attribute?.Description ?? value.ToString() ?? string.Empty;
    }

    public static string GetDescription<TEnum>(this TEnum value) where TEnum : struct, Enum
    {
        var field = typeof(TEnum).GetField(value.ToString());
        if (field == null)
            return value.ToString() ?? string.Empty;

        var attribute = field.GetCustomAttribute<DescriptionAttribute>();
        return attribute?.Description ?? value.ToString() ?? string.Empty;
    }

    #endregion

}
</file>

<file path="Shared/Common/Extensions/HashExtension.cs">
#region using

using System.Security.Cryptography;
using System.Text;

#endregion

namespace Common.Extensions;

public static class HashExtension
{
    #region Methods

    public static string UseSha256(this string input)
    {
        if (string.IsNullOrWhiteSpace(input)) return string.Empty;

        using (var sha = SHA256.Create())
        {
            var bytes = Encoding.UTF8.GetBytes(input);
            var hash = sha.ComputeHash(bytes);

            return Convert.ToBase64String(hash);
        }
    }

    public static byte[]? UseSha256(this byte[] input)
    {
        if (input == null)
        {
            return null;
        }

        using (var sha = SHA256.Create())
        {
            return sha.ComputeHash(input);
        }
    }

    public static string UseSha512(this string input)
    {
        if (string.IsNullOrWhiteSpace(input)) return string.Empty;

        using (var sha = SHA512.Create())
        {
            var bytes = Encoding.UTF8.GetBytes(input);
            var hash = sha.ComputeHash(bytes);

            return Convert.ToBase64String(hash);
        }
    }

    #endregion
}
</file>

<file path="Shared/Common/Extensions/NumericExtension.cs">
namespace Common.Extensions;

public static class NumericExtension
{
    #region Fields, Properties and Indexers

    private static readonly string[] FileSizeSuffixes = ["Bytes", "KB", "MB", "GB", "TB", "PB"];

    #endregion

    #region Methods

    public static string ToFileSize(this long value)
    {
        int counter = 0;
        decimal number = value;
        while (Math.Round(number / 1024) >= 1)
        {
            number /= 1024;
            counter++;
        }

        return $"{number:n1} {FileSizeSuffixes[counter]}";
    }

    public static string ToShortNumber(this int value)
    {
        const string baseString = "k";
        string toString = $"{value:#,##0.##}";
        if (value < 1000)
        {
            return value.ToString();
        }

        string s1 = toString.Split(",")[0];
        string s2 = toString.Split(",")[1];

        string str;
        if (int.Parse(s2) > 99)
        {
            str = string.Concat(s1, ".", s2.AsSpan(0, s2.Length - 2), baseString);
        }
        else
        {
            str = s1 + baseString;
        }

        return str;
    }

    public static TEnum? ToEnum<TEnum>(this int value) where TEnum : struct, Enum
    {
        return Enum.IsDefined(typeof(TEnum), value)
            ? (TEnum)Enum.ToObject(typeof(TEnum), value)
            : null;
    }

    #endregion
}
</file>

<file path="Shared/Common/Extensions/QueryableExtension.cs">
#region using

using System.Linq.Expressions;

#endregion

namespace Common.Extensions;

public static class QueryableExtension
{
    #region Methods

    public static IQueryable<T> WhereIf<T>(this IQueryable<T> query,
        bool condition,
        Expression<Func<T, bool>> predicate)
    {
        if (!condition)
        {
            return query;
        }

        return query.Where(predicate);
    }

    public static IQueryable<T> TakeIf<T, TKey>(this IQueryable<T> query,
        Expression<Func<T, TKey>> orderBy, bool condition, int limit, bool orderByDescending = true)
    {
        query = (orderByDescending ? query.OrderByDescending(orderBy) : query.OrderBy(orderBy));
        if (!condition)
        {
            return query;
        }

        return query.Take(limit);
    }

    public static IQueryable<T> PageBy<T, TKey>(this IQueryable<T> query,
        Expression<Func<T, TKey>> orderBy, int page, int pageSize, bool orderByDescending = true)
    {
        if (query == null)
        {
            throw new ArgumentNullException("query");
        }

        if (page <= 0)
        {
            page = 1;
        }

        query = (orderByDescending ? query.OrderByDescending(orderBy) : query.OrderBy(orderBy));
        return query.Skip((page - 1) * pageSize).Take(pageSize);
    }

    #endregion
}
</file>

<file path="Shared/Common/Extensions/StringExtension.cs">
#region using

using System.Text.RegularExpressions;

#endregion

namespace Common.Extensions;

public static class StringExtension
{
    #region Methods

    public static string TruncateString(this string value, int maxLength = 0)
    {
        return value.Length > maxLength
        ? string.Concat(value.AsSpan(0, maxLength), "...")
        : value;
    }

    public static string Slugify(this string input)
    {
        if (string.IsNullOrWhiteSpace(input)) return string.Empty;

        string result = Regex.Replace(input, @"\s+", "-");
        result = Regex.Replace(result, @"[^a-zA-Z0-9\-]", "");
        result = Regex.Replace(result, "-{2,}", "-");

        return result.Trim('-');
    }

    public static TEnum? ToEnum<TEnum>(this string str) where TEnum : struct, Enum
    {
        if (string.IsNullOrWhiteSpace(str))
            return null;

        return Enum.TryParse<TEnum>(str, true, out var result) ? result : null;
    }

    public static string To(this string input)
    {
        if (string.IsNullOrWhiteSpace(input)) return string.Empty;

        string result = Regex.Replace(input, @"\s+", "-");
        result = Regex.Replace(result, @"[^a-zA-Z0-9\-]", "");
        result = Regex.Replace(result, "-{2,}", "-");

        return result.Trim('-');
    }

    #endregion
}
</file>

<file path="Shared/Common/Helpers/EnumHelper.cs">
namespace Common.Helpers;

public static class EnumHelper
{
    #region Methods

    public static bool IsEnumValueValid<T>(int value) where T : struct, Enum
    {
        return Enum.IsDefined(typeof(T), value);
    }

    #endregion
}
</file>

<file path="Shared/Common/Helpers/NumericHelper.cs">
namespace Common.Helpers;

public static class NumericHelper
{
    #region Methods

    public static int CalculateDiscountPercent(double originalPrice, double salePrice)
    {
        double discountAmount = originalPrice - salePrice;
        double discountPercent = (discountAmount / originalPrice) * 100;
        return (int)discountPercent;
    }

    #endregion
}
</file>

<file path="Shared/Common/Models/Context/UserContext.cs">
namespace Common.Models.Context;

public sealed class UserContext
{
    #region Fields, Properties and Indexers

    public string Id { get; init; } = default!;

    public string UserName { get; init; } = default!;

    public string FirstName { get; init; } = default!;

    public string LastName { get; init; } = default!;

    public string? MiddleName { get; init; }

    public string Email { get; init; } = default!;

    public bool EmailVerified { get; init; }

    public string? Tenant { get; init; }

    public List<string>? Roles { get; init; }

    #endregion

    #region Methods

    public bool HasRoles(string roleName)
    {
        return Roles != null && Roles.Any(role => role == roleName);
    }

    #endregion
}
</file>

<file path="Shared/Common/Models/Reponses/ApiCreatedResponse.cs">
namespace Common.Models.Reponses;

public sealed class ApiCreatedResponse<T>
{
    #region Fields, Properties and Indexers

    public T Value { get; set; } = default!;

    #endregion

    #region Ctors

    public ApiCreatedResponse() { }

    public ApiCreatedResponse(T value)
    {
        Value = value;
    }

    #endregion
}
</file>

<file path="Shared/Common/Models/Reponses/ApiDefaultPathResponse.cs">
namespace Common.Models.Reponses;

public sealed class ApiDefaultPathResponse
{
    #region Fields, Properties and Indexers

    public string Service { get; set; } = default!;

    public string Status { get; set; } = default!;

    public DateTimeOffset Timestamp { get; set; }

    public string Environment { get; set; } = default!;

    public Dictionary<string, string> Endpoints { get; set; } = default!;

    public string Message { get; set; } = default!;

    #endregion
}
</file>

<file path="Shared/Common/Models/Reponses/ApiDeletedResponse.cs">
namespace Common.Models.Reponses;

public sealed class ApiDeletedResponse<T>
{
    #region Fields, Properties and Indexers

    public T Value { get; set; } = default!;

    #endregion

    #region Ctors

    public ApiDeletedResponse() { }

    public ApiDeletedResponse(T value)
    {
        Value = value;
    }

    #endregion
}
</file>

<file path="Shared/Common/Models/Reponses/ApiGetResponse.cs">
namespace Common.Models.Reponses;

public sealed class ApiGetResponse<T>
{
    #region Fields, Properties and Indexers

    public T Result { get; set; } = default!;

    #endregion

    #region Ctors

    public ApiGetResponse() { }

    public ApiGetResponse(T result)
    {
        Result = result;
    }

    #endregion
}
</file>

<file path="Shared/Common/Models/Reponses/ApiPerformedResponse.cs">
namespace Common.Models.Reponses;

public sealed class ApiPerformedResponse<T>
{
    #region Fields, Properties and Indexers

    public T Result { get; set; } = default!;

    #endregion

    #region Ctors

    public ApiPerformedResponse() { }

    public ApiPerformedResponse(T result)
    {
        Result = result;
    }

    #endregion
}
</file>

<file path="Shared/Common/Models/Reponses/ApiUpdatedResponse.cs">
namespace Common.Models.Reponses;

public sealed class ApiUpdatedResponse<T>
{
    #region Fields, Properties and Indexers

    public T Value { get; set; } = default!;

    #endregion

    #region Ctors

    public ApiUpdatedResponse() { }

    public ApiUpdatedResponse(T value)
    {
        Value = value;
    }

    #endregion
}
</file>

<file path="Shared/Common/Models/Reponses/ResultSharedResponse.cs">
namespace Common.Models.Reponses;

public sealed class ResultSharedResponse<T> where T : class
{
    #region Fields, Properties and Indexers

    public T Data { get; set; } = default!;

    public string? Message { get; set; }

    public int StatusCode { get; set; }

    public string? Instance { get; set; }

    public List<ErrorResult>? Errors { get; set; }

    #endregion

    #region Ctors

    public ResultSharedResponse()
    {
    }

    public ResultSharedResponse(
        T data,
        string message,
        int statusCode,
        string? instance,
        List<ErrorResult>? errors)
    {
        Data = data;
        Message = message;
        StatusCode = statusCode;
        Instance = instance;
        Errors = errors;
    }

    public ResultSharedResponse(
        int statusCode,
        string? instance,
        List<ErrorResult>? errors,
        string? message)
    {
        StatusCode = statusCode;
        Instance = instance;
        Errors = errors;
        Message = message;
    }

    #endregion

    #region Methods

    public static ResultSharedResponse<T> Failure(
        int statusCode = 400,
        string? instance = null,
        List<ErrorResult>? errors = null,
        string? message = null)
    {
        return new ResultSharedResponse<T>(statusCode, instance, errors, message);
    }

    public static ResultSharedResponse<T> Success(
        T data,
        string message,
        string? instance = null)
    {
        return new ResultSharedResponse<T>(data, message, 200, instance, null);
    }

    #endregion

}
</file>

<file path="Shared/Common/Models/ErrorResult.cs">
namespace Common.Models;

public sealed class ErrorResult
{
    #region Fields, Properties and Indexers

    public string? ErrorMessage { get; set; }

    public object? Details { get; set; }

    #endregion

    #region Ctors

    public ErrorResult(string errorMessage, object? details)
    {
        ErrorMessage = errorMessage;
        Details = details;
    }

    #endregion
}
</file>

<file path="Shared/Common/Models/PaginationRequest.cs">
namespace Common.Models;

public sealed record PaginationRequest(int PageNumber = 1, int PageSize = 1000);
</file>

<file path="Shared/Common/Models/UploadFileBytes.cs">
namespace Common.Models;

public sealed class UploadFileBytes
{
    #region Fields, Properties and Indexers

    public required string FileName { get; init; }

    public required string ContentType { get; init; }

    public required byte[] Bytes { get; init; }

    #endregion
}
</file>

<file path="Shared/Common/Models/UploadFileResult.cs">
namespace Common.Models;

public sealed class UploadFileResult
{
    #region Fields, Properties and Indexers

    public string FileId { get; set; } = Guid.NewGuid().ToString();

    public string? FolderName { get; set; }

    public string? OriginalFileName { get; set; }

    public string? FileName { get; set; }

    public long FileSize { get; set; }

    public string? ContentType { get; set; }

    public string? PublicURL { get; set; }

    #endregion
}
</file>

<file path="Shared/Common/ValueObjects/Actor.cs">
namespace Common.ValueObjects;

public enum ActorKind { User, System, Job, Worker, Consumer }

public readonly record struct Actor(ActorKind Kind, string Value)
{
    #region Methods

    public static Actor User(string value)
        => new(ActorKind.User, value);

    public static Actor System(string value)
        => new(ActorKind.System, value);

    public static Actor Job(string value)
        => new(ActorKind.Job, value);

    public static Actor Worker(string value)
        => new(ActorKind.Worker, value);

    public static Actor Consumer(string value)
        => new(ActorKind.Consumer, value);

    public override string ToString()
    {
        if (Kind == ActorKind.User) return Value!;

        return $"{Kind.ToString().ToLowerInvariant()}:{Value}";
    }

    #endregion
}
</file>

<file path="Shared/Common/Common.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="EPPlus" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Options\" />
  </ItemGroup>

</Project>
</file>

<file path="Shared/Contracts/Catalog.Contract/Protos/catalog.proto">
syntax = "proto3";

option csharp_namespace = "Catalog.Grpc";

package catalog;

// ==== Definition ====
service CatalogGrpc {
	rpc GetProducts (GetProductsRequest) returns (GetProductsResponse);
	rpc GetProductById (GetProductByIdRequest) returns (GetProductByIdResponse);
	rpc GetCountProduct (GetCountProductRequest) returns (GetCountProductResponse);
	rpc GetAllAvailableProducts (GetAllAvailableProductsRequest) returns (GetAllAvailableProductsResponse);
}

// ==== Messages ====
message Product {
	string id = 1;
	string name = 2;
	double price = 3;
	string thumbnail = 4;
}

message GetProductsRequest {
	string search_text = 1;
	repeated string ids = 2;
}

message GetProductsResponse {
  repeated Product products = 1;
}

message GetProductByIdRequest {
  string id = 1;
}

message GetProductByIdResponse {
  Product product = 1;
}

message GetCountProductRequest { }

message GetCountProductResponse {
  int32 count = 1;
}

message GetAllAvailableProductsRequest {
	string search_text = 1;
	repeated string ids = 2;
}

message GetAllAvailableProductsResponse {
  repeated Product products = 1;
}
</file>

<file path="Shared/Contracts/Catalog.Contract/Catalog.Contract.csproj">
<Project Sdk="Microsoft.NET.Sdk">

</Project>
</file>

<file path="Shared/Contracts/Discount.Contract/Protos/discount.proto">
syntax = "proto3";

option csharp_namespace = "Discount.Grpc";

package discount;

// ==== Definition ====
service DiscountGrpc {
	rpc ApplyCoupon (ApplyCouponRequest) returns (ApplyCouponResponse);
	rpc EvaluateCoupon (EvaluateCouponRequest) returns (EvaluateCouponResponse);
}

// ==== Messages ====
message EvaluateCouponRequest {
	string code = 1;
	double amount = 2;
}

message EvaluateCouponResponse {
  double original_amount = 1;
  double discount_amount = 2;
  double final_amount = 3;
  string coupon_code = 4;
}

message ApplyCouponRequest {
	string code = 1;
	double amount = 2;
}

message ApplyCouponResponse {
  string coupon_code = 4;
}
</file>

<file path="Shared/Contracts/Discount.Contract/Discount.Contract.csproj">
<Project Sdk="Microsoft.NET.Sdk">

</Project>
</file>

<file path="Shared/Contracts/Inventory.Contract/Protos/inventory.proto">
syntax = "proto3";

option csharp_namespace = "Inventory.Grpc";

package inventory;

// ==== Definition ====
service InventoryGrpc {
	rpc ExpireReservation (ExpireReservationRequest) returns (ExpireReservationResponse);
}

// ==== Messages ====
message ExpireReservationRequest { }

message ExpireReservationResponse {
  string success = 1;
}
</file>

<file path="Shared/Contracts/Inventory.Contract/Inventory.Contract.csproj">
<Project Sdk="Microsoft.NET.Sdk">

</Project>
</file>

<file path="Shared/Contracts/Order.Contract/Protos/order.proto">
syntax = "proto3";

option csharp_namespace = "Order.Grpc";

package order;

import "google/protobuf/timestamp.proto";

// ==== Definition ====
service OrderGrpc {
	rpc GetOrdersByMonth (GetOrdersByMonthRequest) returns (GetOrdersByMonthResponse);
	rpc GetAllOrders (GetAllOrdersRequest) returns (GetAllOrdersResponse);
}

// ==== Messages ====
message Order {
	string id = 1;
	repeated OrderItem order_items = 2;
	double total_price = 3;
	double final_price = 4;
	google.protobuf.Timestamp created_on_utc = 5;
}

message OrderItem {
	Product product = 1;
	int32 quantity = 2;
}

message Product {
	string id = 1;
	string name = 2;
	double price = 3;
}

message GetOrdersByMonthRequest {
	int32 year = 1;
	int32 month = 2;
}

message GetOrdersByMonthResponse {
	repeated Order orders = 1;
}

message GetAllOrdersRequest { }

message GetAllOrdersResponse {
	repeated Order orders = 1;
}
</file>

<file path="Shared/Contracts/Order.Contract/Order.Contract.csproj">
<Project Sdk="Microsoft.NET.Sdk">

</Project>
</file>

<file path="Shared/Contracts/Report.Contract/Protos/report.proto">
syntax = "proto3";

option csharp_namespace = "Report.Grpc";

package report;

import "google/protobuf/timestamp.proto";

// ==== Definition ====
service ReportGrpc {
	rpc PutDashboardTotal (PutDashboardTotalRequest) returns (PutDashboardTotalResponse);
	rpc PutOrderGrowthLineChart (PutOrderGrowthLineChartRequest) returns (PutOrderGrowthLineChartResponse);
	rpc PutTopProductPieChart (PutTopProductPieChartRequest) returns (PutTopProductPieChartResponse);
}

// ==== Messages ====
message PutDashboardTotalRequest {
	string title = 1;
	string count = 2;
}

message PutDashboardTotalResponse {
	bool success = 1;
}

message OrderGrowthLineChartItem {
	int32 day = 1;
	double value = 2;
	google.protobuf.Timestamp date = 3;
}

message PutOrderGrowthLineChartRequest {
	repeated OrderGrowthLineChartItem items = 1;
}

message PutOrderGrowthLineChartResponse {
	bool success = 1;
}

message TopProductPieChartItem {
	string name = 1;
	double value = 2;
}

message PutTopProductPieChartRequest {
	repeated TopProductPieChartItem items = 1;
}

message PutTopProductPieChartResponse {
	bool success = 1;
}
</file>

<file path="Shared/Contracts/Report.Contract/Report.Contract.csproj">
<Project Sdk="Microsoft.NET.Sdk" />
</file>

<file path="Shared/EventSourcing/Events/Baskets/BasketCheckoutIntegrationEvent.cs">
namespace EventSourcing.Events.Baskets;

public sealed record BasketCheckoutIntegrationEvent : IntegrationEvent
{
    #region Fields, Properties and Indexers

    public Guid BasketId { get; init; }

    public CustomerIntegrationEvent Customer { get; init; } = default!;

    public AddressIntegrationEvent ShippingAddress { get; init; } = default!;

    public DiscountIntegrationEvent Discount { get; init; } = default!;

    public IReadOnlyCollection<CartItemIntegrationEvent> Items { get; init; } = Array.Empty<CartItemIntegrationEvent>();

    #endregion
}

public sealed record CustomerIntegrationEvent
{
    public Guid? Id { get; init; }

    public string Name { get; init; } = default!;

    public string Email { get; init; } = default!;

    public string PhoneNumber { get; init; } = default!;
}

public sealed record AddressIntegrationEvent
{
    public string AddressLine { get; init; } = default!;

    public string Subdivision { get; init; } = default!;

    public string City { get; init; } = default!;

    public string StateOrProvince { get; init; } = default!;

    public string Country { get; init; } = default!;

    public string PostalCode { get; init; } = default!;
}

public sealed record CartItemIntegrationEvent
{
    public Guid ProductId { get; init; }

    public int Quantity { get; init; }
}

public sealed record DiscountIntegrationEvent
{
    public string CouponCode { get; init; } = default!;

    public decimal DiscountAmount { get; init; }
}
</file>

<file path="Shared/EventSourcing/Events/Catalog/DeletedUnPublishedProductIntegrationEvent.cs">
namespace EventSourcing.Events.Catalog;

public sealed record class DeletedUnPublishedProductIntegrationEvent : IntegrationEvent
{
    #region Fields, Properties and Indexers

    public Guid ProductId { get; init; }

    #endregion
}
</file>

<file path="Shared/EventSourcing/Events/Catalog/UpsertedProductIntegrationEvent.cs">
namespace EventSourcing.Events.Catalog;

public sealed record class UpsertedProductIntegrationEvent : IntegrationEvent
{
    #region Fields, Properties and Indexers

    public Guid ProductId { get; init; }

    public string Name { get; init; } = default!;

    public string Sku { get; init; } = default!;

    public string Slug { get; init; } = default!;

    public decimal Price { get; init; } = default!;

    public decimal? SalePrice { get; init; } = default!;

    public List<string>? Categories { get; init; } = default!;

    public List<string>? Images { get; init; } = default!;

    public string Thumbnail { get; init; } = default!;

    public int Status { get; init; }

    public bool Published { get; init; }

    public DateTimeOffset CreatedOnUtc { get; init; }

    public string? CreatedBy { get; init; }

    public DateTimeOffset? LastModifiedOnUtc { get; init; }

    public string? LastModifiedBy { get; init; }

    #endregion
}
</file>

<file path="Shared/EventSourcing/Events/Inventories/ReservationExpiredIntegrationEvent.cs">
namespace EventSourcing.Events.Inventories;

public sealed record ReservationExpiredIntegrationEvent : IntegrationEvent
{
    #region Fields, Properties and Indexers

    public Guid ReservationId { get; init; }

    public Guid OrderId { get; init; }

    public Guid ProductId { get; init; }

    public string ProductName { get; init; } = default!;

    public int Quantity { get; init; }

    #endregion
}
</file>

<file path="Shared/EventSourcing/Events/Inventories/StockChangedIntegrationEvent.cs">
namespace EventSourcing.Events.Inventories;

public sealed record StockChangedIntegrationEvent : IntegrationEvent
{
    #region Fields, Properties and Indexers

    public Guid InventoryItemId { get; init; }

    public Guid ProductId { get; init; }

    public int ChangeType { get; init; }

    public int Amount { get; init; }

    public string? Source { get; init; }

    #endregion
}
</file>

<file path="Shared/EventSourcing/Events/Orders/OrderCancelledIntegrationEvent.cs">
namespace EventSourcing.Events.Orders;

public sealed record OrderCancelledIntegrationEvent : IntegrationEvent
{
    #region Fields, Properties and Indexers

    public Guid OrderId { get; init; }

    public string OrderNo { get; init; } = default!;

    public string Reason { get; init; } = default!;

    public List<OrderItemIntegrationEvent> OrderItems { get; init; } = default!;

    #endregion
}
</file>

<file path="Shared/EventSourcing/Events/Orders/OrderCreatedIntegrationEvent.cs">
namespace EventSourcing.Events.Orders;

public sealed record OrderCreatedIntegrationEvent : IntegrationEvent
{
    #region Fields, Properties and Indexers

    public Guid OrderId { get; init; }

    public string OrderNo { get; init; } = default!;

    public List<OrderItemIntegrationEvent> OrderItems { get; init; } = default!;

    public decimal TotalPrice { get; init; }

    public decimal FinalPrice { get; init; }

    #endregion
}

public sealed record OrderItemIntegrationEvent
{
    #region Fields, Properties and Indexers

    public Guid ProductId { get; init; }

    public string ProductName { get; init; } = default!;

    public int Quantity { get; init; }

    public decimal UnitPrice { get; init; }

    public decimal LineTotal { get; init; }

    #endregion
}
</file>

<file path="Shared/EventSourcing/Events/Orders/OrderDeliveredIntegrationEvent.cs">
namespace EventSourcing.Events.Orders;

public sealed record class OrderDeliveredIntegrationEvent : IntegrationEvent
{
    #region Fields, Properties and Indexers

    public Guid OrderId { get; init; }

    public string OrderNo { get; init; } = default!;

    public string Reason { get; init; } = default!;

    public List<OrderItemIntegrationEvent> OrderItems { get; init; } = default!;

    #endregion
}
</file>

<file path="Shared/EventSourcing/Events/AssemblyReference.cs">
#region using

using System.Reflection;

#endregion

namespace EventSourcing.Events;

public static class AssemblyReference
{
    public static readonly Assembly Assembly = typeof(AssemblyReference).Assembly;
}
</file>

<file path="Shared/EventSourcing/Events/IntegrationEvent.cs">
namespace EventSourcing.Events;

public record IntegrationEvent
{
    #region Fields, Properties and Indexers

    public string Id { get; init; } = default!;

    public DateTimeOffset OccurredOn { get; init; } = DateTimeOffset.UtcNow;

    public string? EventType => GetType()?.AssemblyQualifiedName;

    #endregion

}
</file>

<file path="Shared/EventSourcing/MassTransit/Extentions.cs">
#region using

using MassTransit;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Common.Configurations;
using System.Reflection;

#endregion

namespace EventSourcing.MassTransit;

public static class Extentions
{
    #region Methods

    public static IServiceCollection AddMessageBroker(
        this IServiceCollection services,
        IConfiguration cfg,
        Assembly? assembly = null)
    {
        services.AddMassTransit(config =>
        {
            config.SetKebabCaseEndpointNameFormatter();

            if (assembly != null)
                config.AddConsumers(assembly);

            config.UsingRabbitMq((context, configurator) =>
            {
                configurator.Host(new Uri(cfg[$"{MessageBrokerCfg.Section}:{MessageBrokerCfg.Host}"]!), host =>
                {
                    host.Username(cfg[$"{MessageBrokerCfg.Section}:{MessageBrokerCfg.UserName}"]!);
                    host.Password(cfg[$"{MessageBrokerCfg.Section}:{MessageBrokerCfg.Password}"]!);
                });
                configurator.ConfigureEndpoints(context);
            });
        });

        return services;
    }

    #endregion
}
</file>

<file path="Shared/EventSourcing/EventSourcing.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="MassTransit.RabbitMQ" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Common\Common.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="Directory.Build.props">
<Project>

  <!-- ============================================ -->
  <!-- Common Properties for All Projects -->
  <!-- ============================================ -->
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>12</LangVersion>
  </PropertyGroup>

  <!-- ============================================ -->
  <!-- Build Configuration -->
  <!-- ============================================ -->
  <PropertyGroup>
    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
    <GenerateDocumentationFile>false</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);CS1591</NoWarn>
  </PropertyGroup>

  <!-- ============================================ -->
  <!-- Assembly Information -->
  <!-- ============================================ -->
  <PropertyGroup>
    <Company>ProG Coder</Company>
    <Authors>Huy Xuan Nguyen</Authors>
    <Copyright>Copyright  ProG Coder 2026</Copyright>
    <Product>ProG Coder Shop Microservices</Product>
  </PropertyGroup>

</Project>
</file>

<file path="Directory.Packages.props">
<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
  </PropertyGroup>
  <!-- ============================================ -->
  <!-- Core CQRS & Validation Packages -->
  <!-- ============================================ -->
  <ItemGroup Label="CQRS and Validation">
    <PackageVersion Include="MediatR" Version="12.3.0" />
    <PackageVersion Include="FluentValidation" Version="11.9.2" />
    <PackageVersion Include="FluentValidation.AspNetCore" Version="11.3.0" />
    <PackageVersion Include="FluentValidation.DependencyInjectionExtensions" Version="11.9.2" />
    <PackageVersion Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" Version="1.23.0" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- Mapping & DI Packages -->
  <!-- ============================================ -->
  <ItemGroup Label="Mapping and Dependency Injection">
    <PackageVersion Include="AutoMapper" Version="12.0.1" />
    <PackageVersion Include="AutoMapper.Extensions.Microsoft.DependencyInjection" Version="12.0.1" />
    <PackageVersion Include="Scrutor" Version="6.1.0" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- Database - Entity Framework Core -->
  <!-- ============================================ -->
  <ItemGroup Label="Entity Framework Core">
    <PackageVersion Include="Microsoft.EntityFrameworkCore" Version="8.0.6" />
    <PackageVersion Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.6" />
    <PackageVersion Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.6" />
    <PackageVersion Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.6" />
    <PackageVersion Include="Aspire.Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.2" />
    <PackageVersion Include="MySql.EntityFrameworkCore" Version="8.0.5" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- Database - NoSQL & Document DB -->
  <!-- ============================================ -->
  <ItemGroup Label="NoSQL and Document Databases">
    <PackageVersion Include="Marten" Version="7.26.4" />
    <PackageVersion Include="MongoDB.Driver" Version="3.4.2" />
    <PackageVersion Include="MongoDB.Bson" Version="3.4.2" />
    <PackageVersion Include="Microsoft.Extensions.Caching.StackExchangeRedis" Version="8.0.8" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- Database - Other -->
  <!-- ============================================ -->
  <ItemGroup Label="Other Database Tools">
    <PackageVersion Include="Dapper" Version="2.1.66" />
    <PackageVersion Include="MySql.Data" Version="9.0.0" />
    <PackageVersion Include="Microsoft.Data.SqlClient" Version="6.1.1" />
    <PackageVersion Include="Npgsql" Version="8.0.3" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- Search & Indexing -->
  <!-- ============================================ -->
  <ItemGroup Label="Search and Indexing">
    <PackageVersion Include="Elasticsearch.Net" Version="7.17.5" />
    <PackageVersion Include="NEST" Version="7.17.5" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- Messaging & Event Bus -->
  <!-- ============================================ -->
  <ItemGroup Label="Messaging and Event Bus">
    <PackageVersion Include="MassTransit.RabbitMQ" Version="8.5.1" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- API & Web Frameworks -->
  <!-- ============================================ -->
  <ItemGroup Label="API and Web">
    <PackageVersion Include="Carter" Version="8.1.0" />
    <PackageVersion Include="Microsoft.AspNetCore.OpenApi" Version="8.0.7" />
    <PackageVersion Include="Swashbuckle.AspNetCore" Version="6.4.0" />
    <PackageVersion Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.8" />
    <PackageVersion Include="Microsoft.AspNetCore.SignalR" Version="1.2.0" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- Health Checks -->
  <!-- ============================================ -->
  <ItemGroup Label="Health Checks">
    <PackageVersion Include="AspNetCore.HealthChecks.MongoDb" Version="9.0.0" />
    <PackageVersion Include="AspNetCore.HealthChecks.MySql" Version="8.0.0" />
    <PackageVersion Include="AspNetCore.HealthChecks.NpgSql" Version="8.0.0" />
    <PackageVersion Include="AspNetCore.HealthChecks.Redis" Version="8.0.1" />
    <PackageVersion Include="AspNetCore.HealthChecks.SqlServer" Version="8.0.0" />
    <PackageVersion Include="AspNetCore.HealthChecks.UI.Client" Version="8.0.0" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- gRPC -->
  <!-- ============================================ -->
  <ItemGroup Label="gRPC">
    <PackageVersion Include="Grpc.AspNetCore" Version="2.65.0" />
    <PackageVersion Include="Grpc.Net.Client" Version="2.65.0" />
    <PackageVersion Include="Grpc.Tools" Version="2.66.0" />
    <PackageVersion Include="Google.Protobuf" Version="3.28.0" />
    <PackageVersion Include="microsoft.aspnetcore.grpc.jsontranscoding" Version="8.0.8" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- HTTP Client & Resilience -->
  <!-- ============================================ -->
  <ItemGroup Label="HTTP Client and Resilience">
    <PackageVersion Include="Refit.HttpClientFactory" Version="8.0.0" />
    <PackageVersion Include="Polly" Version="8.6.2" />
    <PackageVersion Include="Polly.Extensions.Http" Version="3.0.0" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- Logging & Observability -->
  <!-- ============================================ -->
  <ItemGroup Label="Logging">
    <PackageVersion Include="Serilog" Version="4.0.1" />
    <PackageVersion Include="Serilog.AspNetCore" Version="8.0.2" />
    <PackageVersion Include="Serilog.Sinks.Console" Version="6.0.0" />
    <PackageVersion Include="Serilog.Sinks.OpenTelemetry" Version="4.1.0" />
    <PackageVersion Include="Serilog.Sinks.Seq" Version="8.0.0" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- OpenTelemetry -->
  <!-- ============================================ -->
  <ItemGroup Label="OpenTelemetry">
    <PackageVersion Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.9.0" />
    <PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.9.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.9.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Http" Version="1.9.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Runtime" Version="1.9.0" />
    <PackageVersion Include="SharpAbp.Abp.OpenTelemetry.Exporter.Prometheus.AspNetCore" Version="3.1.0" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- Job Scheduling -->
  <!-- ============================================ -->
  <ItemGroup Label="Job Scheduling">
    <PackageVersion Include="Quartz" Version="3.13.1" />
    <PackageVersion Include="Quartz.Extensions.Hosting" Version="3.13.1" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- API Gateway -->
  <!-- ============================================ -->
  <ItemGroup Label="API Gateway">
    <PackageVersion Include="Yarp.ReverseProxy" Version="2.1.0" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- Storage & File Management -->
  <!-- ============================================ -->
  <ItemGroup Label="Storage and File Management">
    <PackageVersion Include="Minio" Version="6.0.3" />
    <PackageVersion Include="EPPlus" Version="7.7.1" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- Microsoft Extensions -->
  <!-- ============================================ -->
  <ItemGroup Label="Microsoft Extensions">
    <PackageVersion Include="Microsoft.Extensions.Hosting" Version="8.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.Binder" Version="8.0.2" />
    <PackageVersion Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="8.0.0" />
    <PackageVersion Include="Microsoft.FeatureManagement.AspNetCore" Version="3.4.0" />
  </ItemGroup>
  <!-- ============================================ -->
  <!-- Utilities & Helpers -->
  <!-- ============================================ -->
  <ItemGroup Label="Utilities and Helpers">
    <PackageVersion Include="Newtonsoft.Json" Version="13.0.3" />
    <PackageVersion Include="Json.Formater" Version="1.0.0" />
  </ItemGroup>
</Project>
</file>

</files>
